
############################
# This script creates a list of registers to read during DFA.
# It creates an hpp file per device
# ##########################


import re
import os
import sys
import time
import bisect

from enum import IntEnum
from dataclasses import dataclass
@dataclass
class RegCollection:  # This data-class holds information on the registers-block we are currently working on
    startAddr   : int = None
    startUnit   : int = None
    startType   : int = None
    startEngType: str = None
    count       : int = 0
    unitRegName : str = None

### The header variable below is the header of each hpp file that is created by this script
header = """
#pragma once

// ---------------------------------------------
// NOTE: this file is auto-generated by a script: """ + __file__+ \
"""
// ---------------------------------------------

#include <vector>
#include "runtime/common/device/dfa_base.hpp"

inline const std::vector<RegsBlock> regsToRead"""

### Return the header
def getHeader(dev):
    return header +dev+" = {\n"

g3WoRegs = []

def getG3WoRegs():
    specRoot = os.environ.get('SPECS_ROOT_H9')
    fileName = specRoot + "/" + "gaudi3/all_regs_extended.txt"

    # Open the file and process each line
    with open(fileName, 'r') as file:
        for line in file:
            columns = line.split()
            hex_number, attr = columns[0], columns[1]
            if attr == 'WO':
                g3WoRegs.append(hex_number)
    return

### Returns the specs file that holds all the registers of the given device
def getSpecFileName(device):
    if (device == "Gaudi3"):
        specRoot = os.environ.get('SPECS_ROOT_H9')
    else:
        specRoot = os.environ.get('SPECS_ROOT')

    return specRoot + "/" + device.lower() + "/all_regs.txt"

### returns the file name (including path) of the hpp file (for each given device)
def getReadRegFileName(device):
    return outputPath + "/dfa_read_" + device.lower() + "_regs.hpp"

### Check if reading a register is allowed (privilege wise)
def checkPriv(dev, fields):
    if dev == "Gaudi":
         return False

    elif (dev == "Gaudi2") or (dev == "Gaudi3"):
        if (fields[4] == '1'):
             return True

        # For G3, check if WO (dmesg err if we read a WO reg)
        if (dev == "Gaudi3"):
            addrToFind = fields[0]
            indx = bisect.bisect_left(g3WoRegs, addrToFind)

            if indx != len(g3WoRegs) and g3WoRegs[indx] == addrToFind:
                return True

        return False

    sys.exit("Dev " + dev + " not handled")

### This function checks if a register from the specs should be read
# It gets the device type, the register line from specs, match patterns and exclude patterns
# Checks if should skip because of privilege
# Checks if the register unit matches any of the patters in matches list
# If it does, it checks if the register is in the exclude list
# Return: 1) Should we read this register
#         2) a list indicating the BlockType (currently only ALL, ALL1), EngGrp (NONE, TPC, MME, ROT, etc)
def checkMatch(dev, fields, matches, exclude):
    priv = checkPriv(dev, fields)
    if priv: #privilege should be 0
        return (False, ["ALL", "NONE"])

    unitName = fields[1]
    for matchIdx in range(0, len(matches)):
        if re.search(matches[matchIdx][0], unitName):
            block_type = "ALL"
            if len(matches[matchIdx]) > 2:
                block_type = matches[matchIdx][2]
            for excludeIdx in range(0, len(exclude)):
                excludeStr = exclude[excludeIdx][0]
                excludeBlockType = exclude[excludeIdx][1]
                #
                if re.search(excludeStr, fields[2]):
                    # if we find in exclude, we mark it by BLOCK.NONE
                    return (True, [excludeBlockType, "NONE"])
            return (True, [block_type, matches[matchIdx][1]])

    return (False, ["ALL", "NONE"])

### This function checks if a given register matches the match-with-size list
# It returns the same as the match index and the EngGrp (NONE, TPC, MME, ROT, etc)
def checkMatchWithSize(fields, matchWithSize):
    unitName = fields[1]
    for matchIdx in range(0, len(matchWithSize)):
        if re.search(matchWithSize[matchIdx][0], unitName):
            return (True, [matchIdx, matchWithSize[matchIdx][1]])
    return (False, [0, 0])

### This function (for gaudi1) returns the engine id. This function is called after a register to read
### is found and parse the unit name to find the engine id based on the engine type
def parseEngG1(engType, unit):
    if engType == "TPC":
        m = re.search('TPC(\d*)', unit)
        if not m:
            sys.exit("ERROR: Could not parse tpc" + unit)
        else:
            return int(m.group(1))
    elif engType == "MME":
        m = re.search('MME(\d*)', unit)
        if not m:
            sys.exit("ERROR: Could not parse mme" + unit)
        else:
            return int(int(m.group(1)) / 2)
    elif engType == "DMA":
        m = re.search('DMA(\d*)', unit)
        if not m:
            sys.exit("ERROR: Could not parse dma" + unit)
        else:
            return int(m.group(1))
    elif engType == "NIC":
        m = re.search('NIC(\d*)', unit)
        if not m:
            sys.exit("ERROR: Could not parse nic" + unit)
        else:
            return int(m.group(1))

    else:
        sys.exit("Could not find engType " + engType)

### See parseEngG1 for function description
def parseEngG2(engType, unit):
    if engType == "TPC":
        m = re.search('DCORE(\d*)_TPC(\d*)', unit)
        if not m:
            sys.exit("ERROR: Could not parse tpc" + unit)
        else:
            return int(m.group(1)) * 6 + int(m.group(2))
    elif engType == "MME":
        m = re.search('DCORE(\d*)_MME', unit)
        if not m:
            sys.exit("ERROR: Could not parse mme " + unit)
        else:
            return int(m.group(1))
    elif engType == "DMA":
        m = re.search('DCORE(\d*)_EDMA(\d*)', unit)
        if not m:
            sys.exit("ERROR: Could not parse dma " + unit)
        else:
            return int(m.group(1)) * 2 + int(m.group(2))
    elif engType == "NIC":
        m = re.search('NIC(\d*)', unit)
        if not m:
            sys.exit("ERROR: Could not parse nic " + unit)
        else:
            return int(m.group(1))
    elif engType == "ROT":
        m = re.search('ROT(\d*)', unit)
        if not m:
            sys.exit("ERROR: Could not parse rot " + unit)
        else:
            return int(m.group(1))
    elif engType == "PRT":
        m = re.search('PRT(\d*)', unit)
        if not m:
            sys.exit("Could not parse prt " + unit)
        else:
            return int(m.group(1))

    else:
        sys.exit("Could not find engType" + engType)

### See parseEngG1 for function description
def parseEngG3(engType, unit):
    if engType == "TPC":
        m = re.search('HD(\d*)_TPC(\d*)', unit)
        if not m:
            sys.exit("ERROR: Could not parse tpc " + unit)
        else:
            return int(m.group(1)) * 8 + int(m.group(2))
    elif engType == "MME":
        m = re.search('HD(\d*)', unit)
        if not m:
            sys.exit("Could not parse mme " + unit)
        else:
            return int(m.group(1))
    elif engType == "ROT":
        m = re.search('HD(\d*)_ROT(\d*)', unit)
        if not m:
            sys.exit("Could not parse rot " + unit)
        else:
            hd = int(m.group(1))
            hdId = hd - 1 if hd < 4 else hd
            return int(hdId + int(m.group(2)))
    elif engType == "DMA":
        m = re.search('HD(\d*)_SEDMA(\d*)', unit)
        if not m:
            sys.exit("Could not parse dma " + unit)
        else:
            hd = int(m.group(1))
            hdId = hd - 1 if hd < 4 else hd
            return int(hdId + int(m.group(2)))
    elif engType == "PDMA":
        m = re.search('D(\d*)_SPDMA(\d*)', unit)
        if not m:
            sys.exit("Could not parse pdma " + unit)

        m2 = re.search('CH(\d*)', unit)
        if not m2:
            ch = 5 #use ch5 for cases that are not per channel (we don't use ch0 because it is used for LKD and not in mask)
        else:
            ch = int(m2.group(1))
        return (int(m.group(1)) * 2 + int(m.group(2))) * 6 + ch
    elif engType == "NIC":
        m = re.search('D(\d*)_NIC(\d*)', unit)
        if not m:
            sys.exit("Could not parse nic" + unit)
        else:
            return int(m.group(1)) * 6 + int(m.group(2))
    elif engType == "ARC_FARM":
        m = re.search('HD(\d*)_ARC_FARM_FARM', unit)
        if not m:
            sys.exit("Could not parse arc_farm " + unit)
        else:
            return int(m.group(1)) * 2
    elif engType == "ARC":
        m = re.search('HD(\d*)_ARC_FARM_ARC(\d*)', unit)
        if not m:
            sys.exit("Could not parse nic " + unit)
        else:
            return int(m.group(1)) * 2 + int(m.group(2))
    elif engType == "EDUP":
        m = re.search('HD(\d*)', unit)
        if not m:
            sys.exit("Could not parse edup " + unit)
        else:
            return int(m.group(1)) * 2

    else:
        sys.exit("Could not find engType " + engType)


### This function call the appropriate parsing function based on the device type
def parseEng(dev, engType, unit):
    if engType == "NONE":
        return -1
    if dev == "Gaudi":
        return parseEngG1(engType, unit)
    elif dev == "Gaudi2":
        return parseEngG2(engType, unit)
    elif dev == "Gaudi3":
        return parseEngG3(engType, unit)
    else:
        print("Device:", dev, "not found")
        sys.exit("Script error, device not found")

### This function dumps to file the registers-block that was found so far. It is called one
### we find an register to read that shouldn't be added to the current register block
def dumpToFile(fout, dev, regCollection):
    if regCollection.startAddr == None:
        return

    engId = parseEng(dev, regCollection.startEngType, regCollection.startUnit)

    fout.write(f"{{ {hex(regCollection.startAddr)}, {hex(regCollection.count * 4):>10}, BlockType::{regCollection.startType:<5}, ")
    fout.write(f"EngGrp::{regCollection.startEngType:<4}, {engId:>3} }}, // {regCollection.startUnit}.{regCollection.unitRegName}\n")
    clearRegCollection(regCollection)
    return

### This function clears the registers-block information. It is called after the registers-block was dumped
def clearRegCollection(regCollection):
    regCollection.startAddr   = None
    regCollection.startUnit   = str
    regCollection.startType   = None
    regCollection.startEngGrp = None
    regCollection.count       = 1
    regCollection.unitRegName = None

### Checks if the spec file header matches what we expected
def checkFileFormat(dev, fin):
    line   = fin.readline()
    fields = line.split(">")

    if dev == "Gaudi":
        return

    if ((dev == "Gaudi2") or (dev == "Gaudi3")):
        if not re.search("privilege", fields[4]):
            sys.exit(dev + " Bad file format in field 4 " + fields[4]);
        return

def addTpcDebugRegs(fout, dev):
    if (dev == "Gaudi2" or dev == "Gaudi3"):

        if (dev == "Gaudi2"):
            tpcEmlBaseAddrs = [
                  [ 0x1000007ff8040000, " 0"],
                  [ 0x1000007ff8240000, " 1"],
                  [ 0x1000007ff8440000, " 2"],
                  [ 0x1000007ff8640000, " 3"],
                  [ 0x1000007ff8840000, " 4"],
                  [ 0x1000007ff8a40000, " 5"],
                  [ 0x1000007ff9040000, " 6"],
                  [ 0x1000007ff9240000, " 7"],
                  [ 0x1000007ff9440000, " 8"],
                  [ 0x1000007ff9640000, " 9"],
                  [ 0x1000007ff9840000, "10"],
                  [ 0x1000007ff9a40000, "11"],
                  [ 0x1000007ffa040000, "12"],
                  [ 0x1000007ffa240000, "13"],
                  [ 0x1000007ffa440000, "14"],
                  [ 0x1000007ffa640000, "15"],
                  [ 0x1000007ffa840000, "16"],
                  [ 0x1000007ffaa40000, "17"],
                  [ 0x1000007ffb040000, "18"],
                  [ 0x1000007ffb240000, "19"],
                  [ 0x1000007ffb440000, "10"],
                  [ 0x1000007ffb640000, "21"],
                  [ 0x1000007ffb840000, "22"],
                  [ 0x1000007ffba40000, "23"],
            ]

        if (dev == "Gaudi3"):
            tpcEmlBaseAddrs = [
                [ 0x300007ff0040000, " 0"],
                [ 0x300007ff0240000, " 1"],
                [ 0x300007ff0440000, " 2"],
                [ 0x300007ff0640000, " 3"],
                [ 0x300007ff0840000, " 4"],
                [ 0x300007ff0a40000, " 5"],
                [ 0x300007ff0c40000, " 6"],
                [ 0x300007ff0e40000, " 7"],
                [ 0x300007ff1040000, " 8"],
                [ 0x300007ff1240000, " 9"],
                [ 0x300007ff1440000, "10"],
                [ 0x300007ff1640000, "11"],
                [ 0x300007ff1840000, "12"],
                [ 0x300007ff1a40000, "13"],
                [ 0x300007ff1c40000, "14"],
                [ 0x300007ff1e40000, "15"],
                [ 0x300007ff2040000, "16"],
                [ 0x300007ff2240000, "17"],
                [ 0x300007ff2440000, "18"],
                [ 0x300007ff2640000, "19"],
                [ 0x300007ff2840000, "20"],
                [ 0x300007ff2a40000, "21"],
                [ 0x300007ff2c40000, "22"],
                [ 0x300007ff2e40000, "23"],
                [ 0x300007ff3040000, "24"],
                [ 0x300007ff3240000, "25"],
                [ 0x300007ff3440000, "26"],
                [ 0x300007ff3640000, "27"],
                [ 0x300007ff3840000, "28"],
                [ 0x300007ff3a40000, "29"],
                [ 0x300007ff3c40000, "30"],
                [ 0x300007ff3e40000, "31"],
                [ 0x300007ff4040000, "32"],
                [ 0x300007ff4240000, "33"],
                [ 0x300007ff4440000, "34"],
                [ 0x300007ff4640000, "35"],
                [ 0x300007ff4840000, "36"],
                [ 0x300007ff4a40000, "37"],
                [ 0x300007ff4c40000, "38"],
                [ 0x300007ff4e40000, "39"],
                [ 0x300007ff5040000, "40"],
                [ 0x300007ff5240000, "41"],
                [ 0x300007ff5440000, "42"],
                [ 0x300007ff5640000, "43"],
                [ 0x300007ff5840000, "44"],
                [ 0x300007ff5a40000, "45"],
                [ 0x300007ff5c40000, "46"],
                [ 0x300007ff5e40000, "47"],
                [ 0x300007ff6040000, "48"],
                [ 0x300007ff6240000, "49"],
                [ 0x300007ff6440000, "50"],
                [ 0x300007ff6640000, "51"],
                [ 0x300007ff6840000, "52"],
                [ 0x300007ff6a40000, "53"],
                [ 0x300007ff6c40000, "54"],
                [ 0x300007ff6e40000, "55"],
                [ 0x300007ff7040000, "56"],
                [ 0x300007ff7240000, "57"],
                [ 0x300007ff7440000, "58"],
                [ 0x300007ff7640000, "59"],
                [ 0x300007ff7840000, "60"],
                [ 0x300007ff7a40000, "61"],
                [ 0x300007ff7c40000, "62"],
                [ 0x300007ff7e40000, "63"],
            ]

        tpcDebugOffsetSize = [
            [ 0x10000, 0x4000],
            [ 0x14000, 0x4000],
            [ 0x20000, 0x4000],
            [ 0x24000, 0x4000],
            [ 0x30000,  0x100],
            [ 0x40000,    0x4],
            [ 0x50000, 0x4000],
            [ 0x54000, 0x4000],
            [ 0x60000, 0x4000],
            [ 0x64000, 0x4000],
        ]

        for tpc in tpcEmlBaseAddrs:
            for offsetSize in tpcDebugOffsetSize:
                # reading on simulator adds minutes, doing it on a real device only
                fout.write(f"{{ {hex(tpc[0] + offsetSize[0])}, {hex(offsetSize[1]):>10}, BlockType::DEV_ONLY, EngGrp::TPC ,  {tpc[1]} }}, // TPC SPECIAL REGS\n")


# dev:            "Gaudi", "Gaudi2", etc
# matches:        units to search (regex)
# exclude:        Exclude registers (based on register name) -> set a type field (for example, SIM_ONLY)
# matchWitchSize: find the unit address but use 0x8000 as size (for DCCM)
def parseSpecFile(dev, matches, exclude, matchWithSize):
    specFile     = getSpecFileName(dev)
    outFile      = getReadRegFileName(dev)
    regCollected = RegCollection()

    # open spec file and hpp file
    with open(specFile, 'r') as fin, open(outFile, 'w') as fout:
        checkFileFormat(dev, fin)
        fout.write(getHeader(dev))
        for line in fin: # go over all the lines in the spec file

            fields = line.split()

            unitName = fields[1]
            unitRegName = fields[2]
            found, info = checkMatchWithSize(fields, matchWithSize) #special case: find the addr of reg, size is always 0x8000
            if found:
                dumpToFile(fout, dev, regCollected) #dump what we collected so far

                currAddr = int(fields[0], 16)
                engGrp   = info[1]
                engId    = parseEng(dev, engGrp, unitName)

                fout.write(f"{{ {hex(currAddr         )}, {hex(0x4000):>10}, BlockType::ALL  , EngGrp::{engGrp:<4}, {engId:>3} }}, // {unitName}.{unitRegName}\n")
                fout.write(f"{{ {hex(currAddr + 0x4000)}, {hex(0x4000):>10}, BlockType::ALL  , EngGrp::{engGrp:<4}, {engId:>3} }}, // {unitName}.{unitRegName}\n")
                continue

            found, info = checkMatch(dev, fields, matches, exclude)
            type = info[0]
            engGrp = info[1]


            if found == False:
                dumpToFile(fout, dev, regCollected) #dump what we collected so far
                continue

            currAddr = int(fields[0], 16)

            if regCollected.startAddr == None: #Nothing found so far
                regCollected = RegCollection(currAddr, unitName, type, engGrp, 1, unitRegName) #add this reg as first one

            elif currAddr == (regCollected.startAddr + 4 * regCollected.count) and type == regCollected.startType and unitName == regCollected.startUnit: #current found is just after previous one (accumulate)
                regCollected.count += 1
                if regCollected.count == 0x4000 / 4: # size must not be more than 16K (LKD requirement).
                    dumpToFile(fout, dev, regCollected) #dump what we collected so far

            elif regCollected.startAddr != None:
                dumpToFile(fout, dev, regCollected) #dump what we collected so far
                regCollected = RegCollection(currAddr, unitName, type, engGrp, 1, unitRegName)

        dumpToFile(fout, dev, regCollected)

        addTpcDebugRegs(fout, dev)
        fout.write("};")

def parseGaudi():
    dev = "Gaudi"
    matches = [
            ["MME.*_CTRL$",       "MME" ],
            ["MME[0,2]_QM",       "MME" ],
            ["MME[0,2]_ACC$",     "MME" ],
            ["MME[0,2]_SBAB$",    "MME" ],
            ["SYNC_MNGR",         "NONE"],
            ["DMA.*_CORE",        "DMA" ],
            ["TPC.*_QM$",         "TPC" ],
            ["TPC.*_CFG$",        "TPC" ],
            ["TPC.*_EML",         "TPC" ],

            ["DMA.*_QM",          "DMA" ],

            ["NIC[0-4]_QPC[0-1]", "NIC" ],
            ["NIC[0-4]_RX",       "NIC" ],
            ["NIC[0-4]_TX",       "NIC" ],
            ["NIC[0-4]_TMR",      "NIC" ]
    ]

    #            Exclude string,       Exclude Type
    #            ==================================
    excludes = [["SYNC_MNGR_OBJS_SM_SEC", "NONE"],
                ["SYNC_MNGR_OBJS_MON", "ALL1"] # Monitors can't be read with other parts of the SYNC_MNGR
               ]
    matchWithSize = []

    parseSpecFile(dev, matches, excludes, matchWithSize)

def parseGaudi2():
    dev = "Gaudi2"
    matches = [
               ["DCORE[0-9]*_TPC[0-5]*_QM_ARC_AUX", "TPC"],
               ["DCORE[0-9]*_TPC[0-5]*_QM$",        "TPC"],
               ["DCORE[0-9]*_TPC[0-5]*_CFG",        "TPC"],
               ["DCORE[0-9]*_TPC[0-5]*_EML",        "TPC"],

               ["DCORE.*_MME.*ARC_AUX",             "MME"],
               ["DCORE.*_MME.*ARC_DUP_ENG",         "MME"],
               ["DCORE.*_MME.*QM$",                 "MME"],
               ["DCORE.*_MME.*CTRL_LO",             "MME"],
               ["DCORE.*_MME.*CTRL_HI",             "MME"],
               ["DCORE.*_MME.*QM_ARC_ACP_ENG",      "MME"],
               ["DCORE.*_MME.*SBTE[0-9]$",          "MME"],
               ["DCORE.*_MME.*ACC$",                "MME"],

               ["SYNC_MNGR",                        "NONE"],

               ["DCORE.*_EDMA.*_QM$",               "DMA"],
               ["DCORE.*_EDMA.*_QM_ARC_AUX",        "DMA"],
               ["DCORE.*_EDMA.*_CORE",              "DMA"],

               ["DCORE.*_TPC[0-5]_QM$",             "TPC"],
               ["DCORE.*_TPC[0-5]_QM_ARC_AUX",      "TPC"],
               ["DCORE.*_TPC[0-5]_CFG",             "TPC"],

               ["PDMA.*QM$",                        "NONE"],
               ["PDMA.*QM_ARC_AUX",                 "NONE"],
               ["PDMA.*CORE",                       "NONE"],

               ["ROT.*_QM$",                        "ROT"],
               ["ROT.*_QM_ARC_AUX",                 "ROT"],
               ["ROT[0-9]$",                        "ROT"],

               ["ARC_FARM_FARM",                    "NONE"],
               ["ARC_FARM_ARC[0-9]_AUX",            "NONE"],
               ["ARC_FARM_ARC[0-9]_DUP_ENG",        "NONE"],
               ["ARC_FARM_ARC[0-9]_ACP_ENG",        "NONE"],

               ["NIC[0-9]*_QM[0-9]",                "NIC"],
               ["NIC[0-9]*_QM_ARC_AUX[0-9]",        "NIC"],

               ["NIC[0-9].*_QPC[0-1]",              "NIC"],
               ["NIC[0-9].*_RX",                    "NIC"],
               ["NIC[0-9].*_TX",                    "NIC"],
               ["NIC[0-9].*_TMR",                   "NIC"],
               ["NIC[0-9].*_SERDES",                "NIC"],
               ["NIC[0-9].*_PHY",                   "NIC"],
               ["NIC[0-9].*_MAC",                   "NIC"],
               ["PRT[0-9].*_MAC_*",                 "PRT"],

               # "^(?!.*(TPC6|NIC)).*MSTR.*$"
              ]

    excludes = [
                ["RES_RING2", "NONE"],
                ["RES_RING3", "NONE"],
                ["REQ_RING",  "NONE"],
                ["SPECIAL",  "NONE"],
                ["RR_SHRD_HBW_SEC_RANGE_MIN_SHORT_LO_0", "NONE"], #bug in LKD? Asked by LKD to remove for now 2023_09
                ["SM_SEI_MASK", "NONE"],                          #bug in LKD? Asked by LKD to remove for now 2023_09
                ["WR_COMP_MAX_OUTSTAND", "NONE"] # 2024_03_03: This reg was just added, reading it causes an issue with an
                                                 #             older FW that is still in use
               ]
    matchWithSize = [
                     ["DCORE[0-9]*_TPC[0-5]*_QM_DCCM", "TPC"],
                     ["DCORE.*_MME.*ARC_DCCM",         "MME"],
                     ["ARC_FARM_ARC[0-9]_DCCM",        "NONE"],
                     ["NIC[0-9]*_QM_DCCM",             "NIC"],
                     ["PDMA.*QM_ARC_DCCM",             "NONE"],
                     ["ROT.*_QM_ARC_DCCM",             "ROT"],
                     ["EDMA[0-1]*_QM_DCCM",            "DMA"],
                    ]


    parseSpecFile(dev, matches, excludes, matchWithSize)

def parseGaudi3():
    dev = "Gaudi3"
    matches = [
        ["HD[0-7]*_TPC[0-7]*_QM_ARC_AUX", "TPC"],
        ["HD[0-7]*_TPC[0-7]*_QM$",        "TPC"],
        ["HD[0-7]*_TPC[0-7]*_CFG",        "TPC"],
        ["HD[0-9]*_TPC[0-7]*_EML",        "TPC"],

        ["HD[0-7]*_MME.*ARC_AUX",         "MME"],
        ["HD[0-7]*_MME.*QM$",             "MME"],
        ["HD[0-7]*_MME.*CTRL_LO",         "MME"],
        ["HD[0-7]*_MME.*CTRL_HI",         "MME"],
        ["HD[0-7]*_MME.*SBTE[0-9]$",      "MME"],
        ["HD[0-7]*_MME.*ACC$",            "MME"],

        ["SYNC_MNGR",                     "NONE"],

        ["HD[0-7]*_SEDMA.*_QM$",          "DMA"],
        ["HD[0-7]*_SEDMA.*_QM_ARC_AUX",   "DMA"],
        ["HD[0-7]*_SEDMA.*_CS_DBG",       "DMA"],
        ["HD[0-7]*_SEDMA.*_FUNNEL",       "DMA"],
        ["HD[0-7]*_SEDMA.*_CH",           "DMA"],

        ["HD[0-7]*_TPC[0-7]_QM$",         "TPC"],
        ["HD[0-7]*_TPC[0-7]_QM_ARC_AUX",  "TPC"],
        ["HD[0-7]*_TPC[0-7]_CFG",         "TPC"],
        ["HD[0-7]*_TPC[0-7]_SMT$",        "TPC"],

        ["D[0-1].*_SPDMA[0-1]_CH",        "PDMA"],
        ["D[0-1].*_SPDMA[0-1]_CMN",       "PDMA"],
        ["D[0-1].*_SPDMA[0-1]_DUP_ENG",   "PDMA"],

        ["ROT.*_QM$",                     "ROT"],
        ["ROT.*_QM_ARC_AUX",              "ROT"],
        ["ROT[0-9]$",                     "ROT"],

        ["ARC_FARM_FARM",                 "ARC_FARM"],
        ["ARC_FARM_ARC[0-9]_AUX",         "ARC"],
        ["ARC_FARM_ARC[0-9]_DUP_ENG",     "ARC"],
        ["ARC_FARM_ARC[0-9]_AF",          "ARC"],
        ["ARC_FARM_ARC[0-9]_AF_SEC",      "ARC"],
        ["ARC_FARM_ARC[0-9]_ACP_ENG",     "ARC"],

        ["HD[0-7].*_SCD_EDUP_ENG",        "EDUP"],

        ["NIC[0-9]*_QM$",                 "NIC"],
        ["NIC[0-9]*_QM_ARC_AUX",          "NIC"],

        ["NIC[0-9].*_QPC",                "NIC"],
        ["NIC[0-9].*_RX",                 "NIC"],
        ["NIC[0-9].*_TX",                 "NIC"],
        ["NIC[0-9].*_TMR",                "NIC"],
        ["NIC[0-9].*_PHY",                "NIC"],
        ["NIC[0-9].*_MAC",                "NIC"]
    ]

    excludes = [
        ["RES_RING2", "NONE"],
        ["RES_RING3", "NONE"],
        ["REQ_RING",  "NONE"],
        ["GLBL_ERR_CFG1", "NONE"],
        ["CCL_RANGE_DIS", "NONE"], # HD0_TPC0_CFG CCL_RANGE_DIS
        ["CCL_SCRAM", "NONE"],
        ["SPECIAL",  "NONE"],
        ["PHY_CFG_ACCESS", "NONE"] # Causing dmesg errors
    ]
    matchWithSize = [
        ["HD[0-7]*_TPC[0-7]*_QM_DCCM",    "TPC"],
        ["HD[0-7]_MME_QM_ARC_DCCM",       "MME"],
        ["ARC_FARM_ARC[0-9]_DCCM",        "ARC"],
        ["PDMA.*QM_ARC_DCCM",             "PDMA"],
        ["ROT.*_QM_ARC_DCCM",             "ROT"],
        ["SEDMA[0-1]*_QM_DCCM",           "DMA"],
    ]

    getG3WoRegs()
    parseSpecFile(dev, matches, excludes, matchWithSize)


if len(sys.argv) != 2:
    sys.exit("Path for output must be given")

outputPath = sys.argv[1]
print("Creating DFA read register list in " + outputPath)

start = time.time()
parseGaudi()
parseGaudi2()
parseGaudi3()
end = time.time()
print("Done in ",end - start, "seconds")

#Check the output file by using "cat dfa_read_gaudi2_regs.hpp |cut -d'/' -f3|uniq|less"
