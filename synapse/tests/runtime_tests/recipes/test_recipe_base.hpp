#pragma once

#include "test_tensors_container.hpp"
#include "test_sections_container.hpp"

#include "test_host_buffer_alloc.hpp"
#include "test_recipe_interface.hpp"

#include <mutex>

class TestRecipeBase : public TestRecipeInterface
{
public:
    typedef std::vector<synRetrievedLaunchTensorInfoExt> LaunchTensorsInfoDB;

    TestRecipeBase(std::string const& uniqueRecipeName,  // name generated by makeUniqueRecipeName
                   synDeviceType      deviceType,
                   unsigned           inputTensorsAmount,
                   unsigned           innerTensorsAmount,
                   unsigned           outputTensorsAmount,
                   unsigned           uniqueSectionsAmount,
                   bool               isEagerMode);

    TestRecipeBase(TestRecipeBase&& other) noexcept;

    virtual ~TestRecipeBase() override;

    void      getIsConstProperty(bool& isConst, const synSectionId sectionId) const override;
    void      getSectionSizeProperty(uint64_t& sectionSize, const synSectionId sectionId) const override;
    synStatus getSectionHostBufferProperty(uint64_t& hostBuffer, const synSectionId sectionId) const override;

    void recipeSerialize() override;
    bool recipeDeserialize() override;
    void generateRecipe() override;

    const synRecipeHandle& getRecipe() const override { return m_recipeHandle; }

    virtual uint64_t getWorkspaceSize() const override;

    uint64_t getTensorSizeInput(unsigned tensorIndex) const override;
    uint64_t getTensorSizeOutput(unsigned tensorIndex) const override;

    uint64_t getDynamicTensorMaxDimSizeInput(unsigned tensorIndex, unsigned dimIndex) const override;
    uint64_t getDynamicTensorMaxDimSizeOutput(unsigned tensorIndex, unsigned dimIndex) const override;

    virtual const SectionInfoVec& getUniqueSectionsInfo() const override { return m_uniqueSectionsInfo; }
    virtual SectionMemoryVec&     getUniqueSectionsMemory() override { return m_uniqueSectionsMemory; }

    unsigned getTensorInfoVecSizeInput() const override { return m_tensorInfoVecInputs.size(); }
    unsigned getTensorInfoVecSizeOutput() const override { return m_tensorInfoVecOutputs.size(); }
    unsigned getTensorInfoVecSize() const override
    {
        return getTensorInfoVecSizeInput() + getTensorInfoVecSizeOutput();
    }

    virtual const TensorInfoVec& getTensorInfoVecInputs() const override { return m_tensorInfoVecInputs; }
    virtual const TensorInfoVec& getTensorInfoVecOutputs() const override { return m_tensorInfoVecOutputs; }

    const TensorInfo* getTensorInfoInput(unsigned tensorIndex) const override
    {
        return getTensorInfo(tensorIndex, true);
    }
    const TensorInfo* getTensorInfoOutput(unsigned tensorIndex) const override
    {
        return getTensorInfo(tensorIndex, false);
    }
    const TensorInfo* getTensorInfo(const std::string& tensorName) const override;

    virtual const std::vector<const char*> getTensorsName() const override;

    bool isInputOnConstSection(unsigned tensorIndex) const override { return isOnConstSection(tensorIndex, true); }

    bool isOutputOnConstSection(unsigned tensorIndex) const override { return isOnConstSection(tensorIndex, false); }

    unsigned getNumberInputConstTensors() const override;

    static synTensorDescriptor getTensorDescriptor(synDataType   dataType,
                                                   const TSize*  tensorSizes,
                                                   TSize         dims,
                                                   const char*   name,
                                                   unsigned*     strides,
                                                   void*         ptr,
                                                   bool          isQuantized,
                                                   const TSize*  minSizes,
                                                   synTensorType tensorType);

    void extractLaunchTensorsInfo(LaunchTensorsInfoDB& launchTensorsInfo) const;

    void getConstSectionsIds(std::vector<synSectionId>& constSectionIdDB) const;

    void clearConstSectionHostBuffers(const std::vector<synSectionId>& constSectionIds) const override;

    void createGraphHandle() { return _createGraphHandle(); };
    void graphCreation() { return _graphCreation(); };
    void graphCompile() { return _graphCompile(); };

    inline synGraphHandle getGraphHandle() { return m_graphHandle; };

    virtual void
    getConstSectionInfo(uint64_t& sectionSize, void*& hostSectionData, synSectionId sectionId) const override;

    virtual void compileGraph();

    void                         retrieveAmountOfExternalTensors(uint64_t& amountOfExternalTensors) override;
    const std::vector<uint64_t>& retrieveTensorsId() const override;
    const std::vector<uint64_t>& retrieveOrderedTensorsId() const override;
    // Maps a single event to a given launch-tensor
    void mapEventToExternalTensor(TestEvent& rEvent, const synLaunchTensorInfoExt* launchTensorsInfo) const override;
    std::string getRecipeName() const;

protected:
    void _createGraphHandle() override;
    void _destroyGraphHandle() override;

    void _graphCompile();
    void _extractTensorsId();
    void _extractExecutionOrderedTensorIds();

    virtual void _graphCreation() = 0;

    std::string getFileFullPath() const;

    const void* getHostBuffer(bool                         isInput,
                              unsigned                     tensorIndex,
                              const TensorMemoryVec&       tensorInfoVec,
                              const std::vector<uint64_t>& rConstSectionsHostBuffers) const;

    const TensorInfo* getTensorInfo(unsigned tensorIndex, bool isInput) const;
    bool              isOnConstSection(unsigned tensorIndex, bool isInput) const;

    const synDeviceType   m_deviceType;
    synRecipeHandle       m_recipeHandle;
    std::vector<uint64_t> m_tensorIds;
    std::vector<uint64_t> m_orderedTensorIds;  // By execution order (SFG related)

    // Device-side (HBM) buffers for input and output
    TensorInfoVec m_tensorInfoVecInputs  = {};
    TensorInfoVec m_tensorInfoVecOutputs = {};

    // A unique Section is created prior of creating the Tensors
    // The TensorInfo will hold the section index it resides at (otherwise - a dedicated Section per Tensor)
    SectionInfoVec m_uniqueSectionsInfo = {};

    SectionMemoryVec m_uniqueSectionsMemory = {};

    bool           m_eagerMode;
    synGraphHandle m_graphHandle;

    // Will be used when creating the graph (by the _graphCreation() method)
    // We will hold it here, so we can break the compilation into create-graph & compile-graph,
    // allowing to update the basic graph pre-compiling
    TestTensorsContainer  m_inputTensorsContainer;
    TestTensorsContainer  m_innerTensorsContainer;
    TestTensorsContainer  m_outputTensorsContainer;
    TestSectionsContainer m_uniqueSections;

    unsigned m_numOfExternalTensors;

    template<class T>
    static std::string toStringImpl(T const& v)
    {
        return std::to_string(v);
    }
    static std::string toStringImpl(std::string const& v) { return v; }
    static std::string toStringImpl(const char* v) { return v; }
    template<class T>
    static std::string toStringImpl(std::vector<T> const& v)
    {
        std::string str;
        for (unsigned i = 0; i < v.size(); i++)
        {
            str += std::to_string(v[i]);
            if (i != v.size() - 1)
            {
                str += 'x';
            }
        }
        return str;
    }
    template<class T, size_t N>
    static std::string toStringImpl(std::array<T, N> const& v)
    {
        std::string str;
        for (unsigned i = 0; i < v.size(); i++)
        {
            str += std::to_string(v[i]);
            if (i != v.size() - 1)
            {
                str += 'x';
            }
        }
        return str;
    }

    template<class TTestClass, class... TArgs>
    static std::string makeUniqueRecipeName(TArgs const&... args)
    {
        std::string decoratedClassName = "rt_infra_" + std::string(typeid(TTestClass).name());
        return (decoratedClassName + ... + ("_" + toStringImpl(args)));
    }

private:
    void destroy();

    static std::mutex m_threadMutex;
    const std::string m_filename;
};
