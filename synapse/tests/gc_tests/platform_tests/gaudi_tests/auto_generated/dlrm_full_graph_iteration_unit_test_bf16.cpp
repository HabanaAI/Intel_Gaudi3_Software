


/***************************************************************************************
 ***************************************************************************************
 ***************************************************************************************
 ***                                                                                 ***
 ***        This file is auto-generated. DO NOT EDIT!!!                              ***
 ***                                                                                 ***
 ***        To update this file use json_to_synapse.py script from the gc_tools      ***
 ***                                                                                 ***
 ***************************************************************************************
 ***************************************************************************************
 ***************************************************************************************/
#include "synapse_api.h"
#include <vector>
#include <cstring>
#include <cstdint>
#include "perf_lib_layer_params.h"
#include "../gc_autogen_test.h"
#include "../dlrm_test.inl"
#include "habana_global_conf.h"

class SynGaudiDLRMTestBFloat16 : public SynGaudiAutoGenTest
{
public:
    void run_full_dlrm_iteration();
};

TEST_F_GC(SynGaudiDLRMTestBFloat16,
          DISABLED_dlrm_full_graph_single_iteration_test_ASIC_CI)  // disabled due to removed support for tpc guid
{
    run_full_dlrm_iteration();

    run_full_dlrm_iteration();
}
void SynGaudiDLRMTestBFloat16::run_full_dlrm_iteration()
{

    uint32_t deviceId = _getDeviceId();
    synGraphHandle graphHandle;
    synStatus status = synGraphCreate(&graphHandle, synDeviceGaudi);
    ASSERT_TRUE(status == synSuccess && "synGraphCreate failed!");
    clearDramMap();
    GCFG_CHECK_SECTION_OVERLAP.setValue(false);

    /*************
     * bot_l_0_linear node
     * inputs: [X_int(128, 1, 1, 13)(dtype=bf16), bot_l_0_linear_weight(1, 1, 13, 512)(dtype=bf16), bot_l_0_linear_bias[512](dtype=bf16)]
     * output: [bot_l_0_linear_output(128, 1, 1, 512)(dtype=bf16)]
     *************/
    synConvolutionParams bot_l_0_linear_kernel_params;
    bot_l_0_linear_kernel_params.dH = 1;
    bot_l_0_linear_kernel_params.dW = 1;
    bot_l_0_linear_kernel_params.kH = 1;
    bot_l_0_linear_kernel_params.kW = 1;
    bot_l_0_linear_kernel_params.padT = 0;
    bot_l_0_linear_kernel_params.padB = 0;
    bot_l_0_linear_kernel_params.padL = 0;
    bot_l_0_linear_kernel_params.padR = 0;
    bot_l_0_linear_kernel_params.dilH = 1;
    bot_l_0_linear_kernel_params.dilW = 1;

    // create X_int tensor
    const unsigned X_int_sizes[] = {128, 1, 1, 13};
    uint64_t X_int_dram;
    unsigned X_int_size = 128*1*1*13;
    unsigned X_int_size_in_bytes = X_int_size * sizeof(bfloat16) ;
    status = hbmAlloc(X_int_size_in_bytes, &X_int_dram, "X_int");
    ASSERT_TRUE(status == synSuccess && "X_int dram malloc failed!");
    synLaunchTensorInfo X_int_tr_info = {"X_int", X_int_dram};
    UNUSED(X_int_tr_info); // For single op tests
    synTensor X_int = createTensor(4U, syn_type_bf16, X_int_sizes, true, "X_int");
    UNUSED(X_int); // For single op tests

    // create bot_l_0_linear_weight tensor
    const unsigned bot_l_0_linear_weight_sizes[] = {1, 1, 13, 512};
    uint64_t bot_l_0_linear_weight_dram;
    unsigned bot_l_0_linear_weight_size = 1*1*13*512;
    unsigned bot_l_0_linear_weight_size_in_bytes = bot_l_0_linear_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(bot_l_0_linear_weight_size_in_bytes, &bot_l_0_linear_weight_dram, "bot_l_0_linear_weight");
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_weight dram malloc failed!");
    synLaunchTensorInfo bot_l_0_linear_weight_tr_info = {"bot_l_0_linear_weight", bot_l_0_linear_weight_dram};
    UNUSED(bot_l_0_linear_weight_tr_info); // For single op tests
    synTensor bot_l_0_linear_weight = createTensor(4U, syn_type_bf16, bot_l_0_linear_weight_sizes, true, "bot_l_0_linear_weight");
    UNUSED(bot_l_0_linear_weight); // For single op tests

    // create bot_l_0_linear_bias tensor
    const unsigned bot_l_0_linear_bias_sizes[] = {512,};
    uint64_t bot_l_0_linear_bias_dram;
    unsigned bot_l_0_linear_bias_size = 512;
    unsigned bot_l_0_linear_bias_size_in_bytes = bot_l_0_linear_bias_size * sizeof(bfloat16) ;
    status = hbmAlloc(bot_l_0_linear_bias_size_in_bytes, &bot_l_0_linear_bias_dram, "bot_l_0_linear_bias");
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_bias dram malloc failed!");
    synLaunchTensorInfo bot_l_0_linear_bias_tr_info = {"bot_l_0_linear_bias", bot_l_0_linear_bias_dram};
    UNUSED(bot_l_0_linear_bias_tr_info); // For single op tests
    synTensor bot_l_0_linear_bias = createTensor(1U, syn_type_bf16, bot_l_0_linear_bias_sizes, true, "bot_l_0_linear_bias");
    UNUSED(bot_l_0_linear_bias); // For single op tests

    synTensor bot_l_0_linear_in_vec[4] = {X_int, bot_l_0_linear_weight, bot_l_0_linear_bias, nullptr};


    // create bot_l_0_linear_output tensor
    const unsigned bot_l_0_linear_output_sizes[] = {128, 1, 1, 512};
    synTensor bot_l_0_linear_output = createTensor(4U, syn_type_bf16, bot_l_0_linear_output_sizes, false, "bot_l_0_linear_output");
    UNUSED(bot_l_0_linear_output); // For single op tests

    synTensor bot_l_0_linear_out_vec[1] = {bot_l_0_linear_output};


    status = synNodeCreate(graphHandle, bot_l_0_linear_in_vec, bot_l_0_linear_out_vec, 4, 1, (void *)&bot_l_0_linear_kernel_params, sizeof(bot_l_0_linear_kernel_params), "spatial_convolution", "bot_l_0_linear", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bot_l_0_linear failed!");

    /*************
     * bot_l_0_relu node
     * inputs: [bot_l_0_linear_output(128, 1, 1, 512)(dtype=bf16)]
     * output: [bot_l_0_relu_output(128, 1, 1, 512)(dtype=bf16)]
     *************/

    synTensor bot_l_0_relu_in_vec[1] = {bot_l_0_linear_output};


    // create bot_l_0_relu_output tensor
    const unsigned bot_l_0_relu_output_sizes[] = {128, 1, 1, 512};
    synTensor bot_l_0_relu_output = createTensor(4U, syn_type_bf16, bot_l_0_relu_output_sizes, false, "bot_l_0_relu_output");
    UNUSED(bot_l_0_relu_output); // For single op tests

    synTensor bot_l_0_relu_out_vec[1] = {bot_l_0_relu_output};


    status = synNodeCreate(graphHandle, bot_l_0_relu_in_vec, bot_l_0_relu_out_vec, 1, 1, nullptr, 0, "relu_fwd_bf16", "bot_l_0_relu", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bot_l_0_relu failed!");

    /*************
     * bot_l_2_linear node
     * inputs: [bot_l_0_relu_output(128, 1, 1, 512)(dtype=bf16), bot_l_2_linear_weight(1, 1, 512, 512)(dtype=bf16), bot_l_2_linear_bias[512](dtype=bf16)]
     * output: [bot_l_2_linear_output(128, 1, 1, 512)(dtype=bf16)]
     *************/
    synConvolutionParams bot_l_2_linear_kernel_params;
    bot_l_2_linear_kernel_params.dH = 1;
    bot_l_2_linear_kernel_params.dW = 1;
    bot_l_2_linear_kernel_params.kH = 1;
    bot_l_2_linear_kernel_params.kW = 1;
    bot_l_2_linear_kernel_params.padT = 0;
    bot_l_2_linear_kernel_params.padB = 0;
    bot_l_2_linear_kernel_params.padL = 0;
    bot_l_2_linear_kernel_params.padR = 0;
    bot_l_2_linear_kernel_params.dilH = 1;
    bot_l_2_linear_kernel_params.dilW = 1;

    // create bot_l_2_linear_weight tensor
    const unsigned bot_l_2_linear_weight_sizes[] = {1, 1, 512, 512};
    uint64_t bot_l_2_linear_weight_dram;
    unsigned bot_l_2_linear_weight_size = 1*1*512*512;
    unsigned bot_l_2_linear_weight_size_in_bytes = bot_l_2_linear_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(bot_l_2_linear_weight_size_in_bytes, &bot_l_2_linear_weight_dram, "bot_l_2_linear_weight");
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_weight dram malloc failed!");
    synLaunchTensorInfo bot_l_2_linear_weight_tr_info = {"bot_l_2_linear_weight", bot_l_2_linear_weight_dram};
    UNUSED(bot_l_2_linear_weight_tr_info); // For single op tests
    synTensor bot_l_2_linear_weight = createTensor(4U, syn_type_bf16, bot_l_2_linear_weight_sizes, true, "bot_l_2_linear_weight");
    UNUSED(bot_l_2_linear_weight); // For single op tests

    // create bot_l_2_linear_bias tensor
    const unsigned bot_l_2_linear_bias_sizes[] = {512,};
    uint64_t bot_l_2_linear_bias_dram;
    unsigned bot_l_2_linear_bias_size = 512;
    unsigned bot_l_2_linear_bias_size_in_bytes = bot_l_2_linear_bias_size * sizeof(bfloat16) ;
    status = hbmAlloc(bot_l_2_linear_bias_size_in_bytes, &bot_l_2_linear_bias_dram, "bot_l_2_linear_bias");
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_bias dram malloc failed!");
    synLaunchTensorInfo bot_l_2_linear_bias_tr_info = {"bot_l_2_linear_bias", bot_l_2_linear_bias_dram};
    UNUSED(bot_l_2_linear_bias_tr_info); // For single op tests
    synTensor bot_l_2_linear_bias = createTensor(1U, syn_type_bf16, bot_l_2_linear_bias_sizes, true, "bot_l_2_linear_bias");
    UNUSED(bot_l_2_linear_bias); // For single op tests

    synTensor bot_l_2_linear_in_vec[4] = {bot_l_0_relu_output, bot_l_2_linear_weight, bot_l_2_linear_bias, nullptr};


    // create bot_l_2_linear_output tensor
    const unsigned bot_l_2_linear_output_sizes[] = {128, 1, 1, 512};
    synTensor bot_l_2_linear_output = createTensor(4U, syn_type_bf16, bot_l_2_linear_output_sizes, false, "bot_l_2_linear_output");
    UNUSED(bot_l_2_linear_output); // For single op tests

    synTensor bot_l_2_linear_out_vec[1] = {bot_l_2_linear_output};


    status = synNodeCreate(graphHandle, bot_l_2_linear_in_vec, bot_l_2_linear_out_vec, 4, 1, (void *)&bot_l_2_linear_kernel_params, sizeof(bot_l_2_linear_kernel_params), "spatial_convolution", "bot_l_2_linear", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bot_l_2_linear failed!");

    /*************
     * bot_l_2_relu node
     * inputs: [bot_l_2_linear_output(128, 1, 1, 512)(dtype=bf16)]
     * output: [bot_l_2_relu_output(128, 1, 1, 512)(dtype=bf16)]
     *************/

    synTensor bot_l_2_relu_in_vec[1] = {bot_l_2_linear_output};


    // create bot_l_2_relu_output tensor
    const unsigned bot_l_2_relu_output_sizes[] = {128, 1, 1, 512};
    synTensor bot_l_2_relu_output = createTensor(4U, syn_type_bf16, bot_l_2_relu_output_sizes, false, "bot_l_2_relu_output");
    UNUSED(bot_l_2_relu_output); // For single op tests

    synTensor bot_l_2_relu_out_vec[1] = {bot_l_2_relu_output};


    status = synNodeCreate(graphHandle, bot_l_2_relu_in_vec, bot_l_2_relu_out_vec, 1, 1, nullptr, 0, "relu_fwd_bf16", "bot_l_2_relu", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bot_l_2_relu failed!");

    /*************
     * bot_l_4_linear node
     * inputs: [bot_l_2_relu_output(128, 1, 1, 512)(dtype=bf16), bot_l_4_linear_weight(1, 1, 512, 32)(dtype=bf16), bot_l_4_linear_bias[32](dtype=bf16)]
     * output: [bot_l_4_linear_output(128, 1, 1, 32)(dtype=bf16)]
     *************/
    synConvolutionParams bot_l_4_linear_kernel_params;
    bot_l_4_linear_kernel_params.dH = 1;
    bot_l_4_linear_kernel_params.dW = 1;
    bot_l_4_linear_kernel_params.kH = 1;
    bot_l_4_linear_kernel_params.kW = 1;
    bot_l_4_linear_kernel_params.padT = 0;
    bot_l_4_linear_kernel_params.padB = 0;
    bot_l_4_linear_kernel_params.padL = 0;
    bot_l_4_linear_kernel_params.padR = 0;
    bot_l_4_linear_kernel_params.dilH = 1;
    bot_l_4_linear_kernel_params.dilW = 1;

    // create bot_l_4_linear_weight tensor
    const unsigned bot_l_4_linear_weight_sizes[] = {1, 1, 512, 32};
    uint64_t bot_l_4_linear_weight_dram;
    unsigned bot_l_4_linear_weight_size = 1*1*512*32;
    unsigned bot_l_4_linear_weight_size_in_bytes = bot_l_4_linear_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(bot_l_4_linear_weight_size_in_bytes, &bot_l_4_linear_weight_dram, "bot_l_4_linear_weight");
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_weight dram malloc failed!");
    synLaunchTensorInfo bot_l_4_linear_weight_tr_info = {"bot_l_4_linear_weight", bot_l_4_linear_weight_dram};
    UNUSED(bot_l_4_linear_weight_tr_info); // For single op tests
    synTensor bot_l_4_linear_weight = createTensor(4U, syn_type_bf16, bot_l_4_linear_weight_sizes, true, "bot_l_4_linear_weight");
    UNUSED(bot_l_4_linear_weight); // For single op tests

    // create bot_l_4_linear_bias tensor
    const unsigned bot_l_4_linear_bias_sizes[] = {32,};
    uint64_t bot_l_4_linear_bias_dram;
    unsigned bot_l_4_linear_bias_size = 32;
    unsigned bot_l_4_linear_bias_size_in_bytes = bot_l_4_linear_bias_size * sizeof(bfloat16) ;
    status = hbmAlloc(bot_l_4_linear_bias_size_in_bytes, &bot_l_4_linear_bias_dram, "bot_l_4_linear_bias");
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_bias dram malloc failed!");
    synLaunchTensorInfo bot_l_4_linear_bias_tr_info = {"bot_l_4_linear_bias", bot_l_4_linear_bias_dram};
    UNUSED(bot_l_4_linear_bias_tr_info); // For single op tests
    synTensor bot_l_4_linear_bias = createTensor(1U, syn_type_bf16, bot_l_4_linear_bias_sizes, true, "bot_l_4_linear_bias");
    UNUSED(bot_l_4_linear_bias); // For single op tests

    synTensor bot_l_4_linear_in_vec[4] = {bot_l_2_relu_output, bot_l_4_linear_weight, bot_l_4_linear_bias, nullptr};


    // create bot_l_4_linear_output tensor
    const unsigned bot_l_4_linear_output_sizes[] = {128, 1, 1, 32};
    synTensor bot_l_4_linear_output = createTensor(4U, syn_type_bf16, bot_l_4_linear_output_sizes, false, "bot_l_4_linear_output");
    UNUSED(bot_l_4_linear_output); // For single op tests

    synTensor bot_l_4_linear_out_vec[1] = {bot_l_4_linear_output};


    status = synNodeCreate(graphHandle, bot_l_4_linear_in_vec, bot_l_4_linear_out_vec, 4, 1, (void *)&bot_l_4_linear_kernel_params, sizeof(bot_l_4_linear_kernel_params), "spatial_convolution", "bot_l_4_linear", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bot_l_4_linear failed!");

    /*************
     * bot_l_4_relu node
     * inputs: [bot_l_4_linear_output(128, 1, 1, 32)(dtype=bf16)]
     * output: [bot_l_4_relu_output(128, 1, 1, 32)(dtype=bf16)]
     *************/

    synTensor bot_l_4_relu_in_vec[1] = {bot_l_4_linear_output};


    // create bot_l_4_relu_output tensor
    const unsigned bot_l_4_relu_output_sizes[] = {128, 1, 1, 32};
    synTensor bot_l_4_relu_output = createTensor(4U, syn_type_bf16, bot_l_4_relu_output_sizes, false, "bot_l_4_relu_output");
    UNUSED(bot_l_4_relu_output); // For single op tests

    synTensor bot_l_4_relu_out_vec[1] = {bot_l_4_relu_output};


    status = synNodeCreate(graphHandle, bot_l_4_relu_in_vec, bot_l_4_relu_out_vec, 1, 1, nullptr, 0, "relu_fwd_bf16", "bot_l_4_relu", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bot_l_4_relu failed!");

    /*************
     * emb_0_embbag node
     * inputs: [emb_0_embbag_weight[1460, 32](dtype=bf16), lS_indices_0[128](dtype=int32), lS_offset_0[128](dtype=int32)]
     * output: [emb_0_embbag_output(128, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_0_embbag_kernel_params;
    emb_0_embbag_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_0_embbag_kernel_params.sgd.wd = 0;
    emb_0_embbag_kernel_params.sgd.mom = 0;
    emb_0_embbag_kernel_params.sgd.damp = 0;
    emb_0_embbag_kernel_params.sgd.nesterov = false;

    // create emb_0_embbag_weight tensor
    const unsigned emb_0_embbag_weight_sizes[] = {1460, 32};
    uint64_t emb_0_embbag_weight_dram;
    unsigned emb_0_embbag_weight_size = 1460*32;
    unsigned emb_0_embbag_weight_size_in_bytes = emb_0_embbag_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(emb_0_embbag_weight_size_in_bytes, &emb_0_embbag_weight_dram, "emb_0_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_weight dram malloc failed!");
    synLaunchTensorInfo emb_0_embbag_weight_tr_info = {"emb_0_embbag_weight", emb_0_embbag_weight_dram};
    UNUSED(emb_0_embbag_weight_tr_info); // For single op tests
    synTensor emb_0_embbag_weight = createTensor(2U, syn_type_bf16, emb_0_embbag_weight_sizes, true, "emb_0_embbag_weight");
    UNUSED(emb_0_embbag_weight); // For single op tests

    // create lS_indices_0 tensor
    const unsigned lS_indices_0_sizes[] = {128,};
    uint64_t lS_indices_0_dram;
    unsigned lS_indices_0_size = 128;
    unsigned lS_indices_0_size_in_bytes = lS_indices_0_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_indices_0_size_in_bytes, &lS_indices_0_dram, "lS_indices_0");
    ASSERT_TRUE(status == synSuccess && "lS_indices_0 dram malloc failed!");
    synLaunchTensorInfo lS_indices_0_tr_info = {"lS_indices_0", lS_indices_0_dram};
    UNUSED(lS_indices_0_tr_info); // For single op tests
    synTensor lS_indices_0 = createTensor(1U, syn_type_int32, lS_indices_0_sizes, true, "lS_indices_0");
    UNUSED(lS_indices_0); // For single op tests

    // create lS_offset_0 tensor
    const unsigned lS_offset_0_sizes[] = {128,};
    uint64_t lS_offset_0_dram;
    unsigned lS_offset_0_size = 128;
    unsigned lS_offset_0_size_in_bytes = lS_offset_0_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_offset_0_size_in_bytes, &lS_offset_0_dram, "lS_offset_0");
    ASSERT_TRUE(status == synSuccess && "lS_offset_0 dram malloc failed!");
    synLaunchTensorInfo lS_offset_0_tr_info = {"lS_offset_0", lS_offset_0_dram};
    UNUSED(lS_offset_0_tr_info); // For single op tests
    synTensor lS_offset_0 = createTensor(1U, syn_type_int32, lS_offset_0_sizes, true, "lS_offset_0");
    UNUSED(lS_offset_0); // For single op tests

    synTensor emb_0_embbag_in_vec[3] = {emb_0_embbag_weight, lS_indices_0, lS_offset_0};


    // create emb_0_embbag_output tensor
    const unsigned emb_0_embbag_output_sizes[] = {128, 32};
    synTensor emb_0_embbag_output = createTensor(2U, syn_type_bf16, emb_0_embbag_output_sizes, false, "emb_0_embbag_output");
    UNUSED(emb_0_embbag_output); // For single op tests

    synTensor emb_0_embbag_out_vec[1] = {emb_0_embbag_output};


    status = synNodeCreate(graphHandle, emb_0_embbag_in_vec, emb_0_embbag_out_vec, 3, 1, (void *)&emb_0_embbag_kernel_params, sizeof(emb_0_embbag_kernel_params), "embedding_bag_sgd_fwd_bf16", "emb_0_embbag", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_0_embbag failed!");

    /*************
     * emb_1_embbag node
     * inputs: [emb_1_embbag_weight[579, 32](dtype=bf16), lS_indices_1[128](dtype=int32), lS_offset_1[128](dtype=int32)]
     * output: [emb_1_embbag_output(128, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_1_embbag_kernel_params;
    emb_1_embbag_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_1_embbag_kernel_params.sgd.wd = 0;
    emb_1_embbag_kernel_params.sgd.mom = 0;
    emb_1_embbag_kernel_params.sgd.damp = 0;
    emb_1_embbag_kernel_params.sgd.nesterov = false;

    // create emb_1_embbag_weight tensor
    const unsigned emb_1_embbag_weight_sizes[] = {579, 32};
    uint64_t emb_1_embbag_weight_dram;
    unsigned emb_1_embbag_weight_size = 579*32;
    unsigned emb_1_embbag_weight_size_in_bytes = emb_1_embbag_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(emb_1_embbag_weight_size_in_bytes, &emb_1_embbag_weight_dram, "emb_1_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_1_embbag_weight dram malloc failed!");
    synLaunchTensorInfo emb_1_embbag_weight_tr_info = {"emb_1_embbag_weight", emb_1_embbag_weight_dram};
    UNUSED(emb_1_embbag_weight_tr_info); // For single op tests
    synTensor emb_1_embbag_weight = createTensor(2U, syn_type_bf16, emb_1_embbag_weight_sizes, true, "emb_1_embbag_weight");
    UNUSED(emb_1_embbag_weight); // For single op tests

    // create lS_indices_1 tensor
    const unsigned lS_indices_1_sizes[] = {128,};
    uint64_t lS_indices_1_dram;
    unsigned lS_indices_1_size = 128;
    unsigned lS_indices_1_size_in_bytes = lS_indices_1_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_indices_1_size_in_bytes, &lS_indices_1_dram, "lS_indices_1");
    ASSERT_TRUE(status == synSuccess && "lS_indices_1 dram malloc failed!");
    synLaunchTensorInfo lS_indices_1_tr_info = {"lS_indices_1", lS_indices_1_dram};
    UNUSED(lS_indices_1_tr_info); // For single op tests
    synTensor lS_indices_1 = createTensor(1U, syn_type_int32, lS_indices_1_sizes, true, "lS_indices_1");
    UNUSED(lS_indices_1); // For single op tests

    // create lS_offset_1 tensor
    const unsigned lS_offset_1_sizes[] = {128,};
    uint64_t lS_offset_1_dram;
    unsigned lS_offset_1_size = 128;
    unsigned lS_offset_1_size_in_bytes = lS_offset_1_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_offset_1_size_in_bytes, &lS_offset_1_dram, "lS_offset_1");
    ASSERT_TRUE(status == synSuccess && "lS_offset_1 dram malloc failed!");
    synLaunchTensorInfo lS_offset_1_tr_info = {"lS_offset_1", lS_offset_1_dram};
    UNUSED(lS_offset_1_tr_info); // For single op tests
    synTensor lS_offset_1 = createTensor(1U, syn_type_int32, lS_offset_1_sizes, true, "lS_offset_1");
    UNUSED(lS_offset_1); // For single op tests

    synTensor emb_1_embbag_in_vec[3] = {emb_1_embbag_weight, lS_indices_1, lS_offset_1};


    // create emb_1_embbag_output tensor
    const unsigned emb_1_embbag_output_sizes[] = {128, 32};
    synTensor emb_1_embbag_output = createTensor(2U, syn_type_bf16, emb_1_embbag_output_sizes, false, "emb_1_embbag_output");
    UNUSED(emb_1_embbag_output); // For single op tests

    synTensor emb_1_embbag_out_vec[1] = {emb_1_embbag_output};


    status = synNodeCreate(graphHandle, emb_1_embbag_in_vec, emb_1_embbag_out_vec, 3, 1, (void *)&emb_1_embbag_kernel_params, sizeof(emb_1_embbag_kernel_params), "embedding_bag_sgd_fwd_bf16", "emb_1_embbag", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_1_embbag failed!");

    /*************
     * emb_2_embbag node
     * inputs: [emb_2_embbag_weight[8832328, 32](dtype=bf16), lS_indices_2[128](dtype=int32), lS_offset_2[128](dtype=int32)]
     * output: [emb_2_embbag_output(128, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_2_embbag_kernel_params;
    emb_2_embbag_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_2_embbag_kernel_params.sgd.wd = 0;
    emb_2_embbag_kernel_params.sgd.mom = 0;
    emb_2_embbag_kernel_params.sgd.damp = 0;
    emb_2_embbag_kernel_params.sgd.nesterov = false;

    // create emb_2_embbag_weight tensor
    const unsigned emb_2_embbag_weight_sizes[] = {8832328, 32};
    uint64_t emb_2_embbag_weight_dram;
    unsigned emb_2_embbag_weight_size = 8832328*32;
    unsigned emb_2_embbag_weight_size_in_bytes = emb_2_embbag_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(emb_2_embbag_weight_size_in_bytes, &emb_2_embbag_weight_dram, "emb_2_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_2_embbag_weight dram malloc failed!");
    synLaunchTensorInfo emb_2_embbag_weight_tr_info = {"emb_2_embbag_weight", emb_2_embbag_weight_dram};
    UNUSED(emb_2_embbag_weight_tr_info); // For single op tests
    synTensor emb_2_embbag_weight = createTensor(2U, syn_type_bf16, emb_2_embbag_weight_sizes, true, "emb_2_embbag_weight");
    UNUSED(emb_2_embbag_weight); // For single op tests

    // create lS_indices_2 tensor
    const unsigned lS_indices_2_sizes[] = {128,};
    uint64_t lS_indices_2_dram;
    unsigned lS_indices_2_size = 128;
    unsigned lS_indices_2_size_in_bytes = lS_indices_2_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_indices_2_size_in_bytes, &lS_indices_2_dram, "lS_indices_2");
    ASSERT_TRUE(status == synSuccess && "lS_indices_2 dram malloc failed!");
    synLaunchTensorInfo lS_indices_2_tr_info = {"lS_indices_2", lS_indices_2_dram};
    UNUSED(lS_indices_2_tr_info); // For single op tests
    synTensor lS_indices_2 = createTensor(1U, syn_type_int32, lS_indices_2_sizes, true, "lS_indices_2");
    UNUSED(lS_indices_2); // For single op tests

    // create lS_offset_2 tensor
    const unsigned lS_offset_2_sizes[] = {128,};
    uint64_t lS_offset_2_dram;
    unsigned lS_offset_2_size = 128;
    unsigned lS_offset_2_size_in_bytes = lS_offset_2_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_offset_2_size_in_bytes, &lS_offset_2_dram, "lS_offset_2");
    ASSERT_TRUE(status == synSuccess && "lS_offset_2 dram malloc failed!");
    synLaunchTensorInfo lS_offset_2_tr_info = {"lS_offset_2", lS_offset_2_dram};
    UNUSED(lS_offset_2_tr_info); // For single op tests
    synTensor lS_offset_2 = createTensor(1U, syn_type_int32, lS_offset_2_sizes, true, "lS_offset_2");
    UNUSED(lS_offset_2); // For single op tests

    synTensor emb_2_embbag_in_vec[3] = {emb_2_embbag_weight, lS_indices_2, lS_offset_2};


    // create emb_2_embbag_output tensor
    const unsigned emb_2_embbag_output_sizes[] = {128, 32};
    synTensor emb_2_embbag_output = createTensor(2U, syn_type_bf16, emb_2_embbag_output_sizes, false, "emb_2_embbag_output");
    UNUSED(emb_2_embbag_output); // For single op tests

    synTensor emb_2_embbag_out_vec[1] = {emb_2_embbag_output};


    status = synNodeCreate(graphHandle, emb_2_embbag_in_vec, emb_2_embbag_out_vec, 3, 1, (void *)&emb_2_embbag_kernel_params, sizeof(emb_2_embbag_kernel_params), "embedding_bag_sgd_fwd_bf16", "emb_2_embbag", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_2_embbag failed!");

    /*************
     * emb_3_embbag node
     * inputs: [emb_3_embbag_weight[1965470, 32](dtype=bf16), lS_indices_3[128](dtype=int32), lS_offset_3[128](dtype=int32)]
     * output: [emb_3_embbag_output(128, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_3_embbag_kernel_params;
    emb_3_embbag_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_3_embbag_kernel_params.sgd.wd = 0;
    emb_3_embbag_kernel_params.sgd.mom = 0;
    emb_3_embbag_kernel_params.sgd.damp = 0;
    emb_3_embbag_kernel_params.sgd.nesterov = false;

    // create emb_3_embbag_weight tensor
    const unsigned emb_3_embbag_weight_sizes[] = {1965470, 32};
    uint64_t emb_3_embbag_weight_dram;
    unsigned emb_3_embbag_weight_size = 1965470*32;
    unsigned emb_3_embbag_weight_size_in_bytes = emb_3_embbag_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(emb_3_embbag_weight_size_in_bytes, &emb_3_embbag_weight_dram, "emb_3_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_3_embbag_weight dram malloc failed!");
    synLaunchTensorInfo emb_3_embbag_weight_tr_info = {"emb_3_embbag_weight", emb_3_embbag_weight_dram};
    UNUSED(emb_3_embbag_weight_tr_info); // For single op tests
    synTensor emb_3_embbag_weight = createTensor(2U, syn_type_bf16, emb_3_embbag_weight_sizes, true, "emb_3_embbag_weight");
    UNUSED(emb_3_embbag_weight); // For single op tests

    // create lS_indices_3 tensor
    const unsigned lS_indices_3_sizes[] = {128,};
    uint64_t lS_indices_3_dram;
    unsigned lS_indices_3_size = 128;
    unsigned lS_indices_3_size_in_bytes = lS_indices_3_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_indices_3_size_in_bytes, &lS_indices_3_dram, "lS_indices_3");
    ASSERT_TRUE(status == synSuccess && "lS_indices_3 dram malloc failed!");
    synLaunchTensorInfo lS_indices_3_tr_info = {"lS_indices_3", lS_indices_3_dram};
    UNUSED(lS_indices_3_tr_info); // For single op tests
    synTensor lS_indices_3 = createTensor(1U, syn_type_int32, lS_indices_3_sizes, true, "lS_indices_3");
    UNUSED(lS_indices_3); // For single op tests

    // create lS_offset_3 tensor
    const unsigned lS_offset_3_sizes[] = {128,};
    uint64_t lS_offset_3_dram;
    unsigned lS_offset_3_size = 128;
    unsigned lS_offset_3_size_in_bytes = lS_offset_3_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_offset_3_size_in_bytes, &lS_offset_3_dram, "lS_offset_3");
    ASSERT_TRUE(status == synSuccess && "lS_offset_3 dram malloc failed!");
    synLaunchTensorInfo lS_offset_3_tr_info = {"lS_offset_3", lS_offset_3_dram};
    UNUSED(lS_offset_3_tr_info); // For single op tests
    synTensor lS_offset_3 = createTensor(1U, syn_type_int32, lS_offset_3_sizes, true, "lS_offset_3");
    UNUSED(lS_offset_3); // For single op tests

    synTensor emb_3_embbag_in_vec[3] = {emb_3_embbag_weight, lS_indices_3, lS_offset_3};


    // create emb_3_embbag_output tensor
    const unsigned emb_3_embbag_output_sizes[] = {128, 32};
    synTensor emb_3_embbag_output = createTensor(2U, syn_type_bf16, emb_3_embbag_output_sizes, false, "emb_3_embbag_output");
    UNUSED(emb_3_embbag_output); // For single op tests

    synTensor emb_3_embbag_out_vec[1] = {emb_3_embbag_output};


    status = synNodeCreate(graphHandle, emb_3_embbag_in_vec, emb_3_embbag_out_vec, 3, 1, (void *)&emb_3_embbag_kernel_params, sizeof(emb_3_embbag_kernel_params), "embedding_bag_sgd_fwd_bf16", "emb_3_embbag", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_3_embbag failed!");

    /*************
     * emb_4_embbag node
     * inputs: [emb_4_embbag_weight[305, 32](dtype=bf16), lS_indices_4[128](dtype=int32), lS_offset_4[128](dtype=int32)]
     * output: [emb_4_embbag_output(128, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_4_embbag_kernel_params;
    emb_4_embbag_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_4_embbag_kernel_params.sgd.wd = 0;
    emb_4_embbag_kernel_params.sgd.mom = 0;
    emb_4_embbag_kernel_params.sgd.damp = 0;
    emb_4_embbag_kernel_params.sgd.nesterov = false;

    // create emb_4_embbag_weight tensor
    const unsigned emb_4_embbag_weight_sizes[] = {305, 32};
    uint64_t emb_4_embbag_weight_dram;
    unsigned emb_4_embbag_weight_size = 305*32;
    unsigned emb_4_embbag_weight_size_in_bytes = emb_4_embbag_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(emb_4_embbag_weight_size_in_bytes, &emb_4_embbag_weight_dram, "emb_4_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_4_embbag_weight dram malloc failed!");
    synLaunchTensorInfo emb_4_embbag_weight_tr_info = {"emb_4_embbag_weight", emb_4_embbag_weight_dram};
    UNUSED(emb_4_embbag_weight_tr_info); // For single op tests
    synTensor emb_4_embbag_weight = createTensor(2U, syn_type_bf16, emb_4_embbag_weight_sizes, true, "emb_4_embbag_weight");
    UNUSED(emb_4_embbag_weight); // For single op tests

    // create lS_indices_4 tensor
    const unsigned lS_indices_4_sizes[] = {128,};
    uint64_t lS_indices_4_dram;
    unsigned lS_indices_4_size = 128;
    unsigned lS_indices_4_size_in_bytes = lS_indices_4_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_indices_4_size_in_bytes, &lS_indices_4_dram, "lS_indices_4");
    ASSERT_TRUE(status == synSuccess && "lS_indices_4 dram malloc failed!");
    synLaunchTensorInfo lS_indices_4_tr_info = {"lS_indices_4", lS_indices_4_dram};
    UNUSED(lS_indices_4_tr_info); // For single op tests
    synTensor lS_indices_4 = createTensor(1U, syn_type_int32, lS_indices_4_sizes, true, "lS_indices_4");
    UNUSED(lS_indices_4); // For single op tests

    // create lS_offset_4 tensor
    const unsigned lS_offset_4_sizes[] = {128,};
    uint64_t lS_offset_4_dram;
    unsigned lS_offset_4_size = 128;
    unsigned lS_offset_4_size_in_bytes = lS_offset_4_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_offset_4_size_in_bytes, &lS_offset_4_dram, "lS_offset_4");
    ASSERT_TRUE(status == synSuccess && "lS_offset_4 dram malloc failed!");
    synLaunchTensorInfo lS_offset_4_tr_info = {"lS_offset_4", lS_offset_4_dram};
    UNUSED(lS_offset_4_tr_info); // For single op tests
    synTensor lS_offset_4 = createTensor(1U, syn_type_int32, lS_offset_4_sizes, true, "lS_offset_4");
    UNUSED(lS_offset_4); // For single op tests

    synTensor emb_4_embbag_in_vec[3] = {emb_4_embbag_weight, lS_indices_4, lS_offset_4};


    // create emb_4_embbag_output tensor
    const unsigned emb_4_embbag_output_sizes[] = {128, 32};
    synTensor emb_4_embbag_output = createTensor(2U, syn_type_bf16, emb_4_embbag_output_sizes, false, "emb_4_embbag_output");
    UNUSED(emb_4_embbag_output); // For single op tests

    synTensor emb_4_embbag_out_vec[1] = {emb_4_embbag_output};


    status = synNodeCreate(graphHandle, emb_4_embbag_in_vec, emb_4_embbag_out_vec, 3, 1, (void *)&emb_4_embbag_kernel_params, sizeof(emb_4_embbag_kernel_params), "embedding_bag_sgd_fwd_bf16", "emb_4_embbag", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_4_embbag failed!");

    /*************
     * emb_5_embbag node
     * inputs: [emb_5_embbag_weight[24, 32](dtype=bf16), lS_indices_5[128](dtype=int32), lS_offset_5[128](dtype=int32)]
     * output: [emb_5_embbag_output(128, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_5_embbag_kernel_params;
    emb_5_embbag_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_5_embbag_kernel_params.sgd.wd = 0;
    emb_5_embbag_kernel_params.sgd.mom = 0;
    emb_5_embbag_kernel_params.sgd.damp = 0;
    emb_5_embbag_kernel_params.sgd.nesterov = false;

    // create emb_5_embbag_weight tensor
    const unsigned emb_5_embbag_weight_sizes[] = {24, 32};
    uint64_t emb_5_embbag_weight_dram;
    unsigned emb_5_embbag_weight_size = 24*32;
    unsigned emb_5_embbag_weight_size_in_bytes = emb_5_embbag_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(emb_5_embbag_weight_size_in_bytes, &emb_5_embbag_weight_dram, "emb_5_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_5_embbag_weight dram malloc failed!");
    synLaunchTensorInfo emb_5_embbag_weight_tr_info = {"emb_5_embbag_weight", emb_5_embbag_weight_dram};
    UNUSED(emb_5_embbag_weight_tr_info); // For single op tests
    synTensor emb_5_embbag_weight = createTensor(2U, syn_type_bf16, emb_5_embbag_weight_sizes, true, "emb_5_embbag_weight");
    UNUSED(emb_5_embbag_weight); // For single op tests

    // create lS_indices_5 tensor
    const unsigned lS_indices_5_sizes[] = {128,};
    uint64_t lS_indices_5_dram;
    unsigned lS_indices_5_size = 128;
    unsigned lS_indices_5_size_in_bytes = lS_indices_5_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_indices_5_size_in_bytes, &lS_indices_5_dram, "lS_indices_5");
    ASSERT_TRUE(status == synSuccess && "lS_indices_5 dram malloc failed!");
    synLaunchTensorInfo lS_indices_5_tr_info = {"lS_indices_5", lS_indices_5_dram};
    UNUSED(lS_indices_5_tr_info); // For single op tests
    synTensor lS_indices_5 = createTensor(1U, syn_type_int32, lS_indices_5_sizes, true, "lS_indices_5");
    UNUSED(lS_indices_5); // For single op tests

    // create lS_offset_5 tensor
    const unsigned lS_offset_5_sizes[] = {128,};
    uint64_t lS_offset_5_dram;
    unsigned lS_offset_5_size = 128;
    unsigned lS_offset_5_size_in_bytes = lS_offset_5_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_offset_5_size_in_bytes, &lS_offset_5_dram, "lS_offset_5");
    ASSERT_TRUE(status == synSuccess && "lS_offset_5 dram malloc failed!");
    synLaunchTensorInfo lS_offset_5_tr_info = {"lS_offset_5", lS_offset_5_dram};
    UNUSED(lS_offset_5_tr_info); // For single op tests
    synTensor lS_offset_5 = createTensor(1U, syn_type_int32, lS_offset_5_sizes, true, "lS_offset_5");
    UNUSED(lS_offset_5); // For single op tests

    synTensor emb_5_embbag_in_vec[3] = {emb_5_embbag_weight, lS_indices_5, lS_offset_5};


    // create emb_5_embbag_output tensor
    const unsigned emb_5_embbag_output_sizes[] = {128, 32};
    synTensor emb_5_embbag_output = createTensor(2U, syn_type_bf16, emb_5_embbag_output_sizes, false, "emb_5_embbag_output");
    UNUSED(emb_5_embbag_output); // For single op tests

    synTensor emb_5_embbag_out_vec[1] = {emb_5_embbag_output};


    status = synNodeCreate(graphHandle, emb_5_embbag_in_vec, emb_5_embbag_out_vec, 3, 1, (void *)&emb_5_embbag_kernel_params, sizeof(emb_5_embbag_kernel_params), "embedding_bag_sgd_fwd_bf16", "emb_5_embbag", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_5_embbag failed!");

    /*************
     * emb_6_embbag node
     * inputs: [emb_6_embbag_weight[12453, 32](dtype=bf16), lS_indices_6[128](dtype=int32), lS_offset_6[128](dtype=int32)]
     * output: [emb_6_embbag_output(128, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_6_embbag_kernel_params;
    emb_6_embbag_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_6_embbag_kernel_params.sgd.wd = 0;
    emb_6_embbag_kernel_params.sgd.mom = 0;
    emb_6_embbag_kernel_params.sgd.damp = 0;
    emb_6_embbag_kernel_params.sgd.nesterov = false;

    // create emb_6_embbag_weight tensor
    const unsigned emb_6_embbag_weight_sizes[] = {12453, 32};
    uint64_t emb_6_embbag_weight_dram;
    unsigned emb_6_embbag_weight_size = 12453*32;
    unsigned emb_6_embbag_weight_size_in_bytes = emb_6_embbag_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(emb_6_embbag_weight_size_in_bytes, &emb_6_embbag_weight_dram, "emb_6_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_6_embbag_weight dram malloc failed!");
    synLaunchTensorInfo emb_6_embbag_weight_tr_info = {"emb_6_embbag_weight", emb_6_embbag_weight_dram};
    UNUSED(emb_6_embbag_weight_tr_info); // For single op tests
    synTensor emb_6_embbag_weight = createTensor(2U, syn_type_bf16, emb_6_embbag_weight_sizes, true, "emb_6_embbag_weight");
    UNUSED(emb_6_embbag_weight); // For single op tests

    // create lS_indices_6 tensor
    const unsigned lS_indices_6_sizes[] = {128,};
    uint64_t lS_indices_6_dram;
    unsigned lS_indices_6_size = 128;
    unsigned lS_indices_6_size_in_bytes = lS_indices_6_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_indices_6_size_in_bytes, &lS_indices_6_dram, "lS_indices_6");
    ASSERT_TRUE(status == synSuccess && "lS_indices_6 dram malloc failed!");
    synLaunchTensorInfo lS_indices_6_tr_info = {"lS_indices_6", lS_indices_6_dram};
    UNUSED(lS_indices_6_tr_info); // For single op tests
    synTensor lS_indices_6 = createTensor(1U, syn_type_int32, lS_indices_6_sizes, true, "lS_indices_6");
    UNUSED(lS_indices_6); // For single op tests

    // create lS_offset_6 tensor
    const unsigned lS_offset_6_sizes[] = {128,};
    uint64_t lS_offset_6_dram;
    unsigned lS_offset_6_size = 128;
    unsigned lS_offset_6_size_in_bytes = lS_offset_6_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_offset_6_size_in_bytes, &lS_offset_6_dram, "lS_offset_6");
    ASSERT_TRUE(status == synSuccess && "lS_offset_6 dram malloc failed!");
    synLaunchTensorInfo lS_offset_6_tr_info = {"lS_offset_6", lS_offset_6_dram};
    UNUSED(lS_offset_6_tr_info); // For single op tests
    synTensor lS_offset_6 = createTensor(1U, syn_type_int32, lS_offset_6_sizes, true, "lS_offset_6");
    UNUSED(lS_offset_6); // For single op tests

    synTensor emb_6_embbag_in_vec[3] = {emb_6_embbag_weight, lS_indices_6, lS_offset_6};


    // create emb_6_embbag_output tensor
    const unsigned emb_6_embbag_output_sizes[] = {128, 32};
    synTensor emb_6_embbag_output = createTensor(2U, syn_type_bf16, emb_6_embbag_output_sizes, false, "emb_6_embbag_output");
    UNUSED(emb_6_embbag_output); // For single op tests

    synTensor emb_6_embbag_out_vec[1] = {emb_6_embbag_output};


    status = synNodeCreate(graphHandle, emb_6_embbag_in_vec, emb_6_embbag_out_vec, 3, 1, (void *)&emb_6_embbag_kernel_params, sizeof(emb_6_embbag_kernel_params), "embedding_bag_sgd_fwd_bf16", "emb_6_embbag", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_6_embbag failed!");

    /*************
     * emb_7_embbag node
     * inputs: [emb_7_embbag_weight[633, 32](dtype=bf16), lS_indices_7[128](dtype=int32), lS_offset_7[128](dtype=int32)]
     * output: [emb_7_embbag_output(128, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_7_embbag_kernel_params;
    emb_7_embbag_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_7_embbag_kernel_params.sgd.wd = 0;
    emb_7_embbag_kernel_params.sgd.mom = 0;
    emb_7_embbag_kernel_params.sgd.damp = 0;
    emb_7_embbag_kernel_params.sgd.nesterov = false;

    // create emb_7_embbag_weight tensor
    const unsigned emb_7_embbag_weight_sizes[] = {633, 32};
    uint64_t emb_7_embbag_weight_dram;
    unsigned emb_7_embbag_weight_size = 633*32;
    unsigned emb_7_embbag_weight_size_in_bytes = emb_7_embbag_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(emb_7_embbag_weight_size_in_bytes, &emb_7_embbag_weight_dram, "emb_7_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_7_embbag_weight dram malloc failed!");
    synLaunchTensorInfo emb_7_embbag_weight_tr_info = {"emb_7_embbag_weight", emb_7_embbag_weight_dram};
    UNUSED(emb_7_embbag_weight_tr_info); // For single op tests
    synTensor emb_7_embbag_weight = createTensor(2U, syn_type_bf16, emb_7_embbag_weight_sizes, true, "emb_7_embbag_weight");
    UNUSED(emb_7_embbag_weight); // For single op tests

    // create lS_indices_7 tensor
    const unsigned lS_indices_7_sizes[] = {128,};
    uint64_t lS_indices_7_dram;
    unsigned lS_indices_7_size = 128;
    unsigned lS_indices_7_size_in_bytes = lS_indices_7_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_indices_7_size_in_bytes, &lS_indices_7_dram, "lS_indices_7");
    ASSERT_TRUE(status == synSuccess && "lS_indices_7 dram malloc failed!");
    synLaunchTensorInfo lS_indices_7_tr_info = {"lS_indices_7", lS_indices_7_dram};
    UNUSED(lS_indices_7_tr_info); // For single op tests
    synTensor lS_indices_7 = createTensor(1U, syn_type_int32, lS_indices_7_sizes, true, "lS_indices_7");
    UNUSED(lS_indices_7); // For single op tests

    // create lS_offset_7 tensor
    const unsigned lS_offset_7_sizes[] = {128,};
    uint64_t lS_offset_7_dram;
    unsigned lS_offset_7_size = 128;
    unsigned lS_offset_7_size_in_bytes = lS_offset_7_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_offset_7_size_in_bytes, &lS_offset_7_dram, "lS_offset_7");
    ASSERT_TRUE(status == synSuccess && "lS_offset_7 dram malloc failed!");
    synLaunchTensorInfo lS_offset_7_tr_info = {"lS_offset_7", lS_offset_7_dram};
    UNUSED(lS_offset_7_tr_info); // For single op tests
    synTensor lS_offset_7 = createTensor(1U, syn_type_int32, lS_offset_7_sizes, true, "lS_offset_7");
    UNUSED(lS_offset_7); // For single op tests

    synTensor emb_7_embbag_in_vec[3] = {emb_7_embbag_weight, lS_indices_7, lS_offset_7};


    // create emb_7_embbag_output tensor
    const unsigned emb_7_embbag_output_sizes[] = {128, 32};
    synTensor emb_7_embbag_output = createTensor(2U, syn_type_bf16, emb_7_embbag_output_sizes, false, "emb_7_embbag_output");
    UNUSED(emb_7_embbag_output); // For single op tests

    synTensor emb_7_embbag_out_vec[1] = {emb_7_embbag_output};


    status = synNodeCreate(graphHandle, emb_7_embbag_in_vec, emb_7_embbag_out_vec, 3, 1, (void *)&emb_7_embbag_kernel_params, sizeof(emb_7_embbag_kernel_params), "embedding_bag_sgd_fwd_bf16", "emb_7_embbag", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_7_embbag failed!");

    /*************
     * emb_8_embbag node
     * inputs: [emb_8_embbag_weight[3, 32](dtype=bf16), lS_indices_8[128](dtype=int32), lS_offset_8[128](dtype=int32)]
     * output: [emb_8_embbag_output(128, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_8_embbag_kernel_params;
    emb_8_embbag_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_8_embbag_kernel_params.sgd.wd = 0;
    emb_8_embbag_kernel_params.sgd.mom = 0;
    emb_8_embbag_kernel_params.sgd.damp = 0;
    emb_8_embbag_kernel_params.sgd.nesterov = false;

    // create emb_8_embbag_weight tensor
    const unsigned emb_8_embbag_weight_sizes[] = {3, 32};
    uint64_t emb_8_embbag_weight_dram;
    unsigned emb_8_embbag_weight_size = 3*32;
    unsigned emb_8_embbag_weight_size_in_bytes = emb_8_embbag_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(emb_8_embbag_weight_size_in_bytes, &emb_8_embbag_weight_dram, "emb_8_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_8_embbag_weight dram malloc failed!");
    synLaunchTensorInfo emb_8_embbag_weight_tr_info = {"emb_8_embbag_weight", emb_8_embbag_weight_dram};
    UNUSED(emb_8_embbag_weight_tr_info); // For single op tests
    synTensor emb_8_embbag_weight = createTensor(2U, syn_type_bf16, emb_8_embbag_weight_sizes, true, "emb_8_embbag_weight");
    UNUSED(emb_8_embbag_weight); // For single op tests

    // create lS_indices_8 tensor
    const unsigned lS_indices_8_sizes[] = {128,};
    uint64_t lS_indices_8_dram;
    unsigned lS_indices_8_size = 128;
    unsigned lS_indices_8_size_in_bytes = lS_indices_8_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_indices_8_size_in_bytes, &lS_indices_8_dram, "lS_indices_8");
    ASSERT_TRUE(status == synSuccess && "lS_indices_8 dram malloc failed!");
    synLaunchTensorInfo lS_indices_8_tr_info = {"lS_indices_8", lS_indices_8_dram};
    UNUSED(lS_indices_8_tr_info); // For single op tests
    synTensor lS_indices_8 = createTensor(1U, syn_type_int32, lS_indices_8_sizes, true, "lS_indices_8");
    UNUSED(lS_indices_8); // For single op tests

    // create lS_offset_8 tensor
    const unsigned lS_offset_8_sizes[] = {128,};
    uint64_t lS_offset_8_dram;
    unsigned lS_offset_8_size = 128;
    unsigned lS_offset_8_size_in_bytes = lS_offset_8_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_offset_8_size_in_bytes, &lS_offset_8_dram, "lS_offset_8");
    ASSERT_TRUE(status == synSuccess && "lS_offset_8 dram malloc failed!");
    synLaunchTensorInfo lS_offset_8_tr_info = {"lS_offset_8", lS_offset_8_dram};
    UNUSED(lS_offset_8_tr_info); // For single op tests
    synTensor lS_offset_8 = createTensor(1U, syn_type_int32, lS_offset_8_sizes, true, "lS_offset_8");
    UNUSED(lS_offset_8); // For single op tests

    synTensor emb_8_embbag_in_vec[3] = {emb_8_embbag_weight, lS_indices_8, lS_offset_8};


    // create emb_8_embbag_output tensor
    const unsigned emb_8_embbag_output_sizes[] = {128, 32};
    synTensor emb_8_embbag_output = createTensor(2U, syn_type_bf16, emb_8_embbag_output_sizes, false, "emb_8_embbag_output");
    UNUSED(emb_8_embbag_output); // For single op tests

    synTensor emb_8_embbag_out_vec[1] = {emb_8_embbag_output};


    status = synNodeCreate(graphHandle, emb_8_embbag_in_vec, emb_8_embbag_out_vec, 3, 1, (void *)&emb_8_embbag_kernel_params, sizeof(emb_8_embbag_kernel_params), "embedding_bag_sgd_fwd_bf16", "emb_8_embbag", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_8_embbag failed!");

    /*************
     * emb_9_embbag node
     * inputs: [emb_9_embbag_weight[89982, 32](dtype=bf16), lS_indices_9[128](dtype=int32), lS_offset_9[128](dtype=int32)]
     * output: [emb_9_embbag_output(128, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_9_embbag_kernel_params;
    emb_9_embbag_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_9_embbag_kernel_params.sgd.wd = 0;
    emb_9_embbag_kernel_params.sgd.mom = 0;
    emb_9_embbag_kernel_params.sgd.damp = 0;
    emb_9_embbag_kernel_params.sgd.nesterov = false;

    // create emb_9_embbag_weight tensor
    const unsigned emb_9_embbag_weight_sizes[] = {89982, 32};
    uint64_t emb_9_embbag_weight_dram;
    unsigned emb_9_embbag_weight_size = 89982*32;
    unsigned emb_9_embbag_weight_size_in_bytes = emb_9_embbag_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(emb_9_embbag_weight_size_in_bytes, &emb_9_embbag_weight_dram, "emb_9_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_9_embbag_weight dram malloc failed!");
    synLaunchTensorInfo emb_9_embbag_weight_tr_info = {"emb_9_embbag_weight", emb_9_embbag_weight_dram};
    UNUSED(emb_9_embbag_weight_tr_info); // For single op tests
    synTensor emb_9_embbag_weight = createTensor(2U, syn_type_bf16, emb_9_embbag_weight_sizes, true, "emb_9_embbag_weight");
    UNUSED(emb_9_embbag_weight); // For single op tests

    // create lS_indices_9 tensor
    const unsigned lS_indices_9_sizes[] = {128,};
    uint64_t lS_indices_9_dram;
    unsigned lS_indices_9_size = 128;
    unsigned lS_indices_9_size_in_bytes = lS_indices_9_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_indices_9_size_in_bytes, &lS_indices_9_dram, "lS_indices_9");
    ASSERT_TRUE(status == synSuccess && "lS_indices_9 dram malloc failed!");
    synLaunchTensorInfo lS_indices_9_tr_info = {"lS_indices_9", lS_indices_9_dram};
    UNUSED(lS_indices_9_tr_info); // For single op tests
    synTensor lS_indices_9 = createTensor(1U, syn_type_int32, lS_indices_9_sizes, true, "lS_indices_9");
    UNUSED(lS_indices_9); // For single op tests

    // create lS_offset_9 tensor
    const unsigned lS_offset_9_sizes[] = {128,};
    uint64_t lS_offset_9_dram;
    unsigned lS_offset_9_size = 128;
    unsigned lS_offset_9_size_in_bytes = lS_offset_9_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_offset_9_size_in_bytes, &lS_offset_9_dram, "lS_offset_9");
    ASSERT_TRUE(status == synSuccess && "lS_offset_9 dram malloc failed!");
    synLaunchTensorInfo lS_offset_9_tr_info = {"lS_offset_9", lS_offset_9_dram};
    UNUSED(lS_offset_9_tr_info); // For single op tests
    synTensor lS_offset_9 = createTensor(1U, syn_type_int32, lS_offset_9_sizes, true, "lS_offset_9");
    UNUSED(lS_offset_9); // For single op tests

    synTensor emb_9_embbag_in_vec[3] = {emb_9_embbag_weight, lS_indices_9, lS_offset_9};


    // create emb_9_embbag_output tensor
    const unsigned emb_9_embbag_output_sizes[] = {128, 32};
    synTensor emb_9_embbag_output = createTensor(2U, syn_type_bf16, emb_9_embbag_output_sizes, false, "emb_9_embbag_output");
    UNUSED(emb_9_embbag_output); // For single op tests

    synTensor emb_9_embbag_out_vec[1] = {emb_9_embbag_output};


    status = synNodeCreate(graphHandle, emb_9_embbag_in_vec, emb_9_embbag_out_vec, 3, 1, (void *)&emb_9_embbag_kernel_params, sizeof(emb_9_embbag_kernel_params), "embedding_bag_sgd_fwd_bf16", "emb_9_embbag", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_9_embbag failed!");

    /*************
     * emb_10_embbag node
     * inputs: [emb_10_embbag_weight[5623, 32](dtype=bf16), lS_indices_10[128](dtype=int32), lS_offset_10[128](dtype=int32)]
     * output: [emb_10_embbag_output(128, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_10_embbag_kernel_params;
    emb_10_embbag_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_10_embbag_kernel_params.sgd.wd = 0;
    emb_10_embbag_kernel_params.sgd.mom = 0;
    emb_10_embbag_kernel_params.sgd.damp = 0;
    emb_10_embbag_kernel_params.sgd.nesterov = false;

    // create emb_10_embbag_weight tensor
    const unsigned emb_10_embbag_weight_sizes[] = {5623, 32};
    uint64_t emb_10_embbag_weight_dram;
    unsigned emb_10_embbag_weight_size = 5623*32;
    unsigned emb_10_embbag_weight_size_in_bytes = emb_10_embbag_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(emb_10_embbag_weight_size_in_bytes, &emb_10_embbag_weight_dram, "emb_10_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_10_embbag_weight dram malloc failed!");
    synLaunchTensorInfo emb_10_embbag_weight_tr_info = {"emb_10_embbag_weight", emb_10_embbag_weight_dram};
    UNUSED(emb_10_embbag_weight_tr_info); // For single op tests
    synTensor emb_10_embbag_weight = createTensor(2U, syn_type_bf16, emb_10_embbag_weight_sizes, true, "emb_10_embbag_weight");
    UNUSED(emb_10_embbag_weight); // For single op tests

    // create lS_indices_10 tensor
    const unsigned lS_indices_10_sizes[] = {128,};
    uint64_t lS_indices_10_dram;
    unsigned lS_indices_10_size = 128;
    unsigned lS_indices_10_size_in_bytes = lS_indices_10_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_indices_10_size_in_bytes, &lS_indices_10_dram, "lS_indices_10");
    ASSERT_TRUE(status == synSuccess && "lS_indices_10 dram malloc failed!");
    synLaunchTensorInfo lS_indices_10_tr_info = {"lS_indices_10", lS_indices_10_dram};
    UNUSED(lS_indices_10_tr_info); // For single op tests
    synTensor lS_indices_10 = createTensor(1U, syn_type_int32, lS_indices_10_sizes, true, "lS_indices_10");
    UNUSED(lS_indices_10); // For single op tests

    // create lS_offset_10 tensor
    const unsigned lS_offset_10_sizes[] = {128,};
    uint64_t lS_offset_10_dram;
    unsigned lS_offset_10_size = 128;
    unsigned lS_offset_10_size_in_bytes = lS_offset_10_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_offset_10_size_in_bytes, &lS_offset_10_dram, "lS_offset_10");
    ASSERT_TRUE(status == synSuccess && "lS_offset_10 dram malloc failed!");
    synLaunchTensorInfo lS_offset_10_tr_info = {"lS_offset_10", lS_offset_10_dram};
    UNUSED(lS_offset_10_tr_info); // For single op tests
    synTensor lS_offset_10 = createTensor(1U, syn_type_int32, lS_offset_10_sizes, true, "lS_offset_10");
    UNUSED(lS_offset_10); // For single op tests

    synTensor emb_10_embbag_in_vec[3] = {emb_10_embbag_weight, lS_indices_10, lS_offset_10};


    // create emb_10_embbag_output tensor
    const unsigned emb_10_embbag_output_sizes[] = {128, 32};
    synTensor emb_10_embbag_output = createTensor(2U, syn_type_bf16, emb_10_embbag_output_sizes, false, "emb_10_embbag_output");
    UNUSED(emb_10_embbag_output); // For single op tests

    synTensor emb_10_embbag_out_vec[1] = {emb_10_embbag_output};


    status = synNodeCreate(graphHandle, emb_10_embbag_in_vec, emb_10_embbag_out_vec, 3, 1, (void *)&emb_10_embbag_kernel_params, sizeof(emb_10_embbag_kernel_params), "embedding_bag_sgd_fwd_bf16", "emb_10_embbag", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_10_embbag failed!");

    /*************
     * emb_11_embbag node
     * inputs: [emb_11_embbag_weight[7305771, 32](dtype=bf16), lS_indices_11[128](dtype=int32), lS_offset_11[128](dtype=int32)]
     * output: [emb_11_embbag_output(128, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_11_embbag_kernel_params;
    emb_11_embbag_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_11_embbag_kernel_params.sgd.wd = 0;
    emb_11_embbag_kernel_params.sgd.mom = 0;
    emb_11_embbag_kernel_params.sgd.damp = 0;
    emb_11_embbag_kernel_params.sgd.nesterov = false;

    // create emb_11_embbag_weight tensor
    const unsigned emb_11_embbag_weight_sizes[] = {7305771, 32};
    uint64_t emb_11_embbag_weight_dram;
    unsigned emb_11_embbag_weight_size = 7305771*32;
    unsigned emb_11_embbag_weight_size_in_bytes = emb_11_embbag_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(emb_11_embbag_weight_size_in_bytes, &emb_11_embbag_weight_dram, "emb_11_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_11_embbag_weight dram malloc failed!");
    synLaunchTensorInfo emb_11_embbag_weight_tr_info = {"emb_11_embbag_weight", emb_11_embbag_weight_dram};
    UNUSED(emb_11_embbag_weight_tr_info); // For single op tests
    synTensor emb_11_embbag_weight = createTensor(2U, syn_type_bf16, emb_11_embbag_weight_sizes, true, "emb_11_embbag_weight");
    UNUSED(emb_11_embbag_weight); // For single op tests

    // create lS_indices_11 tensor
    const unsigned lS_indices_11_sizes[] = {128,};
    uint64_t lS_indices_11_dram;
    unsigned lS_indices_11_size = 128;
    unsigned lS_indices_11_size_in_bytes = lS_indices_11_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_indices_11_size_in_bytes, &lS_indices_11_dram, "lS_indices_11");
    ASSERT_TRUE(status == synSuccess && "lS_indices_11 dram malloc failed!");
    synLaunchTensorInfo lS_indices_11_tr_info = {"lS_indices_11", lS_indices_11_dram};
    UNUSED(lS_indices_11_tr_info); // For single op tests
    synTensor lS_indices_11 = createTensor(1U, syn_type_int32, lS_indices_11_sizes, true, "lS_indices_11");
    UNUSED(lS_indices_11); // For single op tests

    // create lS_offset_11 tensor
    const unsigned lS_offset_11_sizes[] = {128,};
    uint64_t lS_offset_11_dram;
    unsigned lS_offset_11_size = 128;
    unsigned lS_offset_11_size_in_bytes = lS_offset_11_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_offset_11_size_in_bytes, &lS_offset_11_dram, "lS_offset_11");
    ASSERT_TRUE(status == synSuccess && "lS_offset_11 dram malloc failed!");
    synLaunchTensorInfo lS_offset_11_tr_info = {"lS_offset_11", lS_offset_11_dram};
    UNUSED(lS_offset_11_tr_info); // For single op tests
    synTensor lS_offset_11 = createTensor(1U, syn_type_int32, lS_offset_11_sizes, true, "lS_offset_11");
    UNUSED(lS_offset_11); // For single op tests

    synTensor emb_11_embbag_in_vec[3] = {emb_11_embbag_weight, lS_indices_11, lS_offset_11};


    // create emb_11_embbag_output tensor
    const unsigned emb_11_embbag_output_sizes[] = {128, 32};
    synTensor emb_11_embbag_output = createTensor(2U, syn_type_bf16, emb_11_embbag_output_sizes, false, "emb_11_embbag_output");
    UNUSED(emb_11_embbag_output); // For single op tests

    synTensor emb_11_embbag_out_vec[1] = {emb_11_embbag_output};


    status = synNodeCreate(graphHandle, emb_11_embbag_in_vec, emb_11_embbag_out_vec, 3, 1, (void *)&emb_11_embbag_kernel_params, sizeof(emb_11_embbag_kernel_params), "embedding_bag_sgd_fwd_bf16", "emb_11_embbag", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_11_embbag failed!");

    /*************
     * emb_12_embbag node
     * inputs: [emb_12_embbag_weight[3181, 32](dtype=bf16), lS_indices_12[128](dtype=int32), lS_offset_12[128](dtype=int32)]
     * output: [emb_12_embbag_output(128, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_12_embbag_kernel_params;
    emb_12_embbag_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_12_embbag_kernel_params.sgd.wd = 0;
    emb_12_embbag_kernel_params.sgd.mom = 0;
    emb_12_embbag_kernel_params.sgd.damp = 0;
    emb_12_embbag_kernel_params.sgd.nesterov = false;

    // create emb_12_embbag_weight tensor
    const unsigned emb_12_embbag_weight_sizes[] = {3181, 32};
    uint64_t emb_12_embbag_weight_dram;
    unsigned emb_12_embbag_weight_size = 3181*32;
    unsigned emb_12_embbag_weight_size_in_bytes = emb_12_embbag_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(emb_12_embbag_weight_size_in_bytes, &emb_12_embbag_weight_dram, "emb_12_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_12_embbag_weight dram malloc failed!");
    synLaunchTensorInfo emb_12_embbag_weight_tr_info = {"emb_12_embbag_weight", emb_12_embbag_weight_dram};
    UNUSED(emb_12_embbag_weight_tr_info); // For single op tests
    synTensor emb_12_embbag_weight = createTensor(2U, syn_type_bf16, emb_12_embbag_weight_sizes, true, "emb_12_embbag_weight");
    UNUSED(emb_12_embbag_weight); // For single op tests

    // create lS_indices_12 tensor
    const unsigned lS_indices_12_sizes[] = {128,};
    uint64_t lS_indices_12_dram;
    unsigned lS_indices_12_size = 128;
    unsigned lS_indices_12_size_in_bytes = lS_indices_12_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_indices_12_size_in_bytes, &lS_indices_12_dram, "lS_indices_12");
    ASSERT_TRUE(status == synSuccess && "lS_indices_12 dram malloc failed!");
    synLaunchTensorInfo lS_indices_12_tr_info = {"lS_indices_12", lS_indices_12_dram};
    UNUSED(lS_indices_12_tr_info); // For single op tests
    synTensor lS_indices_12 = createTensor(1U, syn_type_int32, lS_indices_12_sizes, true, "lS_indices_12");
    UNUSED(lS_indices_12); // For single op tests

    // create lS_offset_12 tensor
    const unsigned lS_offset_12_sizes[] = {128,};
    uint64_t lS_offset_12_dram;
    unsigned lS_offset_12_size = 128;
    unsigned lS_offset_12_size_in_bytes = lS_offset_12_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_offset_12_size_in_bytes, &lS_offset_12_dram, "lS_offset_12");
    ASSERT_TRUE(status == synSuccess && "lS_offset_12 dram malloc failed!");
    synLaunchTensorInfo lS_offset_12_tr_info = {"lS_offset_12", lS_offset_12_dram};
    UNUSED(lS_offset_12_tr_info); // For single op tests
    synTensor lS_offset_12 = createTensor(1U, syn_type_int32, lS_offset_12_sizes, true, "lS_offset_12");
    UNUSED(lS_offset_12); // For single op tests

    synTensor emb_12_embbag_in_vec[3] = {emb_12_embbag_weight, lS_indices_12, lS_offset_12};


    // create emb_12_embbag_output tensor
    const unsigned emb_12_embbag_output_sizes[] = {128, 32};
    synTensor emb_12_embbag_output = createTensor(2U, syn_type_bf16, emb_12_embbag_output_sizes, false, "emb_12_embbag_output");
    UNUSED(emb_12_embbag_output); // For single op tests

    synTensor emb_12_embbag_out_vec[1] = {emb_12_embbag_output};


    status = synNodeCreate(graphHandle, emb_12_embbag_in_vec, emb_12_embbag_out_vec, 3, 1, (void *)&emb_12_embbag_kernel_params, sizeof(emb_12_embbag_kernel_params), "embedding_bag_sgd_fwd_bf16", "emb_12_embbag", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_12_embbag failed!");

    /*************
     * emb_13_embbag node
     * inputs: [emb_13_embbag_weight[27, 32](dtype=bf16), lS_indices_13[128](dtype=int32), lS_offset_13[128](dtype=int32)]
     * output: [emb_13_embbag_output(128, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_13_embbag_kernel_params;
    emb_13_embbag_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_13_embbag_kernel_params.sgd.wd = 0;
    emb_13_embbag_kernel_params.sgd.mom = 0;
    emb_13_embbag_kernel_params.sgd.damp = 0;
    emb_13_embbag_kernel_params.sgd.nesterov = false;

    // create emb_13_embbag_weight tensor
    const unsigned emb_13_embbag_weight_sizes[] = {27, 32};
    uint64_t emb_13_embbag_weight_dram;
    unsigned emb_13_embbag_weight_size = 27*32;
    unsigned emb_13_embbag_weight_size_in_bytes = emb_13_embbag_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(emb_13_embbag_weight_size_in_bytes, &emb_13_embbag_weight_dram, "emb_13_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_13_embbag_weight dram malloc failed!");
    synLaunchTensorInfo emb_13_embbag_weight_tr_info = {"emb_13_embbag_weight", emb_13_embbag_weight_dram};
    UNUSED(emb_13_embbag_weight_tr_info); // For single op tests
    synTensor emb_13_embbag_weight = createTensor(2U, syn_type_bf16, emb_13_embbag_weight_sizes, true, "emb_13_embbag_weight");
    UNUSED(emb_13_embbag_weight); // For single op tests

    // create lS_indices_13 tensor
    const unsigned lS_indices_13_sizes[] = {128,};
    uint64_t lS_indices_13_dram;
    unsigned lS_indices_13_size = 128;
    unsigned lS_indices_13_size_in_bytes = lS_indices_13_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_indices_13_size_in_bytes, &lS_indices_13_dram, "lS_indices_13");
    ASSERT_TRUE(status == synSuccess && "lS_indices_13 dram malloc failed!");
    synLaunchTensorInfo lS_indices_13_tr_info = {"lS_indices_13", lS_indices_13_dram};
    UNUSED(lS_indices_13_tr_info); // For single op tests
    synTensor lS_indices_13 = createTensor(1U, syn_type_int32, lS_indices_13_sizes, true, "lS_indices_13");
    UNUSED(lS_indices_13); // For single op tests

    // create lS_offset_13 tensor
    const unsigned lS_offset_13_sizes[] = {128,};
    uint64_t lS_offset_13_dram;
    unsigned lS_offset_13_size = 128;
    unsigned lS_offset_13_size_in_bytes = lS_offset_13_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_offset_13_size_in_bytes, &lS_offset_13_dram, "lS_offset_13");
    ASSERT_TRUE(status == synSuccess && "lS_offset_13 dram malloc failed!");
    synLaunchTensorInfo lS_offset_13_tr_info = {"lS_offset_13", lS_offset_13_dram};
    UNUSED(lS_offset_13_tr_info); // For single op tests
    synTensor lS_offset_13 = createTensor(1U, syn_type_int32, lS_offset_13_sizes, true, "lS_offset_13");
    UNUSED(lS_offset_13); // For single op tests

    synTensor emb_13_embbag_in_vec[3] = {emb_13_embbag_weight, lS_indices_13, lS_offset_13};


    // create emb_13_embbag_output tensor
    const unsigned emb_13_embbag_output_sizes[] = {128, 32};
    synTensor emb_13_embbag_output = createTensor(2U, syn_type_bf16, emb_13_embbag_output_sizes, false, "emb_13_embbag_output");
    UNUSED(emb_13_embbag_output); // For single op tests

    synTensor emb_13_embbag_out_vec[1] = {emb_13_embbag_output};


    status = synNodeCreate(graphHandle, emb_13_embbag_in_vec, emb_13_embbag_out_vec, 3, 1, (void *)&emb_13_embbag_kernel_params, sizeof(emb_13_embbag_kernel_params), "embedding_bag_sgd_fwd_bf16", "emb_13_embbag", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_13_embbag failed!");

    /*************
     * emb_14_embbag node
     * inputs: [emb_14_embbag_weight[14746, 32](dtype=bf16), lS_indices_14[128](dtype=int32), lS_offset_14[128](dtype=int32)]
     * output: [emb_14_embbag_output(128, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_14_embbag_kernel_params;
    emb_14_embbag_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_14_embbag_kernel_params.sgd.wd = 0;
    emb_14_embbag_kernel_params.sgd.mom = 0;
    emb_14_embbag_kernel_params.sgd.damp = 0;
    emb_14_embbag_kernel_params.sgd.nesterov = false;

    // create emb_14_embbag_weight tensor
    const unsigned emb_14_embbag_weight_sizes[] = {14746, 32};
    uint64_t emb_14_embbag_weight_dram;
    unsigned emb_14_embbag_weight_size = 14746*32;
    unsigned emb_14_embbag_weight_size_in_bytes = emb_14_embbag_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(emb_14_embbag_weight_size_in_bytes, &emb_14_embbag_weight_dram, "emb_14_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_14_embbag_weight dram malloc failed!");
    synLaunchTensorInfo emb_14_embbag_weight_tr_info = {"emb_14_embbag_weight", emb_14_embbag_weight_dram};
    UNUSED(emb_14_embbag_weight_tr_info); // For single op tests
    synTensor emb_14_embbag_weight = createTensor(2U, syn_type_bf16, emb_14_embbag_weight_sizes, true, "emb_14_embbag_weight");
    UNUSED(emb_14_embbag_weight); // For single op tests

    // create lS_indices_14 tensor
    const unsigned lS_indices_14_sizes[] = {128,};
    uint64_t lS_indices_14_dram;
    unsigned lS_indices_14_size = 128;
    unsigned lS_indices_14_size_in_bytes = lS_indices_14_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_indices_14_size_in_bytes, &lS_indices_14_dram, "lS_indices_14");
    ASSERT_TRUE(status == synSuccess && "lS_indices_14 dram malloc failed!");
    synLaunchTensorInfo lS_indices_14_tr_info = {"lS_indices_14", lS_indices_14_dram};
    UNUSED(lS_indices_14_tr_info); // For single op tests
    synTensor lS_indices_14 = createTensor(1U, syn_type_int32, lS_indices_14_sizes, true, "lS_indices_14");
    UNUSED(lS_indices_14); // For single op tests

    // create lS_offset_14 tensor
    const unsigned lS_offset_14_sizes[] = {128,};
    uint64_t lS_offset_14_dram;
    unsigned lS_offset_14_size = 128;
    unsigned lS_offset_14_size_in_bytes = lS_offset_14_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_offset_14_size_in_bytes, &lS_offset_14_dram, "lS_offset_14");
    ASSERT_TRUE(status == synSuccess && "lS_offset_14 dram malloc failed!");
    synLaunchTensorInfo lS_offset_14_tr_info = {"lS_offset_14", lS_offset_14_dram};
    UNUSED(lS_offset_14_tr_info); // For single op tests
    synTensor lS_offset_14 = createTensor(1U, syn_type_int32, lS_offset_14_sizes, true, "lS_offset_14");
    UNUSED(lS_offset_14); // For single op tests

    synTensor emb_14_embbag_in_vec[3] = {emb_14_embbag_weight, lS_indices_14, lS_offset_14};


    // create emb_14_embbag_output tensor
    const unsigned emb_14_embbag_output_sizes[] = {128, 32};
    synTensor emb_14_embbag_output = createTensor(2U, syn_type_bf16, emb_14_embbag_output_sizes, false, "emb_14_embbag_output");
    UNUSED(emb_14_embbag_output); // For single op tests

    synTensor emb_14_embbag_out_vec[1] = {emb_14_embbag_output};


    status = synNodeCreate(graphHandle, emb_14_embbag_in_vec, emb_14_embbag_out_vec, 3, 1, (void *)&emb_14_embbag_kernel_params, sizeof(emb_14_embbag_kernel_params), "embedding_bag_sgd_fwd_bf16", "emb_14_embbag", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_14_embbag failed!");

    /*************
     * emb_15_embbag node
     * inputs: [emb_15_embbag_weight[4811892, 32](dtype=bf16), lS_indices_15[128](dtype=int32), lS_offset_15[128](dtype=int32)]
     * output: [emb_15_embbag_output(128, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_15_embbag_kernel_params;
    emb_15_embbag_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_15_embbag_kernel_params.sgd.wd = 0;
    emb_15_embbag_kernel_params.sgd.mom = 0;
    emb_15_embbag_kernel_params.sgd.damp = 0;
    emb_15_embbag_kernel_params.sgd.nesterov = false;

    // create emb_15_embbag_weight tensor
    const unsigned emb_15_embbag_weight_sizes[] = {4811892, 32};
    uint64_t emb_15_embbag_weight_dram;
    unsigned emb_15_embbag_weight_size = 4811892*32;
    unsigned emb_15_embbag_weight_size_in_bytes = emb_15_embbag_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(emb_15_embbag_weight_size_in_bytes, &emb_15_embbag_weight_dram, "emb_15_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_15_embbag_weight dram malloc failed!");
    synLaunchTensorInfo emb_15_embbag_weight_tr_info = {"emb_15_embbag_weight", emb_15_embbag_weight_dram};
    UNUSED(emb_15_embbag_weight_tr_info); // For single op tests
    synTensor emb_15_embbag_weight = createTensor(2U, syn_type_bf16, emb_15_embbag_weight_sizes, true, "emb_15_embbag_weight");
    UNUSED(emb_15_embbag_weight); // For single op tests

    // create lS_indices_15 tensor
    const unsigned lS_indices_15_sizes[] = {128,};
    uint64_t lS_indices_15_dram;
    unsigned lS_indices_15_size = 128;
    unsigned lS_indices_15_size_in_bytes = lS_indices_15_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_indices_15_size_in_bytes, &lS_indices_15_dram, "lS_indices_15");
    ASSERT_TRUE(status == synSuccess && "lS_indices_15 dram malloc failed!");
    synLaunchTensorInfo lS_indices_15_tr_info = {"lS_indices_15", lS_indices_15_dram};
    UNUSED(lS_indices_15_tr_info); // For single op tests
    synTensor lS_indices_15 = createTensor(1U, syn_type_int32, lS_indices_15_sizes, true, "lS_indices_15");
    UNUSED(lS_indices_15); // For single op tests

    // create lS_offset_15 tensor
    const unsigned lS_offset_15_sizes[] = {128,};
    uint64_t lS_offset_15_dram;
    unsigned lS_offset_15_size = 128;
    unsigned lS_offset_15_size_in_bytes = lS_offset_15_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_offset_15_size_in_bytes, &lS_offset_15_dram, "lS_offset_15");
    ASSERT_TRUE(status == synSuccess && "lS_offset_15 dram malloc failed!");
    synLaunchTensorInfo lS_offset_15_tr_info = {"lS_offset_15", lS_offset_15_dram};
    UNUSED(lS_offset_15_tr_info); // For single op tests
    synTensor lS_offset_15 = createTensor(1U, syn_type_int32, lS_offset_15_sizes, true, "lS_offset_15");
    UNUSED(lS_offset_15); // For single op tests

    synTensor emb_15_embbag_in_vec[3] = {emb_15_embbag_weight, lS_indices_15, lS_offset_15};


    // create emb_15_embbag_output tensor
    const unsigned emb_15_embbag_output_sizes[] = {128, 32};
    synTensor emb_15_embbag_output = createTensor(2U, syn_type_bf16, emb_15_embbag_output_sizes, false, "emb_15_embbag_output");
    UNUSED(emb_15_embbag_output); // For single op tests

    synTensor emb_15_embbag_out_vec[1] = {emb_15_embbag_output};


    status = synNodeCreate(graphHandle, emb_15_embbag_in_vec, emb_15_embbag_out_vec, 3, 1, (void *)&emb_15_embbag_kernel_params, sizeof(emb_15_embbag_kernel_params), "embedding_bag_sgd_fwd_bf16", "emb_15_embbag", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_15_embbag failed!");

    /*************
     * emb_16_embbag node
     * inputs: [emb_16_embbag_weight[10, 32](dtype=bf16), lS_indices_16[128](dtype=int32), lS_offset_16[128](dtype=int32)]
     * output: [emb_16_embbag_output(128, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_16_embbag_kernel_params;
    emb_16_embbag_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_16_embbag_kernel_params.sgd.wd = 0;
    emb_16_embbag_kernel_params.sgd.mom = 0;
    emb_16_embbag_kernel_params.sgd.damp = 0;
    emb_16_embbag_kernel_params.sgd.nesterov = false;

    // create emb_16_embbag_weight tensor
    const unsigned emb_16_embbag_weight_sizes[] = {10, 32};
    uint64_t emb_16_embbag_weight_dram;
    unsigned emb_16_embbag_weight_size = 10*32;
    unsigned emb_16_embbag_weight_size_in_bytes = emb_16_embbag_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(emb_16_embbag_weight_size_in_bytes, &emb_16_embbag_weight_dram, "emb_16_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_16_embbag_weight dram malloc failed!");
    synLaunchTensorInfo emb_16_embbag_weight_tr_info = {"emb_16_embbag_weight", emb_16_embbag_weight_dram};
    UNUSED(emb_16_embbag_weight_tr_info); // For single op tests
    synTensor emb_16_embbag_weight = createTensor(2U, syn_type_bf16, emb_16_embbag_weight_sizes, true, "emb_16_embbag_weight");
    UNUSED(emb_16_embbag_weight); // For single op tests

    // create lS_indices_16 tensor
    const unsigned lS_indices_16_sizes[] = {128,};
    uint64_t lS_indices_16_dram;
    unsigned lS_indices_16_size = 128;
    unsigned lS_indices_16_size_in_bytes = lS_indices_16_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_indices_16_size_in_bytes, &lS_indices_16_dram, "lS_indices_16");
    ASSERT_TRUE(status == synSuccess && "lS_indices_16 dram malloc failed!");
    synLaunchTensorInfo lS_indices_16_tr_info = {"lS_indices_16", lS_indices_16_dram};
    UNUSED(lS_indices_16_tr_info); // For single op tests
    synTensor lS_indices_16 = createTensor(1U, syn_type_int32, lS_indices_16_sizes, true, "lS_indices_16");
    UNUSED(lS_indices_16); // For single op tests

    // create lS_offset_16 tensor
    const unsigned lS_offset_16_sizes[] = {128,};
    uint64_t lS_offset_16_dram;
    unsigned lS_offset_16_size = 128;
    unsigned lS_offset_16_size_in_bytes = lS_offset_16_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_offset_16_size_in_bytes, &lS_offset_16_dram, "lS_offset_16");
    ASSERT_TRUE(status == synSuccess && "lS_offset_16 dram malloc failed!");
    synLaunchTensorInfo lS_offset_16_tr_info = {"lS_offset_16", lS_offset_16_dram};
    UNUSED(lS_offset_16_tr_info); // For single op tests
    synTensor lS_offset_16 = createTensor(1U, syn_type_int32, lS_offset_16_sizes, true, "lS_offset_16");
    UNUSED(lS_offset_16); // For single op tests

    synTensor emb_16_embbag_in_vec[3] = {emb_16_embbag_weight, lS_indices_16, lS_offset_16};


    // create emb_16_embbag_output tensor
    const unsigned emb_16_embbag_output_sizes[] = {128, 32};
    synTensor emb_16_embbag_output = createTensor(2U, syn_type_bf16, emb_16_embbag_output_sizes, false, "emb_16_embbag_output");
    UNUSED(emb_16_embbag_output); // For single op tests

    synTensor emb_16_embbag_out_vec[1] = {emb_16_embbag_output};


    status = synNodeCreate(graphHandle, emb_16_embbag_in_vec, emb_16_embbag_out_vec, 3, 1, (void *)&emb_16_embbag_kernel_params, sizeof(emb_16_embbag_kernel_params), "embedding_bag_sgd_fwd_bf16", "emb_16_embbag", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_16_embbag failed!");

    /*************
     * emb_17_embbag node
     * inputs: [emb_17_embbag_weight[5580, 32](dtype=bf16), lS_indices_17[128](dtype=int32), lS_offset_17[128](dtype=int32)]
     * output: [emb_17_embbag_output(128, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_17_embbag_kernel_params;
    emb_17_embbag_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_17_embbag_kernel_params.sgd.wd = 0;
    emb_17_embbag_kernel_params.sgd.mom = 0;
    emb_17_embbag_kernel_params.sgd.damp = 0;
    emb_17_embbag_kernel_params.sgd.nesterov = false;

    // create emb_17_embbag_weight tensor
    const unsigned emb_17_embbag_weight_sizes[] = {5580, 32};
    uint64_t emb_17_embbag_weight_dram;
    unsigned emb_17_embbag_weight_size = 5580*32;
    unsigned emb_17_embbag_weight_size_in_bytes = emb_17_embbag_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(emb_17_embbag_weight_size_in_bytes, &emb_17_embbag_weight_dram, "emb_17_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_17_embbag_weight dram malloc failed!");
    synLaunchTensorInfo emb_17_embbag_weight_tr_info = {"emb_17_embbag_weight", emb_17_embbag_weight_dram};
    UNUSED(emb_17_embbag_weight_tr_info); // For single op tests
    synTensor emb_17_embbag_weight = createTensor(2U, syn_type_bf16, emb_17_embbag_weight_sizes, true, "emb_17_embbag_weight");
    UNUSED(emb_17_embbag_weight); // For single op tests

    // create lS_indices_17 tensor
    const unsigned lS_indices_17_sizes[] = {128,};
    uint64_t lS_indices_17_dram;
    unsigned lS_indices_17_size = 128;
    unsigned lS_indices_17_size_in_bytes = lS_indices_17_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_indices_17_size_in_bytes, &lS_indices_17_dram, "lS_indices_17");
    ASSERT_TRUE(status == synSuccess && "lS_indices_17 dram malloc failed!");
    synLaunchTensorInfo lS_indices_17_tr_info = {"lS_indices_17", lS_indices_17_dram};
    UNUSED(lS_indices_17_tr_info); // For single op tests
    synTensor lS_indices_17 = createTensor(1U, syn_type_int32, lS_indices_17_sizes, true, "lS_indices_17");
    UNUSED(lS_indices_17); // For single op tests

    // create lS_offset_17 tensor
    const unsigned lS_offset_17_sizes[] = {128,};
    uint64_t lS_offset_17_dram;
    unsigned lS_offset_17_size = 128;
    unsigned lS_offset_17_size_in_bytes = lS_offset_17_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_offset_17_size_in_bytes, &lS_offset_17_dram, "lS_offset_17");
    ASSERT_TRUE(status == synSuccess && "lS_offset_17 dram malloc failed!");
    synLaunchTensorInfo lS_offset_17_tr_info = {"lS_offset_17", lS_offset_17_dram};
    UNUSED(lS_offset_17_tr_info); // For single op tests
    synTensor lS_offset_17 = createTensor(1U, syn_type_int32, lS_offset_17_sizes, true, "lS_offset_17");
    UNUSED(lS_offset_17); // For single op tests

    synTensor emb_17_embbag_in_vec[3] = {emb_17_embbag_weight, lS_indices_17, lS_offset_17};


    // create emb_17_embbag_output tensor
    const unsigned emb_17_embbag_output_sizes[] = {128, 32};
    synTensor emb_17_embbag_output = createTensor(2U, syn_type_bf16, emb_17_embbag_output_sizes, false, "emb_17_embbag_output");
    UNUSED(emb_17_embbag_output); // For single op tests

    synTensor emb_17_embbag_out_vec[1] = {emb_17_embbag_output};


    status = synNodeCreate(graphHandle, emb_17_embbag_in_vec, emb_17_embbag_out_vec, 3, 1, (void *)&emb_17_embbag_kernel_params, sizeof(emb_17_embbag_kernel_params), "embedding_bag_sgd_fwd_bf16", "emb_17_embbag", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_17_embbag failed!");

    /*************
     * emb_18_embbag node
     * inputs: [emb_18_embbag_weight[2171, 32](dtype=bf16), lS_indices_18[128](dtype=int32), lS_offset_18[128](dtype=int32)]
     * output: [emb_18_embbag_output(128, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_18_embbag_kernel_params;
    emb_18_embbag_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_18_embbag_kernel_params.sgd.wd = 0;
    emb_18_embbag_kernel_params.sgd.mom = 0;
    emb_18_embbag_kernel_params.sgd.damp = 0;
    emb_18_embbag_kernel_params.sgd.nesterov = false;

    // create emb_18_embbag_weight tensor
    const unsigned emb_18_embbag_weight_sizes[] = {2171, 32};
    uint64_t emb_18_embbag_weight_dram;
    unsigned emb_18_embbag_weight_size = 2171*32;
    unsigned emb_18_embbag_weight_size_in_bytes = emb_18_embbag_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(emb_18_embbag_weight_size_in_bytes, &emb_18_embbag_weight_dram, "emb_18_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_18_embbag_weight dram malloc failed!");
    synLaunchTensorInfo emb_18_embbag_weight_tr_info = {"emb_18_embbag_weight", emb_18_embbag_weight_dram};
    UNUSED(emb_18_embbag_weight_tr_info); // For single op tests
    synTensor emb_18_embbag_weight = createTensor(2U, syn_type_bf16, emb_18_embbag_weight_sizes, true, "emb_18_embbag_weight");
    UNUSED(emb_18_embbag_weight); // For single op tests

    // create lS_indices_18 tensor
    const unsigned lS_indices_18_sizes[] = {128,};
    uint64_t lS_indices_18_dram;
    unsigned lS_indices_18_size = 128;
    unsigned lS_indices_18_size_in_bytes = lS_indices_18_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_indices_18_size_in_bytes, &lS_indices_18_dram, "lS_indices_18");
    ASSERT_TRUE(status == synSuccess && "lS_indices_18 dram malloc failed!");
    synLaunchTensorInfo lS_indices_18_tr_info = {"lS_indices_18", lS_indices_18_dram};
    UNUSED(lS_indices_18_tr_info); // For single op tests
    synTensor lS_indices_18 = createTensor(1U, syn_type_int32, lS_indices_18_sizes, true, "lS_indices_18");
    UNUSED(lS_indices_18); // For single op tests

    // create lS_offset_18 tensor
    const unsigned lS_offset_18_sizes[] = {128,};
    uint64_t lS_offset_18_dram;
    unsigned lS_offset_18_size = 128;
    unsigned lS_offset_18_size_in_bytes = lS_offset_18_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_offset_18_size_in_bytes, &lS_offset_18_dram, "lS_offset_18");
    ASSERT_TRUE(status == synSuccess && "lS_offset_18 dram malloc failed!");
    synLaunchTensorInfo lS_offset_18_tr_info = {"lS_offset_18", lS_offset_18_dram};
    UNUSED(lS_offset_18_tr_info); // For single op tests
    synTensor lS_offset_18 = createTensor(1U, syn_type_int32, lS_offset_18_sizes, true, "lS_offset_18");
    UNUSED(lS_offset_18); // For single op tests

    synTensor emb_18_embbag_in_vec[3] = {emb_18_embbag_weight, lS_indices_18, lS_offset_18};


    // create emb_18_embbag_output tensor
    const unsigned emb_18_embbag_output_sizes[] = {128, 32};
    synTensor emb_18_embbag_output = createTensor(2U, syn_type_bf16, emb_18_embbag_output_sizes, false, "emb_18_embbag_output");
    UNUSED(emb_18_embbag_output); // For single op tests

    synTensor emb_18_embbag_out_vec[1] = {emb_18_embbag_output};


    status = synNodeCreate(graphHandle, emb_18_embbag_in_vec, emb_18_embbag_out_vec, 3, 1, (void *)&emb_18_embbag_kernel_params, sizeof(emb_18_embbag_kernel_params), "embedding_bag_sgd_fwd_bf16", "emb_18_embbag", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_18_embbag failed!");

    /*************
     * emb_19_embbag node
     * inputs: [emb_19_embbag_weight[4, 32](dtype=bf16), lS_indices_19[128](dtype=int32), lS_offset_19[128](dtype=int32)]
     * output: [emb_19_embbag_output(128, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_19_embbag_kernel_params;
    emb_19_embbag_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_19_embbag_kernel_params.sgd.wd = 0;
    emb_19_embbag_kernel_params.sgd.mom = 0;
    emb_19_embbag_kernel_params.sgd.damp = 0;
    emb_19_embbag_kernel_params.sgd.nesterov = false;

    // create emb_19_embbag_weight tensor
    const unsigned emb_19_embbag_weight_sizes[] = {4, 32};
    uint64_t emb_19_embbag_weight_dram;
    unsigned emb_19_embbag_weight_size = 4*32;
    unsigned emb_19_embbag_weight_size_in_bytes = emb_19_embbag_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(emb_19_embbag_weight_size_in_bytes, &emb_19_embbag_weight_dram, "emb_19_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_19_embbag_weight dram malloc failed!");
    synLaunchTensorInfo emb_19_embbag_weight_tr_info = {"emb_19_embbag_weight", emb_19_embbag_weight_dram};
    UNUSED(emb_19_embbag_weight_tr_info); // For single op tests
    synTensor emb_19_embbag_weight = createTensor(2U, syn_type_bf16, emb_19_embbag_weight_sizes, true, "emb_19_embbag_weight");
    UNUSED(emb_19_embbag_weight); // For single op tests

    // create lS_indices_19 tensor
    const unsigned lS_indices_19_sizes[] = {128,};
    uint64_t lS_indices_19_dram;
    unsigned lS_indices_19_size = 128;
    unsigned lS_indices_19_size_in_bytes = lS_indices_19_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_indices_19_size_in_bytes, &lS_indices_19_dram, "lS_indices_19");
    ASSERT_TRUE(status == synSuccess && "lS_indices_19 dram malloc failed!");
    synLaunchTensorInfo lS_indices_19_tr_info = {"lS_indices_19", lS_indices_19_dram};
    UNUSED(lS_indices_19_tr_info); // For single op tests
    synTensor lS_indices_19 = createTensor(1U, syn_type_int32, lS_indices_19_sizes, true, "lS_indices_19");
    UNUSED(lS_indices_19); // For single op tests

    // create lS_offset_19 tensor
    const unsigned lS_offset_19_sizes[] = {128,};
    uint64_t lS_offset_19_dram;
    unsigned lS_offset_19_size = 128;
    unsigned lS_offset_19_size_in_bytes = lS_offset_19_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_offset_19_size_in_bytes, &lS_offset_19_dram, "lS_offset_19");
    ASSERT_TRUE(status == synSuccess && "lS_offset_19 dram malloc failed!");
    synLaunchTensorInfo lS_offset_19_tr_info = {"lS_offset_19", lS_offset_19_dram};
    UNUSED(lS_offset_19_tr_info); // For single op tests
    synTensor lS_offset_19 = createTensor(1U, syn_type_int32, lS_offset_19_sizes, true, "lS_offset_19");
    UNUSED(lS_offset_19); // For single op tests

    synTensor emb_19_embbag_in_vec[3] = {emb_19_embbag_weight, lS_indices_19, lS_offset_19};


    // create emb_19_embbag_output tensor
    const unsigned emb_19_embbag_output_sizes[] = {128, 32};
    synTensor emb_19_embbag_output = createTensor(2U, syn_type_bf16, emb_19_embbag_output_sizes, false, "emb_19_embbag_output");
    UNUSED(emb_19_embbag_output); // For single op tests

    synTensor emb_19_embbag_out_vec[1] = {emb_19_embbag_output};


    status = synNodeCreate(graphHandle, emb_19_embbag_in_vec, emb_19_embbag_out_vec, 3, 1, (void *)&emb_19_embbag_kernel_params, sizeof(emb_19_embbag_kernel_params), "embedding_bag_sgd_fwd_bf16", "emb_19_embbag", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_19_embbag failed!");

    /*************
     * emb_20_embbag node
     * inputs: [emb_20_embbag_weight[6183794, 32](dtype=bf16), lS_indices_20[128](dtype=int32), lS_offset_20[128](dtype=int32)]
     * output: [emb_20_embbag_output(128, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_20_embbag_kernel_params;
    emb_20_embbag_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_20_embbag_kernel_params.sgd.wd = 0;
    emb_20_embbag_kernel_params.sgd.mom = 0;
    emb_20_embbag_kernel_params.sgd.damp = 0;
    emb_20_embbag_kernel_params.sgd.nesterov = false;

    // create emb_20_embbag_weight tensor
    const unsigned emb_20_embbag_weight_sizes[] = {6183794, 32};
    uint64_t emb_20_embbag_weight_dram;
    unsigned emb_20_embbag_weight_size = 6183794*32;
    unsigned emb_20_embbag_weight_size_in_bytes = emb_20_embbag_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(emb_20_embbag_weight_size_in_bytes, &emb_20_embbag_weight_dram, "emb_20_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_20_embbag_weight dram malloc failed!");
    synLaunchTensorInfo emb_20_embbag_weight_tr_info = {"emb_20_embbag_weight", emb_20_embbag_weight_dram};
    UNUSED(emb_20_embbag_weight_tr_info); // For single op tests
    synTensor emb_20_embbag_weight = createTensor(2U, syn_type_bf16, emb_20_embbag_weight_sizes, true, "emb_20_embbag_weight");
    UNUSED(emb_20_embbag_weight); // For single op tests

    // create lS_indices_20 tensor
    const unsigned lS_indices_20_sizes[] = {128,};
    uint64_t lS_indices_20_dram;
    unsigned lS_indices_20_size = 128;
    unsigned lS_indices_20_size_in_bytes = lS_indices_20_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_indices_20_size_in_bytes, &lS_indices_20_dram, "lS_indices_20");
    ASSERT_TRUE(status == synSuccess && "lS_indices_20 dram malloc failed!");
    synLaunchTensorInfo lS_indices_20_tr_info = {"lS_indices_20", lS_indices_20_dram};
    UNUSED(lS_indices_20_tr_info); // For single op tests
    synTensor lS_indices_20 = createTensor(1U, syn_type_int32, lS_indices_20_sizes, true, "lS_indices_20");
    UNUSED(lS_indices_20); // For single op tests

    // create lS_offset_20 tensor
    const unsigned lS_offset_20_sizes[] = {128,};
    uint64_t lS_offset_20_dram;
    unsigned lS_offset_20_size = 128;
    unsigned lS_offset_20_size_in_bytes = lS_offset_20_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_offset_20_size_in_bytes, &lS_offset_20_dram, "lS_offset_20");
    ASSERT_TRUE(status == synSuccess && "lS_offset_20 dram malloc failed!");
    synLaunchTensorInfo lS_offset_20_tr_info = {"lS_offset_20", lS_offset_20_dram};
    UNUSED(lS_offset_20_tr_info); // For single op tests
    synTensor lS_offset_20 = createTensor(1U, syn_type_int32, lS_offset_20_sizes, true, "lS_offset_20");
    UNUSED(lS_offset_20); // For single op tests

    synTensor emb_20_embbag_in_vec[3] = {emb_20_embbag_weight, lS_indices_20, lS_offset_20};


    // create emb_20_embbag_output tensor
    const unsigned emb_20_embbag_output_sizes[] = {128, 32};
    synTensor emb_20_embbag_output = createTensor(2U, syn_type_bf16, emb_20_embbag_output_sizes, false, "emb_20_embbag_output");
    UNUSED(emb_20_embbag_output); // For single op tests

    synTensor emb_20_embbag_out_vec[1] = {emb_20_embbag_output};


    status = synNodeCreate(graphHandle, emb_20_embbag_in_vec, emb_20_embbag_out_vec, 3, 1, (void *)&emb_20_embbag_kernel_params, sizeof(emb_20_embbag_kernel_params), "embedding_bag_sgd_fwd_bf16", "emb_20_embbag", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_20_embbag failed!");

    /*************
     * emb_21_embbag node
     * inputs: [emb_21_embbag_weight[18, 32](dtype=bf16), lS_indices_21[128](dtype=int32), lS_offset_21[128](dtype=int32)]
     * output: [emb_21_embbag_output(128, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_21_embbag_kernel_params;
    emb_21_embbag_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_21_embbag_kernel_params.sgd.wd = 0;
    emb_21_embbag_kernel_params.sgd.mom = 0;
    emb_21_embbag_kernel_params.sgd.damp = 0;
    emb_21_embbag_kernel_params.sgd.nesterov = false;

    // create emb_21_embbag_weight tensor
    const unsigned emb_21_embbag_weight_sizes[] = {18, 32};
    uint64_t emb_21_embbag_weight_dram;
    unsigned emb_21_embbag_weight_size = 18*32;
    unsigned emb_21_embbag_weight_size_in_bytes = emb_21_embbag_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(emb_21_embbag_weight_size_in_bytes, &emb_21_embbag_weight_dram, "emb_21_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_21_embbag_weight dram malloc failed!");
    synLaunchTensorInfo emb_21_embbag_weight_tr_info = {"emb_21_embbag_weight", emb_21_embbag_weight_dram};
    UNUSED(emb_21_embbag_weight_tr_info); // For single op tests
    synTensor emb_21_embbag_weight = createTensor(2U, syn_type_bf16, emb_21_embbag_weight_sizes, true, "emb_21_embbag_weight");
    UNUSED(emb_21_embbag_weight); // For single op tests

    // create lS_indices_21 tensor
    const unsigned lS_indices_21_sizes[] = {128,};
    uint64_t lS_indices_21_dram;
    unsigned lS_indices_21_size = 128;
    unsigned lS_indices_21_size_in_bytes = lS_indices_21_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_indices_21_size_in_bytes, &lS_indices_21_dram, "lS_indices_21");
    ASSERT_TRUE(status == synSuccess && "lS_indices_21 dram malloc failed!");
    synLaunchTensorInfo lS_indices_21_tr_info = {"lS_indices_21", lS_indices_21_dram};
    UNUSED(lS_indices_21_tr_info); // For single op tests
    synTensor lS_indices_21 = createTensor(1U, syn_type_int32, lS_indices_21_sizes, true, "lS_indices_21");
    UNUSED(lS_indices_21); // For single op tests

    // create lS_offset_21 tensor
    const unsigned lS_offset_21_sizes[] = {128,};
    uint64_t lS_offset_21_dram;
    unsigned lS_offset_21_size = 128;
    unsigned lS_offset_21_size_in_bytes = lS_offset_21_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_offset_21_size_in_bytes, &lS_offset_21_dram, "lS_offset_21");
    ASSERT_TRUE(status == synSuccess && "lS_offset_21 dram malloc failed!");
    synLaunchTensorInfo lS_offset_21_tr_info = {"lS_offset_21", lS_offset_21_dram};
    UNUSED(lS_offset_21_tr_info); // For single op tests
    synTensor lS_offset_21 = createTensor(1U, syn_type_int32, lS_offset_21_sizes, true, "lS_offset_21");
    UNUSED(lS_offset_21); // For single op tests

    synTensor emb_21_embbag_in_vec[3] = {emb_21_embbag_weight, lS_indices_21, lS_offset_21};


    // create emb_21_embbag_output tensor
    const unsigned emb_21_embbag_output_sizes[] = {128, 32};
    synTensor emb_21_embbag_output = createTensor(2U, syn_type_bf16, emb_21_embbag_output_sizes, false, "emb_21_embbag_output");
    UNUSED(emb_21_embbag_output); // For single op tests

    synTensor emb_21_embbag_out_vec[1] = {emb_21_embbag_output};


    status = synNodeCreate(graphHandle, emb_21_embbag_in_vec, emb_21_embbag_out_vec, 3, 1, (void *)&emb_21_embbag_kernel_params, sizeof(emb_21_embbag_kernel_params), "embedding_bag_sgd_fwd_bf16", "emb_21_embbag", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_21_embbag failed!");

    /*************
     * emb_22_embbag node
     * inputs: [emb_22_embbag_weight[15, 32](dtype=bf16), lS_indices_22[128](dtype=int32), lS_offset_22[128](dtype=int32)]
     * output: [emb_22_embbag_output(128, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_22_embbag_kernel_params;
    emb_22_embbag_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_22_embbag_kernel_params.sgd.wd = 0;
    emb_22_embbag_kernel_params.sgd.mom = 0;
    emb_22_embbag_kernel_params.sgd.damp = 0;
    emb_22_embbag_kernel_params.sgd.nesterov = false;

    // create emb_22_embbag_weight tensor
    const unsigned emb_22_embbag_weight_sizes[] = {15, 32};
    uint64_t emb_22_embbag_weight_dram;
    unsigned emb_22_embbag_weight_size = 15*32;
    unsigned emb_22_embbag_weight_size_in_bytes = emb_22_embbag_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(emb_22_embbag_weight_size_in_bytes, &emb_22_embbag_weight_dram, "emb_22_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_22_embbag_weight dram malloc failed!");
    synLaunchTensorInfo emb_22_embbag_weight_tr_info = {"emb_22_embbag_weight", emb_22_embbag_weight_dram};
    UNUSED(emb_22_embbag_weight_tr_info); // For single op tests
    synTensor emb_22_embbag_weight = createTensor(2U, syn_type_bf16, emb_22_embbag_weight_sizes, true, "emb_22_embbag_weight");
    UNUSED(emb_22_embbag_weight); // For single op tests

    // create lS_indices_22 tensor
    const unsigned lS_indices_22_sizes[] = {128,};
    uint64_t lS_indices_22_dram;
    unsigned lS_indices_22_size = 128;
    unsigned lS_indices_22_size_in_bytes = lS_indices_22_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_indices_22_size_in_bytes, &lS_indices_22_dram, "lS_indices_22");
    ASSERT_TRUE(status == synSuccess && "lS_indices_22 dram malloc failed!");
    synLaunchTensorInfo lS_indices_22_tr_info = {"lS_indices_22", lS_indices_22_dram};
    UNUSED(lS_indices_22_tr_info); // For single op tests
    synTensor lS_indices_22 = createTensor(1U, syn_type_int32, lS_indices_22_sizes, true, "lS_indices_22");
    UNUSED(lS_indices_22); // For single op tests

    // create lS_offset_22 tensor
    const unsigned lS_offset_22_sizes[] = {128,};
    uint64_t lS_offset_22_dram;
    unsigned lS_offset_22_size = 128;
    unsigned lS_offset_22_size_in_bytes = lS_offset_22_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_offset_22_size_in_bytes, &lS_offset_22_dram, "lS_offset_22");
    ASSERT_TRUE(status == synSuccess && "lS_offset_22 dram malloc failed!");
    synLaunchTensorInfo lS_offset_22_tr_info = {"lS_offset_22", lS_offset_22_dram};
    UNUSED(lS_offset_22_tr_info); // For single op tests
    synTensor lS_offset_22 = createTensor(1U, syn_type_int32, lS_offset_22_sizes, true, "lS_offset_22");
    UNUSED(lS_offset_22); // For single op tests

    synTensor emb_22_embbag_in_vec[3] = {emb_22_embbag_weight, lS_indices_22, lS_offset_22};


    // create emb_22_embbag_output tensor
    const unsigned emb_22_embbag_output_sizes[] = {128, 32};
    synTensor emb_22_embbag_output = createTensor(2U, syn_type_bf16, emb_22_embbag_output_sizes, false, "emb_22_embbag_output");
    UNUSED(emb_22_embbag_output); // For single op tests

    synTensor emb_22_embbag_out_vec[1] = {emb_22_embbag_output};


    status = synNodeCreate(graphHandle, emb_22_embbag_in_vec, emb_22_embbag_out_vec, 3, 1, (void *)&emb_22_embbag_kernel_params, sizeof(emb_22_embbag_kernel_params), "embedding_bag_sgd_fwd_bf16", "emb_22_embbag", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_22_embbag failed!");

    /*************
     * emb_23_embbag node
     * inputs: [emb_23_embbag_weight[266403, 32](dtype=bf16), lS_indices_23[128](dtype=int32), lS_offset_23[128](dtype=int32)]
     * output: [emb_23_embbag_output(128, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_23_embbag_kernel_params;
    emb_23_embbag_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_23_embbag_kernel_params.sgd.wd = 0;
    emb_23_embbag_kernel_params.sgd.mom = 0;
    emb_23_embbag_kernel_params.sgd.damp = 0;
    emb_23_embbag_kernel_params.sgd.nesterov = false;

    // create emb_23_embbag_weight tensor
    const unsigned emb_23_embbag_weight_sizes[] = {266403, 32};
    uint64_t emb_23_embbag_weight_dram;
    unsigned emb_23_embbag_weight_size = 266403*32;
    unsigned emb_23_embbag_weight_size_in_bytes = emb_23_embbag_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(emb_23_embbag_weight_size_in_bytes, &emb_23_embbag_weight_dram, "emb_23_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_23_embbag_weight dram malloc failed!");
    synLaunchTensorInfo emb_23_embbag_weight_tr_info = {"emb_23_embbag_weight", emb_23_embbag_weight_dram};
    UNUSED(emb_23_embbag_weight_tr_info); // For single op tests
    synTensor emb_23_embbag_weight = createTensor(2U, syn_type_bf16, emb_23_embbag_weight_sizes, true, "emb_23_embbag_weight");
    UNUSED(emb_23_embbag_weight); // For single op tests

    // create lS_indices_23 tensor
    const unsigned lS_indices_23_sizes[] = {128,};
    uint64_t lS_indices_23_dram;
    unsigned lS_indices_23_size = 128;
    unsigned lS_indices_23_size_in_bytes = lS_indices_23_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_indices_23_size_in_bytes, &lS_indices_23_dram, "lS_indices_23");
    ASSERT_TRUE(status == synSuccess && "lS_indices_23 dram malloc failed!");
    synLaunchTensorInfo lS_indices_23_tr_info = {"lS_indices_23", lS_indices_23_dram};
    UNUSED(lS_indices_23_tr_info); // For single op tests
    synTensor lS_indices_23 = createTensor(1U, syn_type_int32, lS_indices_23_sizes, true, "lS_indices_23");
    UNUSED(lS_indices_23); // For single op tests

    // create lS_offset_23 tensor
    const unsigned lS_offset_23_sizes[] = {128,};
    uint64_t lS_offset_23_dram;
    unsigned lS_offset_23_size = 128;
    unsigned lS_offset_23_size_in_bytes = lS_offset_23_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_offset_23_size_in_bytes, &lS_offset_23_dram, "lS_offset_23");
    ASSERT_TRUE(status == synSuccess && "lS_offset_23 dram malloc failed!");
    synLaunchTensorInfo lS_offset_23_tr_info = {"lS_offset_23", lS_offset_23_dram};
    UNUSED(lS_offset_23_tr_info); // For single op tests
    synTensor lS_offset_23 = createTensor(1U, syn_type_int32, lS_offset_23_sizes, true, "lS_offset_23");
    UNUSED(lS_offset_23); // For single op tests

    synTensor emb_23_embbag_in_vec[3] = {emb_23_embbag_weight, lS_indices_23, lS_offset_23};


    // create emb_23_embbag_output tensor
    const unsigned emb_23_embbag_output_sizes[] = {128, 32};
    synTensor emb_23_embbag_output = createTensor(2U, syn_type_bf16, emb_23_embbag_output_sizes, false, "emb_23_embbag_output");
    UNUSED(emb_23_embbag_output); // For single op tests

    synTensor emb_23_embbag_out_vec[1] = {emb_23_embbag_output};


    status = synNodeCreate(graphHandle, emb_23_embbag_in_vec, emb_23_embbag_out_vec, 3, 1, (void *)&emb_23_embbag_kernel_params, sizeof(emb_23_embbag_kernel_params), "embedding_bag_sgd_fwd_bf16", "emb_23_embbag", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_23_embbag failed!");

    /*************
     * emb_24_embbag node
     * inputs: [emb_24_embbag_weight[105, 32](dtype=bf16), lS_indices_24[128](dtype=int32), lS_offset_24[128](dtype=int32)]
     * output: [emb_24_embbag_output(128, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_24_embbag_kernel_params;
    emb_24_embbag_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_24_embbag_kernel_params.sgd.wd = 0;
    emb_24_embbag_kernel_params.sgd.mom = 0;
    emb_24_embbag_kernel_params.sgd.damp = 0;
    emb_24_embbag_kernel_params.sgd.nesterov = false;

    // create emb_24_embbag_weight tensor
    const unsigned emb_24_embbag_weight_sizes[] = {105, 32};
    uint64_t emb_24_embbag_weight_dram;
    unsigned emb_24_embbag_weight_size = 105*32;
    unsigned emb_24_embbag_weight_size_in_bytes = emb_24_embbag_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(emb_24_embbag_weight_size_in_bytes, &emb_24_embbag_weight_dram, "emb_24_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_24_embbag_weight dram malloc failed!");
    synLaunchTensorInfo emb_24_embbag_weight_tr_info = {"emb_24_embbag_weight", emb_24_embbag_weight_dram};
    UNUSED(emb_24_embbag_weight_tr_info); // For single op tests
    synTensor emb_24_embbag_weight = createTensor(2U, syn_type_bf16, emb_24_embbag_weight_sizes, true, "emb_24_embbag_weight");
    UNUSED(emb_24_embbag_weight); // For single op tests

    // create lS_indices_24 tensor
    const unsigned lS_indices_24_sizes[] = {128,};
    uint64_t lS_indices_24_dram;
    unsigned lS_indices_24_size = 128;
    unsigned lS_indices_24_size_in_bytes = lS_indices_24_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_indices_24_size_in_bytes, &lS_indices_24_dram, "lS_indices_24");
    ASSERT_TRUE(status == synSuccess && "lS_indices_24 dram malloc failed!");
    synLaunchTensorInfo lS_indices_24_tr_info = {"lS_indices_24", lS_indices_24_dram};
    UNUSED(lS_indices_24_tr_info); // For single op tests
    synTensor lS_indices_24 = createTensor(1U, syn_type_int32, lS_indices_24_sizes, true, "lS_indices_24");
    UNUSED(lS_indices_24); // For single op tests

    // create lS_offset_24 tensor
    const unsigned lS_offset_24_sizes[] = {128,};
    uint64_t lS_offset_24_dram;
    unsigned lS_offset_24_size = 128;
    unsigned lS_offset_24_size_in_bytes = lS_offset_24_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_offset_24_size_in_bytes, &lS_offset_24_dram, "lS_offset_24");
    ASSERT_TRUE(status == synSuccess && "lS_offset_24 dram malloc failed!");
    synLaunchTensorInfo lS_offset_24_tr_info = {"lS_offset_24", lS_offset_24_dram};
    UNUSED(lS_offset_24_tr_info); // For single op tests
    synTensor lS_offset_24 = createTensor(1U, syn_type_int32, lS_offset_24_sizes, true, "lS_offset_24");
    UNUSED(lS_offset_24); // For single op tests

    synTensor emb_24_embbag_in_vec[3] = {emb_24_embbag_weight, lS_indices_24, lS_offset_24};


    // create emb_24_embbag_output tensor
    const unsigned emb_24_embbag_output_sizes[] = {128, 32};
    synTensor emb_24_embbag_output = createTensor(2U, syn_type_bf16, emb_24_embbag_output_sizes, false, "emb_24_embbag_output");
    UNUSED(emb_24_embbag_output); // For single op tests

    synTensor emb_24_embbag_out_vec[1] = {emb_24_embbag_output};


    status = synNodeCreate(graphHandle, emb_24_embbag_in_vec, emb_24_embbag_out_vec, 3, 1, (void *)&emb_24_embbag_kernel_params, sizeof(emb_24_embbag_kernel_params), "embedding_bag_sgd_fwd_bf16", "emb_24_embbag", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_24_embbag failed!");

    /*************
     * emb_25_embbag node
     * inputs: [emb_25_embbag_weight[135786, 32](dtype=bf16), lS_indices_25[128](dtype=int32), lS_offset_25[128](dtype=int32)]
     * output: [emb_25_embbag_output(128, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_25_embbag_kernel_params;
    emb_25_embbag_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_25_embbag_kernel_params.sgd.wd = 0;
    emb_25_embbag_kernel_params.sgd.mom = 0;
    emb_25_embbag_kernel_params.sgd.damp = 0;
    emb_25_embbag_kernel_params.sgd.nesterov = false;

    // create emb_25_embbag_weight tensor
    const unsigned emb_25_embbag_weight_sizes[] = {135786, 32};
    uint64_t emb_25_embbag_weight_dram;
    unsigned emb_25_embbag_weight_size = 135786*32;
    unsigned emb_25_embbag_weight_size_in_bytes = emb_25_embbag_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(emb_25_embbag_weight_size_in_bytes, &emb_25_embbag_weight_dram, "emb_25_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_25_embbag_weight dram malloc failed!");
    synLaunchTensorInfo emb_25_embbag_weight_tr_info = {"emb_25_embbag_weight", emb_25_embbag_weight_dram};
    UNUSED(emb_25_embbag_weight_tr_info); // For single op tests
    synTensor emb_25_embbag_weight = createTensor(2U, syn_type_bf16, emb_25_embbag_weight_sizes, true, "emb_25_embbag_weight");
    UNUSED(emb_25_embbag_weight); // For single op tests

    // create lS_indices_25 tensor
    const unsigned lS_indices_25_sizes[] = {128,};
    uint64_t lS_indices_25_dram;
    unsigned lS_indices_25_size = 128;
    unsigned lS_indices_25_size_in_bytes = lS_indices_25_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_indices_25_size_in_bytes, &lS_indices_25_dram, "lS_indices_25");
    ASSERT_TRUE(status == synSuccess && "lS_indices_25 dram malloc failed!");
    synLaunchTensorInfo lS_indices_25_tr_info = {"lS_indices_25", lS_indices_25_dram};
    UNUSED(lS_indices_25_tr_info); // For single op tests
    synTensor lS_indices_25 = createTensor(1U, syn_type_int32, lS_indices_25_sizes, true, "lS_indices_25");
    UNUSED(lS_indices_25); // For single op tests

    // create lS_offset_25 tensor
    const unsigned lS_offset_25_sizes[] = {128,};
    uint64_t lS_offset_25_dram;
    unsigned lS_offset_25_size = 128;
    unsigned lS_offset_25_size_in_bytes = lS_offset_25_size * sizeof(int32_t) ;
    status = hbmAlloc(lS_offset_25_size_in_bytes, &lS_offset_25_dram, "lS_offset_25");
    ASSERT_TRUE(status == synSuccess && "lS_offset_25 dram malloc failed!");
    synLaunchTensorInfo lS_offset_25_tr_info = {"lS_offset_25", lS_offset_25_dram};
    UNUSED(lS_offset_25_tr_info); // For single op tests
    synTensor lS_offset_25 = createTensor(1U, syn_type_int32, lS_offset_25_sizes, true, "lS_offset_25");
    UNUSED(lS_offset_25); // For single op tests

    synTensor emb_25_embbag_in_vec[3] = {emb_25_embbag_weight, lS_indices_25, lS_offset_25};


    // create emb_25_embbag_output tensor
    const unsigned emb_25_embbag_output_sizes[] = {128, 32};
    synTensor emb_25_embbag_output = createTensor(2U, syn_type_bf16, emb_25_embbag_output_sizes, false, "emb_25_embbag_output");
    UNUSED(emb_25_embbag_output); // For single op tests

    synTensor emb_25_embbag_out_vec[1] = {emb_25_embbag_output};


    status = synNodeCreate(graphHandle, emb_25_embbag_in_vec, emb_25_embbag_out_vec, 3, 1, (void *)&emb_25_embbag_kernel_params, sizeof(emb_25_embbag_kernel_params), "embedding_bag_sgd_fwd_bf16", "emb_25_embbag", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_25_embbag failed!");

    /*************
     * concat_interact0_bot_l_4_relu_output_reshape node
     * inputs: [bot_l_4_relu_output(128, 1, 1, 32)(dtype=bf16)]
     * output: [concat_interact0_bot_l_4_relu_output_tensor_reshape(128, 32)(dtype=bf16)]
     *************/

    synTensor concat_interact0_bot_l_4_relu_output_reshape_in_vec[1] = {bot_l_4_relu_output};


    // create concat_interact0_bot_l_4_relu_output_tensor_reshape tensor
    const unsigned concat_interact0_bot_l_4_relu_output_tensor_reshape_sizes[] = {128, 32};
    synTensor concat_interact0_bot_l_4_relu_output_tensor_reshape = createTensor(2U, syn_type_bf16, concat_interact0_bot_l_4_relu_output_tensor_reshape_sizes, false, "concat_interact0_bot_l_4_relu_output_tensor_reshape");
    UNUSED(concat_interact0_bot_l_4_relu_output_tensor_reshape); // For single op tests

    synTensor concat_interact0_bot_l_4_relu_output_reshape_out_vec[1] = {concat_interact0_bot_l_4_relu_output_tensor_reshape};


    status = synNodeCreate(graphHandle, concat_interact0_bot_l_4_relu_output_reshape_in_vec, concat_interact0_bot_l_4_relu_output_reshape_out_vec, 1, 1, nullptr, 0, "reshape", "concat_interact0_bot_l_4_relu_output_reshape", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for concat_interact0_bot_l_4_relu_output_reshape failed!");

    /*************
     * concat_interact0 node
     * inputs: [concat_interact0_bot_l_4_relu_output_tensor_reshape(128, 32)(dtype=bf16), emb_0_embbag_output(128, 32)(dtype=bf16), emb_1_embbag_output(128, 32)(dtype=bf16), emb_2_embbag_output(128, 32)(dtype=bf16), emb_3_embbag_output(128, 32)(dtype=bf16), emb_4_embbag_output(128, 32)(dtype=bf16), emb_5_embbag_output(128, 32)(dtype=bf16), emb_6_embbag_output(128, 32)(dtype=bf16), emb_7_embbag_output(128, 32)(dtype=bf16), emb_8_embbag_output(128, 32)(dtype=bf16), emb_9_embbag_output(128, 32)(dtype=bf16), emb_10_embbag_output(128, 32)(dtype=bf16), emb_11_embbag_output(128, 32)(dtype=bf16), emb_12_embbag_output(128, 32)(dtype=bf16), emb_13_embbag_output(128, 32)(dtype=bf16), emb_14_embbag_output(128, 32)(dtype=bf16), emb_15_embbag_output(128, 32)(dtype=bf16), emb_16_embbag_output(128, 32)(dtype=bf16), emb_17_embbag_output(128, 32)(dtype=bf16), emb_18_embbag_output(128, 32)(dtype=bf16), emb_19_embbag_output(128, 32)(dtype=bf16), emb_20_embbag_output(128, 32)(dtype=bf16), emb_21_embbag_output(128, 32)(dtype=bf16), emb_22_embbag_output(128, 32)(dtype=bf16), emb_23_embbag_output(128, 32)(dtype=bf16), emb_24_embbag_output(128, 32)(dtype=bf16), emb_25_embbag_output(128, 32)(dtype=bf16)]
     * output: [concat_interact0_output(128, 864)(dtype=bf16)]
     *************/

    synTensor concat_interact0_in_vec[27] = {concat_interact0_bot_l_4_relu_output_tensor_reshape, emb_0_embbag_output, emb_1_embbag_output, emb_2_embbag_output, emb_3_embbag_output, emb_4_embbag_output, emb_5_embbag_output, emb_6_embbag_output, emb_7_embbag_output, emb_8_embbag_output, emb_9_embbag_output, emb_10_embbag_output, emb_11_embbag_output, emb_12_embbag_output, emb_13_embbag_output, emb_14_embbag_output, emb_15_embbag_output, emb_16_embbag_output, emb_17_embbag_output, emb_18_embbag_output, emb_19_embbag_output, emb_20_embbag_output, emb_21_embbag_output, emb_22_embbag_output, emb_23_embbag_output, emb_24_embbag_output, emb_25_embbag_output};


    // create concat_interact0_output tensor
    const unsigned concat_interact0_output_sizes[] = {128, 864};
    synTensor concat_interact0_output = createTensor(2U, syn_type_bf16, concat_interact0_output_sizes, false, "concat_interact0_output");
    UNUSED(concat_interact0_output); // For single op tests

    synTensor concat_interact0_out_vec[1] = {concat_interact0_output};


    status = synNodeCreate(graphHandle, concat_interact0_in_vec, concat_interact0_out_vec, 27, 1, nullptr, 0, "concat", "concat_interact0", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for concat_interact0 failed!");

    /*************
     * reshape_bmm_fwd node
     * inputs: [concat_interact0_output(128, 864)(dtype=bf16)]
     * output: [reshape_bmm_output(128, 27, 32)(dtype=bf16)]
     *************/

    synTensor reshape_bmm_fwd_in_vec[1] = {concat_interact0_output};


    // create reshape_bmm_output tensor
    const unsigned reshape_bmm_output_sizes[] = {128, 27, 32};
    uint64_t reshape_bmm_output_dram;
    unsigned reshape_bmm_output_size = 128*27*32;
    unsigned reshape_bmm_output_size_in_bytes = reshape_bmm_output_size * sizeof(bfloat16) ;
    status = hbmAlloc(reshape_bmm_output_size_in_bytes, &reshape_bmm_output_dram, "reshape_bmm_output");
    ASSERT_TRUE(status == synSuccess && "reshape_bmm_output dram malloc failed!");
    synLaunchTensorInfo reshape_bmm_output_tr_info = {"reshape_bmm_output", reshape_bmm_output_dram};
    UNUSED(reshape_bmm_output_tr_info); // For single op tests
    synTensor reshape_bmm_output = createTensor(3U, syn_type_bf16, reshape_bmm_output_sizes, true, "reshape_bmm_output");
    UNUSED(reshape_bmm_output); // For single op tests

    synTensor reshape_bmm_fwd_out_vec[1] = {reshape_bmm_output};


    status = synNodeCreate(graphHandle, reshape_bmm_fwd_in_vec, reshape_bmm_fwd_out_vec, 1, 1, nullptr, 0, "reshape", "reshape_bmm_fwd", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for reshape_bmm_fwd failed!");

    /*************
     * bmm_interact node
     * inputs: [reshape_bmm_output(128, 27, 32)(dtype=bf16), reshape_bmm_output(128, 27, 32)(dtype=bf16)]
     * output: [bmm_interact_output(128, 27, 27)(dtype=bf16)]
     *************/
    synGEMMParams bmm_interact_kernel_params;
    bmm_interact_kernel_params.transpose_a = false;
    bmm_interact_kernel_params.transpose_b = true;

    synTensor bmm_interact_in_vec[2] = {reshape_bmm_output, reshape_bmm_output};


    // create bmm_interact_output tensor
    const unsigned bmm_interact_output_sizes[] = {128, 27, 27};
    synTensor bmm_interact_output = createTensor(3U, syn_type_bf16, bmm_interact_output_sizes, false, "bmm_interact_output");
    UNUSED(bmm_interact_output); // For single op tests

    synTensor bmm_interact_out_vec[1] = {bmm_interact_output};


    status = synNodeCreate(graphHandle, bmm_interact_in_vec, bmm_interact_out_vec, 2, 1, (void *)&bmm_interact_kernel_params, sizeof(bmm_interact_kernel_params), "batch_gemm", "bmm_interact", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bmm_interact failed!");

    /*************
     * reshape_tril_fwd node
     * inputs: [bmm_interact_output(128, 27, 27)(dtype=bf16)]
     * output: [reshape_tril_output(128, 729)(dtype=bf16)]
     *************/

    synTensor reshape_tril_fwd_in_vec[1] = {bmm_interact_output};


    // create reshape_tril_output tensor
    const unsigned reshape_tril_output_sizes[] = {128, 729};
    synTensor reshape_tril_output = createTensor(2U, syn_type_bf16, reshape_tril_output_sizes, false, "reshape_tril_output");
    UNUSED(reshape_tril_output); // For single op tests

    synTensor reshape_tril_fwd_out_vec[1] = {reshape_tril_output};


    status = synNodeCreate(graphHandle, reshape_tril_fwd_in_vec, reshape_tril_fwd_out_vec, 1, 1, nullptr, 0, "reshape", "reshape_tril_fwd", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for reshape_tril_fwd failed!");

    /*************
     * tril_indices_fwd node
     * inputs: [reshape_tril_output(128, 729)(dtype=bf16), tril_indices[351](dtype=int32)]
     * output: [tril_indices_output(128, 351)(dtype=bf16)]
     *************/
    ns_ScatterKernel::Params tril_indices_fwd_kernel_params;
    tril_indices_fwd_kernel_params.axis = 0;

    // create tril_indices tensor
    const unsigned tril_indices_sizes[] = {351,};
    uint64_t tril_indices_dram;
    unsigned tril_indices_size = 351;
    unsigned tril_indices_size_in_bytes = tril_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(tril_indices_size_in_bytes, &tril_indices_dram, "tril_indices");
    ASSERT_TRUE(status == synSuccess && "tril_indices dram malloc failed!");
    synLaunchTensorInfo tril_indices_tr_info = {"tril_indices", tril_indices_dram};
    UNUSED(tril_indices_tr_info); // For single op tests
    synTensor tril_indices = createTensor(1U, syn_type_int32, tril_indices_sizes, true, "tril_indices");
    UNUSED(tril_indices); // For single op tests

    synTensor tril_indices_fwd_in_vec[2] = {reshape_tril_output, tril_indices};


    // create tril_indices_output tensor
    const unsigned tril_indices_output_sizes[] = {128, 351};
    synTensor tril_indices_output = createTensor(2U, syn_type_bf16, tril_indices_output_sizes, false, "tril_indices_output");
    UNUSED(tril_indices_output); // For single op tests

    synTensor tril_indices_fwd_out_vec[1] = {tril_indices_output};


    status = synNodeCreate(graphHandle, tril_indices_fwd_in_vec, tril_indices_fwd_out_vec, 2, 1, (void *)&tril_indices_fwd_kernel_params, sizeof(tril_indices_fwd_kernel_params), "gather_fwd_bf16", "tril_indices_fwd", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for tril_indices_fwd failed!");

    /*************
     * concat_interact1_bot_l_4_relu_output_reshape node
     * inputs: [bot_l_4_relu_output(128, 1, 1, 32)(dtype=bf16)]
     * output: [concat_interact1_bot_l_4_relu_output_tensor_reshape(128, 32)(dtype=bf16)]
     *************/

    synTensor concat_interact1_bot_l_4_relu_output_reshape_in_vec[1] = {bot_l_4_relu_output};


    // create concat_interact1_bot_l_4_relu_output_tensor_reshape tensor
    const unsigned concat_interact1_bot_l_4_relu_output_tensor_reshape_sizes[] = {128, 32};
    synTensor concat_interact1_bot_l_4_relu_output_tensor_reshape = createTensor(2U, syn_type_bf16, concat_interact1_bot_l_4_relu_output_tensor_reshape_sizes, false, "concat_interact1_bot_l_4_relu_output_tensor_reshape");
    UNUSED(concat_interact1_bot_l_4_relu_output_tensor_reshape); // For single op tests

    synTensor concat_interact1_bot_l_4_relu_output_reshape_out_vec[1] = {concat_interact1_bot_l_4_relu_output_tensor_reshape};


    status = synNodeCreate(graphHandle, concat_interact1_bot_l_4_relu_output_reshape_in_vec, concat_interact1_bot_l_4_relu_output_reshape_out_vec, 1, 1, nullptr, 0, "reshape", "concat_interact1_bot_l_4_relu_output_reshape", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for concat_interact1_bot_l_4_relu_output_reshape failed!");

    /*************
     * concat_interact1 node
     * inputs: [concat_interact1_bot_l_4_relu_output_tensor_reshape(128, 32)(dtype=bf16), tril_indices_output(128, 351)(dtype=bf16)]
     * output: [concat_interact1_output(128, 383)(dtype=bf16)]
     *************/

    synTensor concat_interact1_in_vec[2] = {concat_interact1_bot_l_4_relu_output_tensor_reshape, tril_indices_output};


    // create concat_interact1_output tensor
    const unsigned concat_interact1_output_sizes[] = {128, 383};
    synTensor concat_interact1_output = createTensor(2U, syn_type_bf16, concat_interact1_output_sizes, false, "concat_interact1_output");
    UNUSED(concat_interact1_output); // For single op tests

    synTensor concat_interact1_out_vec[1] = {concat_interact1_output};


    status = synNodeCreate(graphHandle, concat_interact1_in_vec, concat_interact1_out_vec, 2, 1, nullptr, 0, "concat", "concat_interact1", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for concat_interact1 failed!");

    /*************
     * top_l_0_linear_concat_interact1_output_reshape node
     * inputs: [concat_interact1_output(128, 383)(dtype=bf16)]
     * output: [top_l_0_linear_concat_interact1_output_tensor_reshape(128, 1, 1, 383)(dtype=bf16)]
     *************/

    synTensor top_l_0_linear_concat_interact1_output_reshape_in_vec[1] = {concat_interact1_output};


    // create top_l_0_linear_concat_interact1_output_tensor_reshape tensor
    const unsigned top_l_0_linear_concat_interact1_output_tensor_reshape_sizes[] = {128, 1, 1, 383};
    synTensor top_l_0_linear_concat_interact1_output_tensor_reshape = createTensor(4U, syn_type_bf16, top_l_0_linear_concat_interact1_output_tensor_reshape_sizes, false, "top_l_0_linear_concat_interact1_output_tensor_reshape");
    UNUSED(top_l_0_linear_concat_interact1_output_tensor_reshape); // For single op tests

    synTensor top_l_0_linear_concat_interact1_output_reshape_out_vec[1] = {top_l_0_linear_concat_interact1_output_tensor_reshape};


    status = synNodeCreate(graphHandle, top_l_0_linear_concat_interact1_output_reshape_in_vec, top_l_0_linear_concat_interact1_output_reshape_out_vec, 1, 1, nullptr, 0, "reshape", "top_l_0_linear_concat_interact1_output_reshape", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_0_linear_concat_interact1_output_reshape failed!");

    /*************
     * top_l_0_linear node
     * inputs: [top_l_0_linear_concat_interact1_output_tensor_reshape(128, 1, 1, 383)(dtype=bf16), top_l_0_linear_weight(1, 1, 383, 1024)(dtype=bf16), top_l_0_linear_bias[1024](dtype=bf16)]
     * output: [top_l_0_linear_output(128, 1, 1, 1024)(dtype=bf16)]
     *************/
    synConvolutionParams top_l_0_linear_kernel_params;
    top_l_0_linear_kernel_params.dH = 1;
    top_l_0_linear_kernel_params.dW = 1;
    top_l_0_linear_kernel_params.kH = 1;
    top_l_0_linear_kernel_params.kW = 1;
    top_l_0_linear_kernel_params.padT = 0;
    top_l_0_linear_kernel_params.padB = 0;
    top_l_0_linear_kernel_params.padL = 0;
    top_l_0_linear_kernel_params.padR = 0;
    top_l_0_linear_kernel_params.dilH = 1;
    top_l_0_linear_kernel_params.dilW = 1;

    // create top_l_0_linear_weight tensor
    const unsigned top_l_0_linear_weight_sizes[] = {1, 1, 383, 1024};
    uint64_t top_l_0_linear_weight_dram;
    unsigned top_l_0_linear_weight_size = 1*1*383*1024;
    unsigned top_l_0_linear_weight_size_in_bytes = top_l_0_linear_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_0_linear_weight_size_in_bytes, &top_l_0_linear_weight_dram, "top_l_0_linear_weight");
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_weight dram malloc failed!");
    synLaunchTensorInfo top_l_0_linear_weight_tr_info = {"top_l_0_linear_weight", top_l_0_linear_weight_dram};
    UNUSED(top_l_0_linear_weight_tr_info); // For single op tests
    synTensor top_l_0_linear_weight = createTensor(4U, syn_type_bf16, top_l_0_linear_weight_sizes, true, "top_l_0_linear_weight");
    UNUSED(top_l_0_linear_weight); // For single op tests

    // create top_l_0_linear_bias tensor
    const unsigned top_l_0_linear_bias_sizes[] = {1024,};
    uint64_t top_l_0_linear_bias_dram;
    unsigned top_l_0_linear_bias_size = 1024;
    unsigned top_l_0_linear_bias_size_in_bytes = top_l_0_linear_bias_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_0_linear_bias_size_in_bytes, &top_l_0_linear_bias_dram, "top_l_0_linear_bias");
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_bias dram malloc failed!");
    synLaunchTensorInfo top_l_0_linear_bias_tr_info = {"top_l_0_linear_bias", top_l_0_linear_bias_dram};
    UNUSED(top_l_0_linear_bias_tr_info); // For single op tests
    synTensor top_l_0_linear_bias = createTensor(1U, syn_type_bf16, top_l_0_linear_bias_sizes, true, "top_l_0_linear_bias");
    UNUSED(top_l_0_linear_bias); // For single op tests

    synTensor top_l_0_linear_in_vec[4] = {top_l_0_linear_concat_interact1_output_tensor_reshape, top_l_0_linear_weight, top_l_0_linear_bias, nullptr};


    // create top_l_0_linear_output tensor
    const unsigned top_l_0_linear_output_sizes[] = {128, 1, 1, 1024};
    synTensor top_l_0_linear_output = createTensor(4U, syn_type_bf16, top_l_0_linear_output_sizes, false, "top_l_0_linear_output");
    UNUSED(top_l_0_linear_output); // For single op tests

    synTensor top_l_0_linear_out_vec[1] = {top_l_0_linear_output};


    status = synNodeCreate(graphHandle, top_l_0_linear_in_vec, top_l_0_linear_out_vec, 4, 1, (void *)&top_l_0_linear_kernel_params, sizeof(top_l_0_linear_kernel_params), "spatial_convolution", "top_l_0_linear", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_0_linear failed!");

    /*************
     * top_l_0_relu node
     * inputs: [top_l_0_linear_output(128, 1, 1, 1024)(dtype=bf16)]
     * output: [top_l_0_relu_output(128, 1, 1, 1024)(dtype=bf16)]
     *************/

    synTensor top_l_0_relu_in_vec[1] = {top_l_0_linear_output};


    // create top_l_0_relu_output tensor
    const unsigned top_l_0_relu_output_sizes[] = {128, 1, 1, 1024};
    synTensor top_l_0_relu_output = createTensor(4U, syn_type_bf16, top_l_0_relu_output_sizes, false, "top_l_0_relu_output");
    UNUSED(top_l_0_relu_output); // For single op tests

    synTensor top_l_0_relu_out_vec[1] = {top_l_0_relu_output};


    status = synNodeCreate(graphHandle, top_l_0_relu_in_vec, top_l_0_relu_out_vec, 1, 1, nullptr, 0, "relu_fwd_bf16", "top_l_0_relu", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_0_relu failed!");

    /*************
     * top_l_2_linear node
     * inputs: [top_l_0_relu_output(128, 1, 1, 1024)(dtype=bf16), top_l_2_linear_weight(1, 1, 1024, 1024)(dtype=bf16), top_l_2_linear_bias[1024](dtype=bf16)]
     * output: [top_l_2_linear_output(128, 1, 1, 1024)(dtype=bf16)]
     *************/
    synConvolutionParams top_l_2_linear_kernel_params;
    top_l_2_linear_kernel_params.dH = 1;
    top_l_2_linear_kernel_params.dW = 1;
    top_l_2_linear_kernel_params.kH = 1;
    top_l_2_linear_kernel_params.kW = 1;
    top_l_2_linear_kernel_params.padT = 0;
    top_l_2_linear_kernel_params.padB = 0;
    top_l_2_linear_kernel_params.padL = 0;
    top_l_2_linear_kernel_params.padR = 0;
    top_l_2_linear_kernel_params.dilH = 1;
    top_l_2_linear_kernel_params.dilW = 1;

    // create top_l_2_linear_weight tensor
    const unsigned top_l_2_linear_weight_sizes[] = {1, 1, 1024, 1024};
    uint64_t top_l_2_linear_weight_dram;
    unsigned top_l_2_linear_weight_size = 1*1*1024*1024;
    unsigned top_l_2_linear_weight_size_in_bytes = top_l_2_linear_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_2_linear_weight_size_in_bytes, &top_l_2_linear_weight_dram, "top_l_2_linear_weight");
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_weight dram malloc failed!");
    synLaunchTensorInfo top_l_2_linear_weight_tr_info = {"top_l_2_linear_weight", top_l_2_linear_weight_dram};
    UNUSED(top_l_2_linear_weight_tr_info); // For single op tests
    synTensor top_l_2_linear_weight = createTensor(4U, syn_type_bf16, top_l_2_linear_weight_sizes, true, "top_l_2_linear_weight");
    UNUSED(top_l_2_linear_weight); // For single op tests

    // create top_l_2_linear_bias tensor
    const unsigned top_l_2_linear_bias_sizes[] = {1024,};
    uint64_t top_l_2_linear_bias_dram;
    unsigned top_l_2_linear_bias_size = 1024;
    unsigned top_l_2_linear_bias_size_in_bytes = top_l_2_linear_bias_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_2_linear_bias_size_in_bytes, &top_l_2_linear_bias_dram, "top_l_2_linear_bias");
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_bias dram malloc failed!");
    synLaunchTensorInfo top_l_2_linear_bias_tr_info = {"top_l_2_linear_bias", top_l_2_linear_bias_dram};
    UNUSED(top_l_2_linear_bias_tr_info); // For single op tests
    synTensor top_l_2_linear_bias = createTensor(1U, syn_type_bf16, top_l_2_linear_bias_sizes, true, "top_l_2_linear_bias");
    UNUSED(top_l_2_linear_bias); // For single op tests

    synTensor top_l_2_linear_in_vec[4] = {top_l_0_relu_output, top_l_2_linear_weight, top_l_2_linear_bias, nullptr};


    // create top_l_2_linear_output tensor
    const unsigned top_l_2_linear_output_sizes[] = {128, 1, 1, 1024};
    synTensor top_l_2_linear_output = createTensor(4U, syn_type_bf16, top_l_2_linear_output_sizes, false, "top_l_2_linear_output");
    UNUSED(top_l_2_linear_output); // For single op tests

    synTensor top_l_2_linear_out_vec[1] = {top_l_2_linear_output};


    status = synNodeCreate(graphHandle, top_l_2_linear_in_vec, top_l_2_linear_out_vec, 4, 1, (void *)&top_l_2_linear_kernel_params, sizeof(top_l_2_linear_kernel_params), "spatial_convolution", "top_l_2_linear", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_2_linear failed!");

    /*************
     * top_l_2_relu node
     * inputs: [top_l_2_linear_output(128, 1, 1, 1024)(dtype=bf16)]
     * output: [top_l_2_relu_output(128, 1, 1, 1024)(dtype=bf16)]
     *************/

    synTensor top_l_2_relu_in_vec[1] = {top_l_2_linear_output};


    // create top_l_2_relu_output tensor
    const unsigned top_l_2_relu_output_sizes[] = {128, 1, 1, 1024};
    synTensor top_l_2_relu_output = createTensor(4U, syn_type_bf16, top_l_2_relu_output_sizes, false, "top_l_2_relu_output");
    UNUSED(top_l_2_relu_output); // For single op tests

    synTensor top_l_2_relu_out_vec[1] = {top_l_2_relu_output};


    status = synNodeCreate(graphHandle, top_l_2_relu_in_vec, top_l_2_relu_out_vec, 1, 1, nullptr, 0, "relu_fwd_bf16", "top_l_2_relu", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_2_relu failed!");

    /*************
     * top_l_4_linear node
     * inputs: [top_l_2_relu_output(128, 1, 1, 1024)(dtype=bf16), top_l_4_linear_weight(1, 1, 1024, 1024)(dtype=bf16), top_l_4_linear_bias[1024](dtype=bf16)]
     * output: [top_l_4_linear_output(128, 1, 1, 1024)(dtype=bf16)]
     *************/
    synConvolutionParams top_l_4_linear_kernel_params;
    top_l_4_linear_kernel_params.dH = 1;
    top_l_4_linear_kernel_params.dW = 1;
    top_l_4_linear_kernel_params.kH = 1;
    top_l_4_linear_kernel_params.kW = 1;
    top_l_4_linear_kernel_params.padT = 0;
    top_l_4_linear_kernel_params.padB = 0;
    top_l_4_linear_kernel_params.padL = 0;
    top_l_4_linear_kernel_params.padR = 0;
    top_l_4_linear_kernel_params.dilH = 1;
    top_l_4_linear_kernel_params.dilW = 1;

    // create top_l_4_linear_weight tensor
    const unsigned top_l_4_linear_weight_sizes[] = {1, 1, 1024, 1024};
    uint64_t top_l_4_linear_weight_dram;
    unsigned top_l_4_linear_weight_size = 1*1*1024*1024;
    unsigned top_l_4_linear_weight_size_in_bytes = top_l_4_linear_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_4_linear_weight_size_in_bytes, &top_l_4_linear_weight_dram, "top_l_4_linear_weight");
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_weight dram malloc failed!");
    synLaunchTensorInfo top_l_4_linear_weight_tr_info = {"top_l_4_linear_weight", top_l_4_linear_weight_dram};
    UNUSED(top_l_4_linear_weight_tr_info); // For single op tests
    synTensor top_l_4_linear_weight = createTensor(4U, syn_type_bf16, top_l_4_linear_weight_sizes, true, "top_l_4_linear_weight");
    UNUSED(top_l_4_linear_weight); // For single op tests

    // create top_l_4_linear_bias tensor
    const unsigned top_l_4_linear_bias_sizes[] = {1024,};
    uint64_t top_l_4_linear_bias_dram;
    unsigned top_l_4_linear_bias_size = 1024;
    unsigned top_l_4_linear_bias_size_in_bytes = top_l_4_linear_bias_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_4_linear_bias_size_in_bytes, &top_l_4_linear_bias_dram, "top_l_4_linear_bias");
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_bias dram malloc failed!");
    synLaunchTensorInfo top_l_4_linear_bias_tr_info = {"top_l_4_linear_bias", top_l_4_linear_bias_dram};
    UNUSED(top_l_4_linear_bias_tr_info); // For single op tests
    synTensor top_l_4_linear_bias = createTensor(1U, syn_type_bf16, top_l_4_linear_bias_sizes, true, "top_l_4_linear_bias");
    UNUSED(top_l_4_linear_bias); // For single op tests

    synTensor top_l_4_linear_in_vec[4] = {top_l_2_relu_output, top_l_4_linear_weight, top_l_4_linear_bias, nullptr};


    // create top_l_4_linear_output tensor
    const unsigned top_l_4_linear_output_sizes[] = {128, 1, 1, 1024};
    synTensor top_l_4_linear_output = createTensor(4U, syn_type_bf16, top_l_4_linear_output_sizes, false, "top_l_4_linear_output");
    UNUSED(top_l_4_linear_output); // For single op tests

    synTensor top_l_4_linear_out_vec[1] = {top_l_4_linear_output};


    status = synNodeCreate(graphHandle, top_l_4_linear_in_vec, top_l_4_linear_out_vec, 4, 1, (void *)&top_l_4_linear_kernel_params, sizeof(top_l_4_linear_kernel_params), "spatial_convolution", "top_l_4_linear", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_4_linear failed!");

    /*************
     * top_l_4_relu node
     * inputs: [top_l_4_linear_output(128, 1, 1, 1024)(dtype=bf16)]
     * output: [top_l_4_relu_output(128, 1, 1, 1024)(dtype=bf16)]
     *************/

    synTensor top_l_4_relu_in_vec[1] = {top_l_4_linear_output};


    // create top_l_4_relu_output tensor
    const unsigned top_l_4_relu_output_sizes[] = {128, 1, 1, 1024};
    synTensor top_l_4_relu_output = createTensor(4U, syn_type_bf16, top_l_4_relu_output_sizes, false, "top_l_4_relu_output");
    UNUSED(top_l_4_relu_output); // For single op tests

    synTensor top_l_4_relu_out_vec[1] = {top_l_4_relu_output};


    status = synNodeCreate(graphHandle, top_l_4_relu_in_vec, top_l_4_relu_out_vec, 1, 1, nullptr, 0, "relu_fwd_bf16", "top_l_4_relu", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_4_relu failed!");

    /*************
     * top_l_6_linear node
     * inputs: [top_l_4_relu_output(128, 1, 1, 1024)(dtype=bf16), top_l_6_linear_weight(1, 1, 1024, 1024)(dtype=bf16), top_l_6_linear_bias[1024](dtype=bf16)]
     * output: [top_l_6_linear_output(128, 1, 1, 1024)(dtype=bf16)]
     *************/
    synConvolutionParams top_l_6_linear_kernel_params;
    top_l_6_linear_kernel_params.dH = 1;
    top_l_6_linear_kernel_params.dW = 1;
    top_l_6_linear_kernel_params.kH = 1;
    top_l_6_linear_kernel_params.kW = 1;
    top_l_6_linear_kernel_params.padT = 0;
    top_l_6_linear_kernel_params.padB = 0;
    top_l_6_linear_kernel_params.padL = 0;
    top_l_6_linear_kernel_params.padR = 0;
    top_l_6_linear_kernel_params.dilH = 1;
    top_l_6_linear_kernel_params.dilW = 1;

    // create top_l_6_linear_weight tensor
    const unsigned top_l_6_linear_weight_sizes[] = {1, 1, 1024, 1024};
    uint64_t top_l_6_linear_weight_dram;
    unsigned top_l_6_linear_weight_size = 1*1*1024*1024;
    unsigned top_l_6_linear_weight_size_in_bytes = top_l_6_linear_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_6_linear_weight_size_in_bytes, &top_l_6_linear_weight_dram, "top_l_6_linear_weight");
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_weight dram malloc failed!");
    synLaunchTensorInfo top_l_6_linear_weight_tr_info = {"top_l_6_linear_weight", top_l_6_linear_weight_dram};
    UNUSED(top_l_6_linear_weight_tr_info); // For single op tests
    synTensor top_l_6_linear_weight = createTensor(4U, syn_type_bf16, top_l_6_linear_weight_sizes, true, "top_l_6_linear_weight");
    UNUSED(top_l_6_linear_weight); // For single op tests

    // create top_l_6_linear_bias tensor
    const unsigned top_l_6_linear_bias_sizes[] = {1024,};
    uint64_t top_l_6_linear_bias_dram;
    unsigned top_l_6_linear_bias_size = 1024;
    unsigned top_l_6_linear_bias_size_in_bytes = top_l_6_linear_bias_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_6_linear_bias_size_in_bytes, &top_l_6_linear_bias_dram, "top_l_6_linear_bias");
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_bias dram malloc failed!");
    synLaunchTensorInfo top_l_6_linear_bias_tr_info = {"top_l_6_linear_bias", top_l_6_linear_bias_dram};
    UNUSED(top_l_6_linear_bias_tr_info); // For single op tests
    synTensor top_l_6_linear_bias = createTensor(1U, syn_type_bf16, top_l_6_linear_bias_sizes, true, "top_l_6_linear_bias");
    UNUSED(top_l_6_linear_bias); // For single op tests

    synTensor top_l_6_linear_in_vec[4] = {top_l_4_relu_output, top_l_6_linear_weight, top_l_6_linear_bias, nullptr};


    // create top_l_6_linear_output tensor
    const unsigned top_l_6_linear_output_sizes[] = {128, 1, 1, 1024};
    synTensor top_l_6_linear_output = createTensor(4U, syn_type_bf16, top_l_6_linear_output_sizes, false, "top_l_6_linear_output");
    UNUSED(top_l_6_linear_output); // For single op tests

    synTensor top_l_6_linear_out_vec[1] = {top_l_6_linear_output};


    status = synNodeCreate(graphHandle, top_l_6_linear_in_vec, top_l_6_linear_out_vec, 4, 1, (void *)&top_l_6_linear_kernel_params, sizeof(top_l_6_linear_kernel_params), "spatial_convolution", "top_l_6_linear", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_6_linear failed!");

    /*************
     * top_l_6_relu node
     * inputs: [top_l_6_linear_output(128, 1, 1, 1024)(dtype=bf16)]
     * output: [top_l_6_relu_output(128, 1, 1, 1024)(dtype=bf16)]
     *************/

    synTensor top_l_6_relu_in_vec[1] = {top_l_6_linear_output};


    // create top_l_6_relu_output tensor
    const unsigned top_l_6_relu_output_sizes[] = {128, 1, 1, 1024};
    synTensor top_l_6_relu_output = createTensor(4U, syn_type_bf16, top_l_6_relu_output_sizes, false, "top_l_6_relu_output");
    UNUSED(top_l_6_relu_output); // For single op tests

    synTensor top_l_6_relu_out_vec[1] = {top_l_6_relu_output};


    status = synNodeCreate(graphHandle, top_l_6_relu_in_vec, top_l_6_relu_out_vec, 1, 1, nullptr, 0, "relu_fwd_bf16", "top_l_6_relu", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_6_relu failed!");

    /*************
     * top_l_8_linear node
     * inputs: [top_l_6_relu_output(128, 1, 1, 1024)(dtype=bf16), top_l_8_linear_weight(1, 1, 1024, 1024)(dtype=bf16), top_l_8_linear_bias[1024](dtype=bf16)]
     * output: [top_l_8_linear_output(128, 1, 1, 1024)(dtype=bf16)]
     *************/
    synConvolutionParams top_l_8_linear_kernel_params;
    top_l_8_linear_kernel_params.dH = 1;
    top_l_8_linear_kernel_params.dW = 1;
    top_l_8_linear_kernel_params.kH = 1;
    top_l_8_linear_kernel_params.kW = 1;
    top_l_8_linear_kernel_params.padT = 0;
    top_l_8_linear_kernel_params.padB = 0;
    top_l_8_linear_kernel_params.padL = 0;
    top_l_8_linear_kernel_params.padR = 0;
    top_l_8_linear_kernel_params.dilH = 1;
    top_l_8_linear_kernel_params.dilW = 1;

    // create top_l_8_linear_weight tensor
    const unsigned top_l_8_linear_weight_sizes[] = {1, 1, 1024, 1024};
    uint64_t top_l_8_linear_weight_dram;
    unsigned top_l_8_linear_weight_size = 1*1*1024*1024;
    unsigned top_l_8_linear_weight_size_in_bytes = top_l_8_linear_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_8_linear_weight_size_in_bytes, &top_l_8_linear_weight_dram, "top_l_8_linear_weight");
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_weight dram malloc failed!");
    synLaunchTensorInfo top_l_8_linear_weight_tr_info = {"top_l_8_linear_weight", top_l_8_linear_weight_dram};
    UNUSED(top_l_8_linear_weight_tr_info); // For single op tests
    synTensor top_l_8_linear_weight = createTensor(4U, syn_type_bf16, top_l_8_linear_weight_sizes, true, "top_l_8_linear_weight");
    UNUSED(top_l_8_linear_weight); // For single op tests

    // create top_l_8_linear_bias tensor
    const unsigned top_l_8_linear_bias_sizes[] = {1024,};
    uint64_t top_l_8_linear_bias_dram;
    unsigned top_l_8_linear_bias_size = 1024;
    unsigned top_l_8_linear_bias_size_in_bytes = top_l_8_linear_bias_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_8_linear_bias_size_in_bytes, &top_l_8_linear_bias_dram, "top_l_8_linear_bias");
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_bias dram malloc failed!");
    synLaunchTensorInfo top_l_8_linear_bias_tr_info = {"top_l_8_linear_bias", top_l_8_linear_bias_dram};
    UNUSED(top_l_8_linear_bias_tr_info); // For single op tests
    synTensor top_l_8_linear_bias = createTensor(1U, syn_type_bf16, top_l_8_linear_bias_sizes, true, "top_l_8_linear_bias");
    UNUSED(top_l_8_linear_bias); // For single op tests

    synTensor top_l_8_linear_in_vec[4] = {top_l_6_relu_output, top_l_8_linear_weight, top_l_8_linear_bias, nullptr};


    // create top_l_8_linear_output tensor
    const unsigned top_l_8_linear_output_sizes[] = {128, 1, 1, 1024};
    synTensor top_l_8_linear_output = createTensor(4U, syn_type_bf16, top_l_8_linear_output_sizes, false, "top_l_8_linear_output");
    UNUSED(top_l_8_linear_output); // For single op tests

    synTensor top_l_8_linear_out_vec[1] = {top_l_8_linear_output};


    status = synNodeCreate(graphHandle, top_l_8_linear_in_vec, top_l_8_linear_out_vec, 4, 1, (void *)&top_l_8_linear_kernel_params, sizeof(top_l_8_linear_kernel_params), "spatial_convolution", "top_l_8_linear", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_8_linear failed!");

    /*************
     * top_l_8_relu node
     * inputs: [top_l_8_linear_output(128, 1, 1, 1024)(dtype=bf16)]
     * output: [top_l_8_relu_output(128, 1, 1, 1024)(dtype=bf16)]
     *************/

    synTensor top_l_8_relu_in_vec[1] = {top_l_8_linear_output};


    // create top_l_8_relu_output tensor
    const unsigned top_l_8_relu_output_sizes[] = {128, 1, 1, 1024};
    synTensor top_l_8_relu_output = createTensor(4U, syn_type_bf16, top_l_8_relu_output_sizes, false, "top_l_8_relu_output");
    UNUSED(top_l_8_relu_output); // For single op tests

    synTensor top_l_8_relu_out_vec[1] = {top_l_8_relu_output};


    status = synNodeCreate(graphHandle, top_l_8_relu_in_vec, top_l_8_relu_out_vec, 1, 1, nullptr, 0, "relu_fwd_bf16", "top_l_8_relu", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_8_relu failed!");

    /*************
     * top_l_10_linear node
     * inputs: [top_l_8_relu_output(128, 1, 1, 1024)(dtype=bf16), top_l_10_linear_weight(1, 1, 1024, 1)(dtype=bf16), top_l_10_linear_bias[1](dtype=bf16)]
     * output: [top_l_10_linear_output(128, 1, 1, 1)(dtype=bf16)]
     *************/
    synConvolutionParams top_l_10_linear_kernel_params;
    top_l_10_linear_kernel_params.dH = 1;
    top_l_10_linear_kernel_params.dW = 1;
    top_l_10_linear_kernel_params.kH = 1;
    top_l_10_linear_kernel_params.kW = 1;
    top_l_10_linear_kernel_params.padT = 0;
    top_l_10_linear_kernel_params.padB = 0;
    top_l_10_linear_kernel_params.padL = 0;
    top_l_10_linear_kernel_params.padR = 0;
    top_l_10_linear_kernel_params.dilH = 1;
    top_l_10_linear_kernel_params.dilW = 1;

    // create top_l_10_linear_weight tensor
    const unsigned top_l_10_linear_weight_sizes[] = {1, 1, 1024, 1};
    uint64_t top_l_10_linear_weight_dram;
    unsigned top_l_10_linear_weight_size = 1*1*1024*1;
    unsigned top_l_10_linear_weight_size_in_bytes = top_l_10_linear_weight_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_10_linear_weight_size_in_bytes, &top_l_10_linear_weight_dram, "top_l_10_linear_weight");
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_weight dram malloc failed!");
    synLaunchTensorInfo top_l_10_linear_weight_tr_info = {"top_l_10_linear_weight", top_l_10_linear_weight_dram};
    UNUSED(top_l_10_linear_weight_tr_info); // For single op tests
    synTensor top_l_10_linear_weight = createTensor(4U, syn_type_bf16, top_l_10_linear_weight_sizes, true, "top_l_10_linear_weight");
    UNUSED(top_l_10_linear_weight); // For single op tests

    // create top_l_10_linear_bias tensor
    const unsigned top_l_10_linear_bias_sizes[] = {1,};
    uint64_t top_l_10_linear_bias_dram;
    unsigned top_l_10_linear_bias_size = 1;
    unsigned top_l_10_linear_bias_size_in_bytes = top_l_10_linear_bias_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_10_linear_bias_size_in_bytes, &top_l_10_linear_bias_dram, "top_l_10_linear_bias");
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_bias dram malloc failed!");
    synLaunchTensorInfo top_l_10_linear_bias_tr_info = {"top_l_10_linear_bias", top_l_10_linear_bias_dram};
    UNUSED(top_l_10_linear_bias_tr_info); // For single op tests
    synTensor top_l_10_linear_bias = createTensor(1U, syn_type_bf16, top_l_10_linear_bias_sizes, true, "top_l_10_linear_bias");
    UNUSED(top_l_10_linear_bias); // For single op tests

    synTensor top_l_10_linear_in_vec[4] = {top_l_8_relu_output, top_l_10_linear_weight, top_l_10_linear_bias, nullptr};


    // create top_l_10_linear_output tensor
    const unsigned top_l_10_linear_output_sizes[] = {128, 1, 1, 1};
    uint64_t top_l_10_linear_output_dram;
    unsigned top_l_10_linear_output_size = 128*1*1*1;
    unsigned top_l_10_linear_output_size_in_bytes = top_l_10_linear_output_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_10_linear_output_size_in_bytes, &top_l_10_linear_output_dram, "top_l_10_linear_output");
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_output dram malloc failed!");
    synLaunchTensorInfo top_l_10_linear_output_tr_info = {"top_l_10_linear_output", top_l_10_linear_output_dram};
    UNUSED(top_l_10_linear_output_tr_info); // For single op tests
    synTensor top_l_10_linear_output = createTensor(4U, syn_type_bf16, top_l_10_linear_output_sizes, true, "top_l_10_linear_output");
    UNUSED(top_l_10_linear_output); // For single op tests

    synTensor top_l_10_linear_out_vec[1] = {top_l_10_linear_output};


    status = synNodeCreate(graphHandle, top_l_10_linear_in_vec, top_l_10_linear_out_vec, 4, 1, (void *)&top_l_10_linear_kernel_params, sizeof(top_l_10_linear_kernel_params), "spatial_convolution", "top_l_10_linear", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_10_linear failed!");

    /*************
     * binary_cross_entropy_loss_fwd_top_l_10_linear_output_reshape node
     * inputs: [top_l_10_linear_output(128, 1, 1, 1)(dtype=bf16)]
     * output: [binary_cross_entropy_loss_fwd_top_l_10_linear_output_tensor_reshape(1, 128)(dtype=bf16)]
     *************/

    synTensor binary_cross_entropy_loss_fwd_top_l_10_linear_output_reshape_in_vec[1] = {top_l_10_linear_output};


    // create binary_cross_entropy_loss_fwd_top_l_10_linear_output_tensor_reshape tensor
    const unsigned binary_cross_entropy_loss_fwd_top_l_10_linear_output_tensor_reshape_sizes[] = {1, 128};
    synTensor binary_cross_entropy_loss_fwd_top_l_10_linear_output_tensor_reshape = createTensor(2U, syn_type_bf16, binary_cross_entropy_loss_fwd_top_l_10_linear_output_tensor_reshape_sizes, false, "binary_cross_entropy_loss_fwd_top_l_10_linear_output_tensor_reshape");
    UNUSED(binary_cross_entropy_loss_fwd_top_l_10_linear_output_tensor_reshape); // For single op tests

    synTensor binary_cross_entropy_loss_fwd_top_l_10_linear_output_reshape_out_vec[1] = {binary_cross_entropy_loss_fwd_top_l_10_linear_output_tensor_reshape};


    status = synNodeCreate(graphHandle, binary_cross_entropy_loss_fwd_top_l_10_linear_output_reshape_in_vec, binary_cross_entropy_loss_fwd_top_l_10_linear_output_reshape_out_vec, 1, 1, nullptr, 0, "reshape", "binary_cross_entropy_loss_fwd_top_l_10_linear_output_reshape", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for binary_cross_entropy_loss_fwd_top_l_10_linear_output_reshape failed!");

    /*************
     * binary_cross_entropy_loss_fwd node
     * inputs: [binary_cross_entropy_loss_fwd_top_l_10_linear_output_tensor_reshape(1, 128)(dtype=bf16), target[1, 128](dtype=bf16)]
     * output: [binary_cross_entropy_loss_output(1,)(dtype=bf16), binary_cross_entropy_loss_saved_sigmoid(1, 128)(dtype=bf16)]
     *************/
    ns_BinaryCrossEntropy::Params binary_cross_entropy_loss_fwd_kernel_params;
    binary_cross_entropy_loss_fwd_kernel_params.isWeightsUsed = false;
    binary_cross_entropy_loss_fwd_kernel_params.mode = CROSS_ENTROPY_MODE_MEAN;

    // create target tensor
    const unsigned target_sizes[] = {1, 128};
    uint64_t target_dram;
    unsigned target_size = 1*128;
    unsigned target_size_in_bytes = target_size * sizeof(bfloat16) ;
    status = hbmAlloc(target_size_in_bytes, &target_dram, "target");
    ASSERT_TRUE(status == synSuccess && "target dram malloc failed!");
    synLaunchTensorInfo target_tr_info = {"target", target_dram};
    UNUSED(target_tr_info); // For single op tests
    synTensor target = createTensor(2U, syn_type_bf16, target_sizes, true, "target");
    UNUSED(target); // For single op tests

    synTensor binary_cross_entropy_loss_fwd_in_vec[2] = {binary_cross_entropy_loss_fwd_top_l_10_linear_output_tensor_reshape, target};


    // create binary_cross_entropy_loss_output tensor
    const unsigned binary_cross_entropy_loss_output_sizes[] = {1,};
    uint64_t binary_cross_entropy_loss_output_dram;
    unsigned binary_cross_entropy_loss_output_size = 1;
    unsigned binary_cross_entropy_loss_output_size_in_bytes = binary_cross_entropy_loss_output_size * sizeof(bfloat16) ;
    status = hbmAlloc(binary_cross_entropy_loss_output_size_in_bytes, &binary_cross_entropy_loss_output_dram, "binary_cross_entropy_loss_output");
    ASSERT_TRUE(status == synSuccess && "binary_cross_entropy_loss_output dram malloc failed!");
    synLaunchTensorInfo binary_cross_entropy_loss_output_tr_info = {"binary_cross_entropy_loss_output",
                                                                    binary_cross_entropy_loss_output_dram};
    UNUSED(binary_cross_entropy_loss_output_tr_info); // For single op tests
    synTensor binary_cross_entropy_loss_output = createTensor(1U, syn_type_bf16, binary_cross_entropy_loss_output_sizes, true, "binary_cross_entropy_loss_output");
    UNUSED(binary_cross_entropy_loss_output); // For single op tests

    // create binary_cross_entropy_loss_saved_sigmoid tensor
    const unsigned binary_cross_entropy_loss_saved_sigmoid_sizes[] = {1, 128};
    uint64_t binary_cross_entropy_loss_saved_sigmoid_dram;
    unsigned binary_cross_entropy_loss_saved_sigmoid_size = 1*128;
    unsigned binary_cross_entropy_loss_saved_sigmoid_size_in_bytes = binary_cross_entropy_loss_saved_sigmoid_size * sizeof(bfloat16) ;
    status = hbmAlloc(binary_cross_entropy_loss_saved_sigmoid_size_in_bytes, &binary_cross_entropy_loss_saved_sigmoid_dram, "binary_cross_entropy_loss_saved_sigmoid");
    ASSERT_TRUE(status == synSuccess && "binary_cross_entropy_loss_saved_sigmoid dram malloc failed!");
    synLaunchTensorInfo binary_cross_entropy_loss_saved_sigmoid_tr_info = {
        "binary_cross_entropy_loss_saved_sigmoid",
        binary_cross_entropy_loss_saved_sigmoid_dram};
    UNUSED(binary_cross_entropy_loss_saved_sigmoid_tr_info); // For single op tests
    synTensor binary_cross_entropy_loss_saved_sigmoid = createTensor(2U, syn_type_bf16, binary_cross_entropy_loss_saved_sigmoid_sizes, true, "binary_cross_entropy_loss_saved_sigmoid");
    UNUSED(binary_cross_entropy_loss_saved_sigmoid); // For single op tests

    synTensor binary_cross_entropy_loss_fwd_out_vec[2] = {binary_cross_entropy_loss_output, binary_cross_entropy_loss_saved_sigmoid};


    status = synNodeCreate(graphHandle, binary_cross_entropy_loss_fwd_in_vec, binary_cross_entropy_loss_fwd_out_vec, 2, 2, (void *)&binary_cross_entropy_loss_fwd_kernel_params, sizeof(binary_cross_entropy_loss_fwd_kernel_params), "binary_cross_entropy_fwd_bf16", "binary_cross_entropy_loss_fwd", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for binary_cross_entropy_loss_fwd failed!");

    /*************
     * binary_cross_entropy_loss_bwd_top_l_10_linear_output_reshape node
     * inputs: [top_l_10_linear_output(128, 1, 1, 1)(dtype=bf16)]
     * output: [binary_cross_entropy_loss_bwd_top_l_10_linear_output_tensor_reshape(1, 128)(dtype=bf16)]
     *************/

    synTensor binary_cross_entropy_loss_bwd_top_l_10_linear_output_reshape_in_vec[1] = {top_l_10_linear_output};


    // create binary_cross_entropy_loss_bwd_top_l_10_linear_output_tensor_reshape tensor
    const unsigned binary_cross_entropy_loss_bwd_top_l_10_linear_output_tensor_reshape_sizes[] = {1, 128};
    synTensor binary_cross_entropy_loss_bwd_top_l_10_linear_output_tensor_reshape = createTensor(2U, syn_type_bf16, binary_cross_entropy_loss_bwd_top_l_10_linear_output_tensor_reshape_sizes, false, "binary_cross_entropy_loss_bwd_top_l_10_linear_output_tensor_reshape");
    UNUSED(binary_cross_entropy_loss_bwd_top_l_10_linear_output_tensor_reshape); // For single op tests

    synTensor binary_cross_entropy_loss_bwd_top_l_10_linear_output_reshape_out_vec[1] = {binary_cross_entropy_loss_bwd_top_l_10_linear_output_tensor_reshape};


    status = synNodeCreate(graphHandle, binary_cross_entropy_loss_bwd_top_l_10_linear_output_reshape_in_vec, binary_cross_entropy_loss_bwd_top_l_10_linear_output_reshape_out_vec, 1, 1, nullptr, 0, "reshape", "binary_cross_entropy_loss_bwd_top_l_10_linear_output_reshape", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for binary_cross_entropy_loss_bwd_top_l_10_linear_output_reshape failed!");

    /*************
     * binary_cross_entropy_loss_bwd node
     * inputs: [binary_cross_entropy_loss_bwd_top_l_10_linear_output_tensor_reshape(1, 128)(dtype=bf16), target[1, 128](dtype=bf16)]
     * output: [binary_cross_entropy_loss_grad_input(1, 128)(dtype=bf16)]
     *************/
    ns_BinaryCrossEntropy::Params binary_cross_entropy_loss_bwd_kernel_params;
    binary_cross_entropy_loss_bwd_kernel_params.isWeightsUsed = false;
    binary_cross_entropy_loss_bwd_kernel_params.mode = CROSS_ENTROPY_MODE_MEAN;

    synTensor binary_cross_entropy_loss_bwd_in_vec[2] = {binary_cross_entropy_loss_bwd_top_l_10_linear_output_tensor_reshape, target};


    // create binary_cross_entropy_loss_grad_input tensor
    const unsigned binary_cross_entropy_loss_grad_input_sizes[] = {1, 128};
    synTensor binary_cross_entropy_loss_grad_input = createTensor(2U, syn_type_bf16, binary_cross_entropy_loss_grad_input_sizes, false, "binary_cross_entropy_loss_grad_input");
    UNUSED(binary_cross_entropy_loss_grad_input); // For single op tests

    synTensor binary_cross_entropy_loss_bwd_out_vec[1] = {binary_cross_entropy_loss_grad_input};


    status = synNodeCreate(graphHandle, binary_cross_entropy_loss_bwd_in_vec, binary_cross_entropy_loss_bwd_out_vec, 2, 1, (void *)&binary_cross_entropy_loss_bwd_kernel_params, sizeof(binary_cross_entropy_loss_bwd_kernel_params), "binary_cross_entropy_bwd_bf16", "binary_cross_entropy_loss_bwd", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for binary_cross_entropy_loss_bwd failed!");

    /*************
     * top_l_10_linear_dedx_binary_cross_entropy_loss_grad_input_reshape node
     * inputs: [binary_cross_entropy_loss_grad_input(1, 128)(dtype=bf16)]
     * output: [top_l_10_linear_dedx_binary_cross_entropy_loss_grad_input_tensor_reshape(128, 1, 1, 1)(dtype=bf16)]
     *************/

    synTensor top_l_10_linear_dedx_binary_cross_entropy_loss_grad_input_reshape_in_vec[1] = {binary_cross_entropy_loss_grad_input};


    // create top_l_10_linear_dedx_binary_cross_entropy_loss_grad_input_tensor_reshape tensor
    const unsigned top_l_10_linear_dedx_binary_cross_entropy_loss_grad_input_tensor_reshape_sizes[] = {128, 1, 1, 1};
    synTensor top_l_10_linear_dedx_binary_cross_entropy_loss_grad_input_tensor_reshape = createTensor(4U, syn_type_bf16, top_l_10_linear_dedx_binary_cross_entropy_loss_grad_input_tensor_reshape_sizes, false, "top_l_10_linear_dedx_binary_cross_entropy_loss_grad_input_tensor_reshape");
    UNUSED(top_l_10_linear_dedx_binary_cross_entropy_loss_grad_input_tensor_reshape); // For single op tests

    synTensor top_l_10_linear_dedx_binary_cross_entropy_loss_grad_input_reshape_out_vec[1] = {top_l_10_linear_dedx_binary_cross_entropy_loss_grad_input_tensor_reshape};


    status = synNodeCreate(graphHandle, top_l_10_linear_dedx_binary_cross_entropy_loss_grad_input_reshape_in_vec, top_l_10_linear_dedx_binary_cross_entropy_loss_grad_input_reshape_out_vec, 1, 1, nullptr, 0, "reshape", "top_l_10_linear_dedx_binary_cross_entropy_loss_grad_input_reshape", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_10_linear_dedx_binary_cross_entropy_loss_grad_input_reshape failed!");

    /*************
     * top_l_10_linear_dedx node
     * inputs: [top_l_10_linear_dedx_binary_cross_entropy_loss_grad_input_tensor_reshape(128, 1, 1, 1)(dtype=bf16), top_l_10_linear_weight(1, 1, 1024, 1)(dtype=bf16)]
     * output: [top_l_10_linear_grad_input(128, 1, 1, 1024)(dtype=bf16)]
     *************/
    synConvolutionParams top_l_10_linear_dedx_kernel_params;
    top_l_10_linear_dedx_kernel_params.dH = 1;
    top_l_10_linear_dedx_kernel_params.dW = 1;
    top_l_10_linear_dedx_kernel_params.kH = 1;
    top_l_10_linear_dedx_kernel_params.kW = 1;
    top_l_10_linear_dedx_kernel_params.padT = 0;
    top_l_10_linear_dedx_kernel_params.padB = 0;
    top_l_10_linear_dedx_kernel_params.padL = 0;
    top_l_10_linear_dedx_kernel_params.padR = 0;
    top_l_10_linear_dedx_kernel_params.dilH = 1;
    top_l_10_linear_dedx_kernel_params.dilW = 1;

    synTensor top_l_10_linear_dedx_in_vec[2] = {top_l_10_linear_dedx_binary_cross_entropy_loss_grad_input_tensor_reshape, top_l_10_linear_weight};


    // create top_l_10_linear_grad_input tensor
    const unsigned top_l_10_linear_grad_input_sizes[] = {128, 1, 1, 1024};
    uint64_t top_l_10_linear_grad_input_dram;
    unsigned top_l_10_linear_grad_input_size = 128*1*1*1024;
    unsigned top_l_10_linear_grad_input_size_in_bytes = top_l_10_linear_grad_input_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_10_linear_grad_input_size_in_bytes, &top_l_10_linear_grad_input_dram, "top_l_10_linear_grad_input");
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_grad_input dram malloc failed!");
    synLaunchTensorInfo top_l_10_linear_grad_input_tr_info = {"top_l_10_linear_grad_input",
                                                              top_l_10_linear_grad_input_dram};
    UNUSED(top_l_10_linear_grad_input_tr_info); // For single op tests
    synTensor top_l_10_linear_grad_input = createTensor(4U, syn_type_bf16, top_l_10_linear_grad_input_sizes, true, "top_l_10_linear_grad_input");
    UNUSED(top_l_10_linear_grad_input); // For single op tests

    synTensor top_l_10_linear_dedx_out_vec[1] = {top_l_10_linear_grad_input};


    status = synNodeCreate(graphHandle, top_l_10_linear_dedx_in_vec, top_l_10_linear_dedx_out_vec, 2, 1, (void *)&top_l_10_linear_dedx_kernel_params, sizeof(top_l_10_linear_dedx_kernel_params), "dedx", "top_l_10_linear_dedx", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_10_linear_dedx failed!");

    /*************
     * top_l_10_linear_dedw_binary_cross_entropy_loss_grad_input_reshape node
     * inputs: [binary_cross_entropy_loss_grad_input(1, 128)(dtype=bf16)]
     * output: [top_l_10_linear_dedw_binary_cross_entropy_loss_grad_input_tensor_reshape(128, 1, 1, 1)(dtype=bf16)]
     *************/

    synTensor top_l_10_linear_dedw_binary_cross_entropy_loss_grad_input_reshape_in_vec[1] = {binary_cross_entropy_loss_grad_input};


    // create top_l_10_linear_dedw_binary_cross_entropy_loss_grad_input_tensor_reshape tensor
    const unsigned top_l_10_linear_dedw_binary_cross_entropy_loss_grad_input_tensor_reshape_sizes[] = {128, 1, 1, 1};
    synTensor top_l_10_linear_dedw_binary_cross_entropy_loss_grad_input_tensor_reshape = createTensor(4U, syn_type_bf16, top_l_10_linear_dedw_binary_cross_entropy_loss_grad_input_tensor_reshape_sizes, false, "top_l_10_linear_dedw_binary_cross_entropy_loss_grad_input_tensor_reshape");
    UNUSED(top_l_10_linear_dedw_binary_cross_entropy_loss_grad_input_tensor_reshape); // For single op tests

    synTensor top_l_10_linear_dedw_binary_cross_entropy_loss_grad_input_reshape_out_vec[1] = {top_l_10_linear_dedw_binary_cross_entropy_loss_grad_input_tensor_reshape};


    status = synNodeCreate(graphHandle, top_l_10_linear_dedw_binary_cross_entropy_loss_grad_input_reshape_in_vec, top_l_10_linear_dedw_binary_cross_entropy_loss_grad_input_reshape_out_vec, 1, 1, nullptr, 0, "reshape", "top_l_10_linear_dedw_binary_cross_entropy_loss_grad_input_reshape", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_10_linear_dedw_binary_cross_entropy_loss_grad_input_reshape failed!");

    /*************
     * top_l_10_linear_dedw node
     * inputs: [top_l_10_linear_dedw_binary_cross_entropy_loss_grad_input_tensor_reshape(128, 1, 1, 1)(dtype=bf16), top_l_8_relu_output(128, 1, 1, 1024)(dtype=bf16)]
     * output: [top_l_10_linear_weight_grad(1, 1, 1024, 1)(dtype=float32)]
     *************/
    synConvolutionParams top_l_10_linear_dedw_kernel_params;
    top_l_10_linear_dedw_kernel_params.dH = 1;
    top_l_10_linear_dedw_kernel_params.dW = 1;
    top_l_10_linear_dedw_kernel_params.kH = 1;
    top_l_10_linear_dedw_kernel_params.kW = 1;
    top_l_10_linear_dedw_kernel_params.padT = 0;
    top_l_10_linear_dedw_kernel_params.padB = 0;
    top_l_10_linear_dedw_kernel_params.padL = 0;
    top_l_10_linear_dedw_kernel_params.padR = 0;
    top_l_10_linear_dedw_kernel_params.dilH = 1;
    top_l_10_linear_dedw_kernel_params.dilW = 1;

    synTensor top_l_10_linear_dedw_in_vec[2] = {top_l_10_linear_dedw_binary_cross_entropy_loss_grad_input_tensor_reshape, top_l_8_relu_output};


    // create top_l_10_linear_weight_grad tensor
    const unsigned top_l_10_linear_weight_grad_sizes[] = {1, 1, 1024, 1};
    uint64_t top_l_10_linear_weight_grad_dram;
    unsigned top_l_10_linear_weight_grad_size = 1*1*1024*1;
    unsigned top_l_10_linear_weight_grad_size_in_bytes = top_l_10_linear_weight_grad_size * sizeof(float) ;
    status = hbmAlloc(top_l_10_linear_weight_grad_size_in_bytes, &top_l_10_linear_weight_grad_dram, "top_l_10_linear_weight_grad");
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_weight_grad dram malloc failed!");
    synLaunchTensorInfo top_l_10_linear_weight_grad_tr_info = {"top_l_10_linear_weight_grad",
                                                               top_l_10_linear_weight_grad_dram};
    UNUSED(top_l_10_linear_weight_grad_tr_info); // For single op tests
    synTensor top_l_10_linear_weight_grad = createTensor(4U, syn_type_single, top_l_10_linear_weight_grad_sizes, true, "top_l_10_linear_weight_grad");
    UNUSED(top_l_10_linear_weight_grad); // For single op tests

    synTensor top_l_10_linear_dedw_out_vec[1] = {top_l_10_linear_weight_grad};


    status = synNodeCreate(graphHandle, top_l_10_linear_dedw_in_vec, top_l_10_linear_dedw_out_vec, 2, 1, (void *)&top_l_10_linear_dedw_kernel_params, sizeof(top_l_10_linear_dedw_kernel_params), "dedw", "top_l_10_linear_dedw", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_10_linear_dedw failed!");

    /*************
     * top_l_10_linear_dedb_binary_cross_entropy_loss_grad_input_reshape node
     * inputs: [binary_cross_entropy_loss_grad_input(1, 128)(dtype=bf16)]
     * output: [top_l_10_linear_dedb_binary_cross_entropy_loss_grad_input_tensor_reshape(128, 1)(dtype=bf16)]
     *************/

    synTensor top_l_10_linear_dedb_binary_cross_entropy_loss_grad_input_reshape_in_vec[1] = {binary_cross_entropy_loss_grad_input};


    // create top_l_10_linear_dedb_binary_cross_entropy_loss_grad_input_tensor_reshape tensor
    const unsigned top_l_10_linear_dedb_binary_cross_entropy_loss_grad_input_tensor_reshape_sizes[] = {128, 1};
    synTensor top_l_10_linear_dedb_binary_cross_entropy_loss_grad_input_tensor_reshape = createTensor(2U, syn_type_bf16, top_l_10_linear_dedb_binary_cross_entropy_loss_grad_input_tensor_reshape_sizes, false, "top_l_10_linear_dedb_binary_cross_entropy_loss_grad_input_tensor_reshape");
    UNUSED(top_l_10_linear_dedb_binary_cross_entropy_loss_grad_input_tensor_reshape); // For single op tests

    synTensor top_l_10_linear_dedb_binary_cross_entropy_loss_grad_input_reshape_out_vec[1] = {top_l_10_linear_dedb_binary_cross_entropy_loss_grad_input_tensor_reshape};


    status = synNodeCreate(graphHandle, top_l_10_linear_dedb_binary_cross_entropy_loss_grad_input_reshape_in_vec, top_l_10_linear_dedb_binary_cross_entropy_loss_grad_input_reshape_out_vec, 1, 1, nullptr, 0, "reshape", "top_l_10_linear_dedb_binary_cross_entropy_loss_grad_input_reshape", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_10_linear_dedb_binary_cross_entropy_loss_grad_input_reshape failed!");

    /*************
     * top_l_10_linear_dedb node
     * inputs: [top_l_10_linear_dedb_binary_cross_entropy_loss_grad_input_tensor_reshape(128, 1)(dtype=bf16)]
     * output: [top_l_10_linear_bias_grad(1,)(dtype=float32)]
     *************/
    ns_Reduction::Params top_l_10_linear_dedb_kernel_params;
    top_l_10_linear_dedb_kernel_params.reductionDimension = 1;

    synTensor top_l_10_linear_dedb_in_vec[1] = {top_l_10_linear_dedb_binary_cross_entropy_loss_grad_input_tensor_reshape};


    // create top_l_10_linear_bias_grad tensor
    const unsigned top_l_10_linear_bias_grad_sizes[] = {1,};
    uint64_t top_l_10_linear_bias_grad_dram;
    unsigned top_l_10_linear_bias_grad_size = 1;
    unsigned top_l_10_linear_bias_grad_size_in_bytes = top_l_10_linear_bias_grad_size * sizeof(float) ;
    status = hbmAlloc(top_l_10_linear_bias_grad_size_in_bytes, &top_l_10_linear_bias_grad_dram, "top_l_10_linear_bias_grad");
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_bias_grad dram malloc failed!");
    synLaunchTensorInfo top_l_10_linear_bias_grad_tr_info = {"top_l_10_linear_bias_grad",
                                                             top_l_10_linear_bias_grad_dram};
    UNUSED(top_l_10_linear_bias_grad_tr_info); // For single op tests
    synTensor top_l_10_linear_bias_grad = createTensor(1U, syn_type_single, top_l_10_linear_bias_grad_sizes, true, "top_l_10_linear_bias_grad");
    UNUSED(top_l_10_linear_bias_grad); // For single op tests

    synTensor top_l_10_linear_dedb_out_vec[1] = {top_l_10_linear_bias_grad};


    status = synNodeCreate(graphHandle, top_l_10_linear_dedb_in_vec, top_l_10_linear_dedb_out_vec, 1, 1, (void *)&top_l_10_linear_dedb_kernel_params, sizeof(top_l_10_linear_dedb_kernel_params), "reduce_sum_fwd_bf16", "top_l_10_linear_dedb", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_10_linear_dedb failed!");

    /*************
     * top_l_8_relu_bwd node
     * inputs: [top_l_10_linear_grad_input(128, 1, 1, 1024)(dtype=bf16), top_l_8_relu_output(128, 1, 1, 1024)(dtype=bf16)]
     * output: [top_l_8_relu_grad_input(128, 1, 1, 1024)(dtype=bf16)]
     *************/

    synTensor top_l_8_relu_bwd_in_vec[2] = {top_l_10_linear_grad_input, top_l_8_relu_output};


    // create top_l_8_relu_grad_input tensor
    const unsigned top_l_8_relu_grad_input_sizes[] = {128, 1, 1, 1024};
    synTensor top_l_8_relu_grad_input = createTensor(4U, syn_type_bf16, top_l_8_relu_grad_input_sizes, false, "top_l_8_relu_grad_input");
    UNUSED(top_l_8_relu_grad_input); // For single op tests

    synTensor top_l_8_relu_bwd_out_vec[1] = {top_l_8_relu_grad_input};


    status = synNodeCreate(graphHandle, top_l_8_relu_bwd_in_vec, top_l_8_relu_bwd_out_vec, 2, 1, nullptr, 0, "relu_bwd_bf16", "top_l_8_relu_bwd", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_8_relu_bwd failed!");

    /*************
     * top_l_8_linear_dedx node
     * inputs: [top_l_8_relu_grad_input(128, 1, 1, 1024)(dtype=bf16), top_l_8_linear_weight(1, 1, 1024, 1024)(dtype=bf16)]
     * output: [top_l_8_linear_grad_input(128, 1, 1, 1024)(dtype=bf16)]
     *************/
    synConvolutionParams top_l_8_linear_dedx_kernel_params;
    top_l_8_linear_dedx_kernel_params.dH = 1;
    top_l_8_linear_dedx_kernel_params.dW = 1;
    top_l_8_linear_dedx_kernel_params.kH = 1;
    top_l_8_linear_dedx_kernel_params.kW = 1;
    top_l_8_linear_dedx_kernel_params.padT = 0;
    top_l_8_linear_dedx_kernel_params.padB = 0;
    top_l_8_linear_dedx_kernel_params.padL = 0;
    top_l_8_linear_dedx_kernel_params.padR = 0;
    top_l_8_linear_dedx_kernel_params.dilH = 1;
    top_l_8_linear_dedx_kernel_params.dilW = 1;

    synTensor top_l_8_linear_dedx_in_vec[2] = {top_l_8_relu_grad_input, top_l_8_linear_weight};


    // create top_l_8_linear_grad_input tensor
    const unsigned top_l_8_linear_grad_input_sizes[] = {128, 1, 1, 1024};
    uint64_t top_l_8_linear_grad_input_dram;
    unsigned top_l_8_linear_grad_input_size = 128*1*1*1024;
    unsigned top_l_8_linear_grad_input_size_in_bytes = top_l_8_linear_grad_input_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_8_linear_grad_input_size_in_bytes, &top_l_8_linear_grad_input_dram, "top_l_8_linear_grad_input");
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_grad_input dram malloc failed!");
    synLaunchTensorInfo top_l_8_linear_grad_input_tr_info = {"top_l_8_linear_grad_input",
                                                             top_l_8_linear_grad_input_dram};
    UNUSED(top_l_8_linear_grad_input_tr_info); // For single op tests
    synTensor top_l_8_linear_grad_input = createTensor(4U, syn_type_bf16, top_l_8_linear_grad_input_sizes, true, "top_l_8_linear_grad_input");
    UNUSED(top_l_8_linear_grad_input); // For single op tests

    synTensor top_l_8_linear_dedx_out_vec[1] = {top_l_8_linear_grad_input};


    status = synNodeCreate(graphHandle, top_l_8_linear_dedx_in_vec, top_l_8_linear_dedx_out_vec, 2, 1, (void *)&top_l_8_linear_dedx_kernel_params, sizeof(top_l_8_linear_dedx_kernel_params), "dedx", "top_l_8_linear_dedx", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_8_linear_dedx failed!");

    /*************
     * top_l_8_linear_dedw node
     * inputs: [top_l_8_relu_grad_input(128, 1, 1, 1024)(dtype=bf16), top_l_6_relu_output(128, 1, 1, 1024)(dtype=bf16)]
     * output: [top_l_8_linear_weight_grad(1, 1, 1024, 1024)(dtype=float32)]
     *************/
    synConvolutionParams top_l_8_linear_dedw_kernel_params;
    top_l_8_linear_dedw_kernel_params.dH = 1;
    top_l_8_linear_dedw_kernel_params.dW = 1;
    top_l_8_linear_dedw_kernel_params.kH = 1;
    top_l_8_linear_dedw_kernel_params.kW = 1;
    top_l_8_linear_dedw_kernel_params.padT = 0;
    top_l_8_linear_dedw_kernel_params.padB = 0;
    top_l_8_linear_dedw_kernel_params.padL = 0;
    top_l_8_linear_dedw_kernel_params.padR = 0;
    top_l_8_linear_dedw_kernel_params.dilH = 1;
    top_l_8_linear_dedw_kernel_params.dilW = 1;

    synTensor top_l_8_linear_dedw_in_vec[2] = {top_l_8_relu_grad_input, top_l_6_relu_output};


    // create top_l_8_linear_weight_grad tensor
    const unsigned top_l_8_linear_weight_grad_sizes[] = {1, 1, 1024, 1024};
    uint64_t top_l_8_linear_weight_grad_dram;
    unsigned top_l_8_linear_weight_grad_size = 1*1*1024*1024;
    unsigned top_l_8_linear_weight_grad_size_in_bytes = top_l_8_linear_weight_grad_size * sizeof(float) ;
    status = hbmAlloc(top_l_8_linear_weight_grad_size_in_bytes, &top_l_8_linear_weight_grad_dram, "top_l_8_linear_weight_grad");
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_weight_grad dram malloc failed!");
    synLaunchTensorInfo top_l_8_linear_weight_grad_tr_info = {"top_l_8_linear_weight_grad",
                                                              top_l_8_linear_weight_grad_dram};
    UNUSED(top_l_8_linear_weight_grad_tr_info); // For single op tests
    synTensor top_l_8_linear_weight_grad = createTensor(4U, syn_type_single, top_l_8_linear_weight_grad_sizes, true, "top_l_8_linear_weight_grad");
    UNUSED(top_l_8_linear_weight_grad); // For single op tests

    synTensor top_l_8_linear_dedw_out_vec[1] = {top_l_8_linear_weight_grad};


    status = synNodeCreate(graphHandle, top_l_8_linear_dedw_in_vec, top_l_8_linear_dedw_out_vec, 2, 1, (void *)&top_l_8_linear_dedw_kernel_params, sizeof(top_l_8_linear_dedw_kernel_params), "dedw", "top_l_8_linear_dedw", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_8_linear_dedw failed!");

    /*************
     * top_l_8_linear_dedb_top_l_8_relu_grad_input_reshape node
     * inputs: [top_l_8_relu_grad_input(128, 1, 1, 1024)(dtype=bf16)]
     * output: [top_l_8_linear_dedb_top_l_8_relu_grad_input_tensor_reshape(128, 1024)(dtype=bf16)]
     *************/

    synTensor top_l_8_linear_dedb_top_l_8_relu_grad_input_reshape_in_vec[1] = {top_l_8_relu_grad_input};


    // create top_l_8_linear_dedb_top_l_8_relu_grad_input_tensor_reshape tensor
    const unsigned top_l_8_linear_dedb_top_l_8_relu_grad_input_tensor_reshape_sizes[] = {128, 1024};
    synTensor top_l_8_linear_dedb_top_l_8_relu_grad_input_tensor_reshape = createTensor(2U, syn_type_bf16, top_l_8_linear_dedb_top_l_8_relu_grad_input_tensor_reshape_sizes, false, "top_l_8_linear_dedb_top_l_8_relu_grad_input_tensor_reshape");
    UNUSED(top_l_8_linear_dedb_top_l_8_relu_grad_input_tensor_reshape); // For single op tests

    synTensor top_l_8_linear_dedb_top_l_8_relu_grad_input_reshape_out_vec[1] = {top_l_8_linear_dedb_top_l_8_relu_grad_input_tensor_reshape};


    status = synNodeCreate(graphHandle, top_l_8_linear_dedb_top_l_8_relu_grad_input_reshape_in_vec, top_l_8_linear_dedb_top_l_8_relu_grad_input_reshape_out_vec, 1, 1, nullptr, 0, "reshape", "top_l_8_linear_dedb_top_l_8_relu_grad_input_reshape", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_8_linear_dedb_top_l_8_relu_grad_input_reshape failed!");

    /*************
     * top_l_8_linear_dedb node
     * inputs: [top_l_8_linear_dedb_top_l_8_relu_grad_input_tensor_reshape(128, 1024)(dtype=bf16)]
     * output: [top_l_8_linear_bias_grad(1024,)(dtype=float32)]
     *************/
    ns_Reduction::Params top_l_8_linear_dedb_kernel_params;
    top_l_8_linear_dedb_kernel_params.reductionDimension = 1;

    synTensor top_l_8_linear_dedb_in_vec[1] = {top_l_8_linear_dedb_top_l_8_relu_grad_input_tensor_reshape};


    // create top_l_8_linear_bias_grad tensor
    const unsigned top_l_8_linear_bias_grad_sizes[] = {1024,};
    uint64_t top_l_8_linear_bias_grad_dram;
    unsigned top_l_8_linear_bias_grad_size = 1024;
    unsigned top_l_8_linear_bias_grad_size_in_bytes = top_l_8_linear_bias_grad_size * sizeof(float) ;
    status = hbmAlloc(top_l_8_linear_bias_grad_size_in_bytes, &top_l_8_linear_bias_grad_dram, "top_l_8_linear_bias_grad");
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_bias_grad dram malloc failed!");
    synLaunchTensorInfo top_l_8_linear_bias_grad_tr_info = {"top_l_8_linear_bias_grad", top_l_8_linear_bias_grad_dram};
    UNUSED(top_l_8_linear_bias_grad_tr_info); // For single op tests
    synTensor top_l_8_linear_bias_grad = createTensor(1U, syn_type_single, top_l_8_linear_bias_grad_sizes, true, "top_l_8_linear_bias_grad");
    UNUSED(top_l_8_linear_bias_grad); // For single op tests

    synTensor top_l_8_linear_dedb_out_vec[1] = {top_l_8_linear_bias_grad};


    status = synNodeCreate(graphHandle, top_l_8_linear_dedb_in_vec, top_l_8_linear_dedb_out_vec, 1, 1, (void *)&top_l_8_linear_dedb_kernel_params, sizeof(top_l_8_linear_dedb_kernel_params), "reduce_sum_fwd_bf16", "top_l_8_linear_dedb", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_8_linear_dedb failed!");

    /*************
     * top_l_6_relu_bwd node
     * inputs: [top_l_8_linear_grad_input(128, 1, 1, 1024)(dtype=bf16), top_l_6_relu_output(128, 1, 1, 1024)(dtype=bf16)]
     * output: [top_l_6_relu_grad_input(128, 1, 1, 1024)(dtype=bf16)]
     *************/

    synTensor top_l_6_relu_bwd_in_vec[2] = {top_l_8_linear_grad_input, top_l_6_relu_output};


    // create top_l_6_relu_grad_input tensor
    const unsigned top_l_6_relu_grad_input_sizes[] = {128, 1, 1, 1024};
    synTensor top_l_6_relu_grad_input = createTensor(4U, syn_type_bf16, top_l_6_relu_grad_input_sizes, false, "top_l_6_relu_grad_input");
    UNUSED(top_l_6_relu_grad_input); // For single op tests

    synTensor top_l_6_relu_bwd_out_vec[1] = {top_l_6_relu_grad_input};


    status = synNodeCreate(graphHandle, top_l_6_relu_bwd_in_vec, top_l_6_relu_bwd_out_vec, 2, 1, nullptr, 0, "relu_bwd_bf16", "top_l_6_relu_bwd", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_6_relu_bwd failed!");

    /*************
     * top_l_6_linear_dedx node
     * inputs: [top_l_6_relu_grad_input(128, 1, 1, 1024)(dtype=bf16), top_l_6_linear_weight(1, 1, 1024, 1024)(dtype=bf16)]
     * output: [top_l_6_linear_grad_input(128, 1, 1, 1024)(dtype=bf16)]
     *************/
    synConvolutionParams top_l_6_linear_dedx_kernel_params;
    top_l_6_linear_dedx_kernel_params.dH = 1;
    top_l_6_linear_dedx_kernel_params.dW = 1;
    top_l_6_linear_dedx_kernel_params.kH = 1;
    top_l_6_linear_dedx_kernel_params.kW = 1;
    top_l_6_linear_dedx_kernel_params.padT = 0;
    top_l_6_linear_dedx_kernel_params.padB = 0;
    top_l_6_linear_dedx_kernel_params.padL = 0;
    top_l_6_linear_dedx_kernel_params.padR = 0;
    top_l_6_linear_dedx_kernel_params.dilH = 1;
    top_l_6_linear_dedx_kernel_params.dilW = 1;

    synTensor top_l_6_linear_dedx_in_vec[2] = {top_l_6_relu_grad_input, top_l_6_linear_weight};


    // create top_l_6_linear_grad_input tensor
    const unsigned top_l_6_linear_grad_input_sizes[] = {128, 1, 1, 1024};
    uint64_t top_l_6_linear_grad_input_dram;
    unsigned top_l_6_linear_grad_input_size = 128*1*1*1024;
    unsigned top_l_6_linear_grad_input_size_in_bytes = top_l_6_linear_grad_input_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_6_linear_grad_input_size_in_bytes, &top_l_6_linear_grad_input_dram, "top_l_6_linear_grad_input");
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_grad_input dram malloc failed!");
    synLaunchTensorInfo top_l_6_linear_grad_input_tr_info = {"top_l_6_linear_grad_input",
                                                             top_l_6_linear_grad_input_dram};
    UNUSED(top_l_6_linear_grad_input_tr_info); // For single op tests
    synTensor top_l_6_linear_grad_input = createTensor(4U, syn_type_bf16, top_l_6_linear_grad_input_sizes, true, "top_l_6_linear_grad_input");
    UNUSED(top_l_6_linear_grad_input); // For single op tests

    synTensor top_l_6_linear_dedx_out_vec[1] = {top_l_6_linear_grad_input};


    status = synNodeCreate(graphHandle, top_l_6_linear_dedx_in_vec, top_l_6_linear_dedx_out_vec, 2, 1, (void *)&top_l_6_linear_dedx_kernel_params, sizeof(top_l_6_linear_dedx_kernel_params), "dedx", "top_l_6_linear_dedx", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_6_linear_dedx failed!");

    /*************
     * top_l_6_linear_dedw node
     * inputs: [top_l_6_relu_grad_input(128, 1, 1, 1024)(dtype=bf16), top_l_4_relu_output(128, 1, 1, 1024)(dtype=bf16)]
     * output: [top_l_6_linear_weight_grad(1, 1, 1024, 1024)(dtype=float32)]
     *************/
    synConvolutionParams top_l_6_linear_dedw_kernel_params;
    top_l_6_linear_dedw_kernel_params.dH = 1;
    top_l_6_linear_dedw_kernel_params.dW = 1;
    top_l_6_linear_dedw_kernel_params.kH = 1;
    top_l_6_linear_dedw_kernel_params.kW = 1;
    top_l_6_linear_dedw_kernel_params.padT = 0;
    top_l_6_linear_dedw_kernel_params.padB = 0;
    top_l_6_linear_dedw_kernel_params.padL = 0;
    top_l_6_linear_dedw_kernel_params.padR = 0;
    top_l_6_linear_dedw_kernel_params.dilH = 1;
    top_l_6_linear_dedw_kernel_params.dilW = 1;

    synTensor top_l_6_linear_dedw_in_vec[2] = {top_l_6_relu_grad_input, top_l_4_relu_output};


    // create top_l_6_linear_weight_grad tensor
    const unsigned top_l_6_linear_weight_grad_sizes[] = {1, 1, 1024, 1024};
    uint64_t top_l_6_linear_weight_grad_dram;
    unsigned top_l_6_linear_weight_grad_size = 1*1*1024*1024;
    unsigned top_l_6_linear_weight_grad_size_in_bytes = top_l_6_linear_weight_grad_size * sizeof(float) ;
    status = hbmAlloc(top_l_6_linear_weight_grad_size_in_bytes, &top_l_6_linear_weight_grad_dram, "top_l_6_linear_weight_grad");
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_weight_grad dram malloc failed!");
    synLaunchTensorInfo top_l_6_linear_weight_grad_tr_info = {"top_l_6_linear_weight_grad",
                                                              top_l_6_linear_weight_grad_dram};
    UNUSED(top_l_6_linear_weight_grad_tr_info); // For single op tests
    synTensor top_l_6_linear_weight_grad = createTensor(4U, syn_type_single, top_l_6_linear_weight_grad_sizes, true, "top_l_6_linear_weight_grad");
    UNUSED(top_l_6_linear_weight_grad); // For single op tests

    synTensor top_l_6_linear_dedw_out_vec[1] = {top_l_6_linear_weight_grad};


    status = synNodeCreate(graphHandle, top_l_6_linear_dedw_in_vec, top_l_6_linear_dedw_out_vec, 2, 1, (void *)&top_l_6_linear_dedw_kernel_params, sizeof(top_l_6_linear_dedw_kernel_params), "dedw", "top_l_6_linear_dedw", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_6_linear_dedw failed!");

    /*************
     * top_l_6_linear_dedb_top_l_6_relu_grad_input_reshape node
     * inputs: [top_l_6_relu_grad_input(128, 1, 1, 1024)(dtype=bf16)]
     * output: [top_l_6_linear_dedb_top_l_6_relu_grad_input_tensor_reshape(128, 1024)(dtype=bf16)]
     *************/

    synTensor top_l_6_linear_dedb_top_l_6_relu_grad_input_reshape_in_vec[1] = {top_l_6_relu_grad_input};


    // create top_l_6_linear_dedb_top_l_6_relu_grad_input_tensor_reshape tensor
    const unsigned top_l_6_linear_dedb_top_l_6_relu_grad_input_tensor_reshape_sizes[] = {128, 1024};
    synTensor top_l_6_linear_dedb_top_l_6_relu_grad_input_tensor_reshape = createTensor(2U, syn_type_bf16, top_l_6_linear_dedb_top_l_6_relu_grad_input_tensor_reshape_sizes, false, "top_l_6_linear_dedb_top_l_6_relu_grad_input_tensor_reshape");
    UNUSED(top_l_6_linear_dedb_top_l_6_relu_grad_input_tensor_reshape); // For single op tests

    synTensor top_l_6_linear_dedb_top_l_6_relu_grad_input_reshape_out_vec[1] = {top_l_6_linear_dedb_top_l_6_relu_grad_input_tensor_reshape};


    status = synNodeCreate(graphHandle, top_l_6_linear_dedb_top_l_6_relu_grad_input_reshape_in_vec, top_l_6_linear_dedb_top_l_6_relu_grad_input_reshape_out_vec, 1, 1, nullptr, 0, "reshape", "top_l_6_linear_dedb_top_l_6_relu_grad_input_reshape", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_6_linear_dedb_top_l_6_relu_grad_input_reshape failed!");

    /*************
     * top_l_6_linear_dedb node
     * inputs: [top_l_6_linear_dedb_top_l_6_relu_grad_input_tensor_reshape(128, 1024)(dtype=bf16)]
     * output: [top_l_6_linear_bias_grad(1024,)(dtype=float32)]
     *************/
    ns_Reduction::Params top_l_6_linear_dedb_kernel_params;
    top_l_6_linear_dedb_kernel_params.reductionDimension = 1;

    synTensor top_l_6_linear_dedb_in_vec[1] = {top_l_6_linear_dedb_top_l_6_relu_grad_input_tensor_reshape};


    // create top_l_6_linear_bias_grad tensor
    const unsigned top_l_6_linear_bias_grad_sizes[] = {1024,};
    uint64_t top_l_6_linear_bias_grad_dram;
    unsigned top_l_6_linear_bias_grad_size = 1024;
    unsigned top_l_6_linear_bias_grad_size_in_bytes = top_l_6_linear_bias_grad_size * sizeof(float) ;
    status = hbmAlloc(top_l_6_linear_bias_grad_size_in_bytes, &top_l_6_linear_bias_grad_dram, "top_l_6_linear_bias_grad");
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_bias_grad dram malloc failed!");
    synLaunchTensorInfo top_l_6_linear_bias_grad_tr_info = {"top_l_6_linear_bias_grad", top_l_6_linear_bias_grad_dram};
    UNUSED(top_l_6_linear_bias_grad_tr_info); // For single op tests
    synTensor top_l_6_linear_bias_grad = createTensor(1U, syn_type_single, top_l_6_linear_bias_grad_sizes, true, "top_l_6_linear_bias_grad");
    UNUSED(top_l_6_linear_bias_grad); // For single op tests

    synTensor top_l_6_linear_dedb_out_vec[1] = {top_l_6_linear_bias_grad};


    status = synNodeCreate(graphHandle, top_l_6_linear_dedb_in_vec, top_l_6_linear_dedb_out_vec, 1, 1, (void *)&top_l_6_linear_dedb_kernel_params, sizeof(top_l_6_linear_dedb_kernel_params), "reduce_sum_fwd_bf16", "top_l_6_linear_dedb", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_6_linear_dedb failed!");

    /*************
     * top_l_4_relu_bwd node
     * inputs: [top_l_6_linear_grad_input(128, 1, 1, 1024)(dtype=bf16), top_l_4_relu_output(128, 1, 1, 1024)(dtype=bf16)]
     * output: [top_l_4_relu_grad_input(128, 1, 1, 1024)(dtype=bf16)]
     *************/

    synTensor top_l_4_relu_bwd_in_vec[2] = {top_l_6_linear_grad_input, top_l_4_relu_output};


    // create top_l_4_relu_grad_input tensor
    const unsigned top_l_4_relu_grad_input_sizes[] = {128, 1, 1, 1024};
    synTensor top_l_4_relu_grad_input = createTensor(4U, syn_type_bf16, top_l_4_relu_grad_input_sizes, false, "top_l_4_relu_grad_input");
    UNUSED(top_l_4_relu_grad_input); // For single op tests

    synTensor top_l_4_relu_bwd_out_vec[1] = {top_l_4_relu_grad_input};


    status = synNodeCreate(graphHandle, top_l_4_relu_bwd_in_vec, top_l_4_relu_bwd_out_vec, 2, 1, nullptr, 0, "relu_bwd_bf16", "top_l_4_relu_bwd", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_4_relu_bwd failed!");

    /*************
     * top_l_4_linear_dedx node
     * inputs: [top_l_4_relu_grad_input(128, 1, 1, 1024)(dtype=bf16), top_l_4_linear_weight(1, 1, 1024, 1024)(dtype=bf16)]
     * output: [top_l_4_linear_grad_input(128, 1, 1, 1024)(dtype=bf16)]
     *************/
    synConvolutionParams top_l_4_linear_dedx_kernel_params;
    top_l_4_linear_dedx_kernel_params.dH = 1;
    top_l_4_linear_dedx_kernel_params.dW = 1;
    top_l_4_linear_dedx_kernel_params.kH = 1;
    top_l_4_linear_dedx_kernel_params.kW = 1;
    top_l_4_linear_dedx_kernel_params.padT = 0;
    top_l_4_linear_dedx_kernel_params.padB = 0;
    top_l_4_linear_dedx_kernel_params.padL = 0;
    top_l_4_linear_dedx_kernel_params.padR = 0;
    top_l_4_linear_dedx_kernel_params.dilH = 1;
    top_l_4_linear_dedx_kernel_params.dilW = 1;

    synTensor top_l_4_linear_dedx_in_vec[2] = {top_l_4_relu_grad_input, top_l_4_linear_weight};


    // create top_l_4_linear_grad_input tensor
    const unsigned top_l_4_linear_grad_input_sizes[] = {128, 1, 1, 1024};
    uint64_t top_l_4_linear_grad_input_dram;
    unsigned top_l_4_linear_grad_input_size = 128*1*1*1024;
    unsigned top_l_4_linear_grad_input_size_in_bytes = top_l_4_linear_grad_input_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_4_linear_grad_input_size_in_bytes, &top_l_4_linear_grad_input_dram, "top_l_4_linear_grad_input");
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_grad_input dram malloc failed!");
    synLaunchTensorInfo top_l_4_linear_grad_input_tr_info = {"top_l_4_linear_grad_input",
                                                             top_l_4_linear_grad_input_dram};
    UNUSED(top_l_4_linear_grad_input_tr_info); // For single op tests
    synTensor top_l_4_linear_grad_input = createTensor(4U, syn_type_bf16, top_l_4_linear_grad_input_sizes, true, "top_l_4_linear_grad_input");
    UNUSED(top_l_4_linear_grad_input); // For single op tests

    synTensor top_l_4_linear_dedx_out_vec[1] = {top_l_4_linear_grad_input};


    status = synNodeCreate(graphHandle, top_l_4_linear_dedx_in_vec, top_l_4_linear_dedx_out_vec, 2, 1, (void *)&top_l_4_linear_dedx_kernel_params, sizeof(top_l_4_linear_dedx_kernel_params), "dedx", "top_l_4_linear_dedx", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_4_linear_dedx failed!");

    /*************
     * top_l_4_linear_dedw node
     * inputs: [top_l_4_relu_grad_input(128, 1, 1, 1024)(dtype=bf16), top_l_2_relu_output(128, 1, 1, 1024)(dtype=bf16)]
     * output: [top_l_4_linear_weight_grad(1, 1, 1024, 1024)(dtype=float32)]
     *************/
    synConvolutionParams top_l_4_linear_dedw_kernel_params;
    top_l_4_linear_dedw_kernel_params.dH = 1;
    top_l_4_linear_dedw_kernel_params.dW = 1;
    top_l_4_linear_dedw_kernel_params.kH = 1;
    top_l_4_linear_dedw_kernel_params.kW = 1;
    top_l_4_linear_dedw_kernel_params.padT = 0;
    top_l_4_linear_dedw_kernel_params.padB = 0;
    top_l_4_linear_dedw_kernel_params.padL = 0;
    top_l_4_linear_dedw_kernel_params.padR = 0;
    top_l_4_linear_dedw_kernel_params.dilH = 1;
    top_l_4_linear_dedw_kernel_params.dilW = 1;

    synTensor top_l_4_linear_dedw_in_vec[2] = {top_l_4_relu_grad_input, top_l_2_relu_output};


    // create top_l_4_linear_weight_grad tensor
    const unsigned top_l_4_linear_weight_grad_sizes[] = {1, 1, 1024, 1024};
    uint64_t top_l_4_linear_weight_grad_dram;
    unsigned top_l_4_linear_weight_grad_size = 1*1*1024*1024;
    unsigned top_l_4_linear_weight_grad_size_in_bytes = top_l_4_linear_weight_grad_size * sizeof(float) ;
    status = hbmAlloc(top_l_4_linear_weight_grad_size_in_bytes, &top_l_4_linear_weight_grad_dram, "top_l_4_linear_weight_grad");
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_weight_grad dram malloc failed!");
    synLaunchTensorInfo top_l_4_linear_weight_grad_tr_info = {"top_l_4_linear_weight_grad",
                                                              top_l_4_linear_weight_grad_dram};
    UNUSED(top_l_4_linear_weight_grad_tr_info); // For single op tests
    synTensor top_l_4_linear_weight_grad = createTensor(4U, syn_type_single, top_l_4_linear_weight_grad_sizes, true, "top_l_4_linear_weight_grad");
    UNUSED(top_l_4_linear_weight_grad); // For single op tests

    synTensor top_l_4_linear_dedw_out_vec[1] = {top_l_4_linear_weight_grad};


    status = synNodeCreate(graphHandle, top_l_4_linear_dedw_in_vec, top_l_4_linear_dedw_out_vec, 2, 1, (void *)&top_l_4_linear_dedw_kernel_params, sizeof(top_l_4_linear_dedw_kernel_params), "dedw", "top_l_4_linear_dedw", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_4_linear_dedw failed!");

    /*************
     * top_l_4_linear_dedb_top_l_4_relu_grad_input_reshape node
     * inputs: [top_l_4_relu_grad_input(128, 1, 1, 1024)(dtype=bf16)]
     * output: [top_l_4_linear_dedb_top_l_4_relu_grad_input_tensor_reshape(128, 1024)(dtype=bf16)]
     *************/

    synTensor top_l_4_linear_dedb_top_l_4_relu_grad_input_reshape_in_vec[1] = {top_l_4_relu_grad_input};


    // create top_l_4_linear_dedb_top_l_4_relu_grad_input_tensor_reshape tensor
    const unsigned top_l_4_linear_dedb_top_l_4_relu_grad_input_tensor_reshape_sizes[] = {128, 1024};
    synTensor top_l_4_linear_dedb_top_l_4_relu_grad_input_tensor_reshape = createTensor(2U, syn_type_bf16, top_l_4_linear_dedb_top_l_4_relu_grad_input_tensor_reshape_sizes, false, "top_l_4_linear_dedb_top_l_4_relu_grad_input_tensor_reshape");
    UNUSED(top_l_4_linear_dedb_top_l_4_relu_grad_input_tensor_reshape); // For single op tests

    synTensor top_l_4_linear_dedb_top_l_4_relu_grad_input_reshape_out_vec[1] = {top_l_4_linear_dedb_top_l_4_relu_grad_input_tensor_reshape};


    status = synNodeCreate(graphHandle, top_l_4_linear_dedb_top_l_4_relu_grad_input_reshape_in_vec, top_l_4_linear_dedb_top_l_4_relu_grad_input_reshape_out_vec, 1, 1, nullptr, 0, "reshape", "top_l_4_linear_dedb_top_l_4_relu_grad_input_reshape", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_4_linear_dedb_top_l_4_relu_grad_input_reshape failed!");

    /*************
     * top_l_4_linear_dedb node
     * inputs: [top_l_4_linear_dedb_top_l_4_relu_grad_input_tensor_reshape(128, 1024)(dtype=bf16)]
     * output: [top_l_4_linear_bias_grad(1024,)(dtype=float32)]
     *************/
    ns_Reduction::Params top_l_4_linear_dedb_kernel_params;
    top_l_4_linear_dedb_kernel_params.reductionDimension = 1;

    synTensor top_l_4_linear_dedb_in_vec[1] = {top_l_4_linear_dedb_top_l_4_relu_grad_input_tensor_reshape};


    // create top_l_4_linear_bias_grad tensor
    const unsigned top_l_4_linear_bias_grad_sizes[] = {1024,};
    uint64_t top_l_4_linear_bias_grad_dram;
    unsigned top_l_4_linear_bias_grad_size = 1024;
    unsigned top_l_4_linear_bias_grad_size_in_bytes = top_l_4_linear_bias_grad_size * sizeof(float) ;
    status = hbmAlloc(top_l_4_linear_bias_grad_size_in_bytes, &top_l_4_linear_bias_grad_dram, "top_l_4_linear_bias_grad");
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_bias_grad dram malloc failed!");
    synLaunchTensorInfo top_l_4_linear_bias_grad_tr_info = {"top_l_4_linear_bias_grad", top_l_4_linear_bias_grad_dram};
    UNUSED(top_l_4_linear_bias_grad_tr_info); // For single op tests
    synTensor top_l_4_linear_bias_grad = createTensor(1U, syn_type_single, top_l_4_linear_bias_grad_sizes, true, "top_l_4_linear_bias_grad");
    UNUSED(top_l_4_linear_bias_grad); // For single op tests

    synTensor top_l_4_linear_dedb_out_vec[1] = {top_l_4_linear_bias_grad};


    status = synNodeCreate(graphHandle, top_l_4_linear_dedb_in_vec, top_l_4_linear_dedb_out_vec, 1, 1, (void *)&top_l_4_linear_dedb_kernel_params, sizeof(top_l_4_linear_dedb_kernel_params), "reduce_sum_fwd_bf16", "top_l_4_linear_dedb", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_4_linear_dedb failed!");

    /*************
     * top_l_2_relu_bwd node
     * inputs: [top_l_4_linear_grad_input(128, 1, 1, 1024)(dtype=bf16), top_l_2_relu_output(128, 1, 1, 1024)(dtype=bf16)]
     * output: [top_l_2_relu_grad_input(128, 1, 1, 1024)(dtype=bf16)]
     *************/

    synTensor top_l_2_relu_bwd_in_vec[2] = {top_l_4_linear_grad_input, top_l_2_relu_output};


    // create top_l_2_relu_grad_input tensor
    const unsigned top_l_2_relu_grad_input_sizes[] = {128, 1, 1, 1024};
    synTensor top_l_2_relu_grad_input = createTensor(4U, syn_type_bf16, top_l_2_relu_grad_input_sizes, false, "top_l_2_relu_grad_input");
    UNUSED(top_l_2_relu_grad_input); // For single op tests

    synTensor top_l_2_relu_bwd_out_vec[1] = {top_l_2_relu_grad_input};


    status = synNodeCreate(graphHandle, top_l_2_relu_bwd_in_vec, top_l_2_relu_bwd_out_vec, 2, 1, nullptr, 0, "relu_bwd_bf16", "top_l_2_relu_bwd", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_2_relu_bwd failed!");

    /*************
     * top_l_2_linear_dedx node
     * inputs: [top_l_2_relu_grad_input(128, 1, 1, 1024)(dtype=bf16), top_l_2_linear_weight(1, 1, 1024, 1024)(dtype=bf16)]
     * output: [top_l_2_linear_grad_input(128, 1, 1, 1024)(dtype=bf16)]
     *************/
    synConvolutionParams top_l_2_linear_dedx_kernel_params;
    top_l_2_linear_dedx_kernel_params.dH = 1;
    top_l_2_linear_dedx_kernel_params.dW = 1;
    top_l_2_linear_dedx_kernel_params.kH = 1;
    top_l_2_linear_dedx_kernel_params.kW = 1;
    top_l_2_linear_dedx_kernel_params.padT = 0;
    top_l_2_linear_dedx_kernel_params.padB = 0;
    top_l_2_linear_dedx_kernel_params.padL = 0;
    top_l_2_linear_dedx_kernel_params.padR = 0;
    top_l_2_linear_dedx_kernel_params.dilH = 1;
    top_l_2_linear_dedx_kernel_params.dilW = 1;

    synTensor top_l_2_linear_dedx_in_vec[2] = {top_l_2_relu_grad_input, top_l_2_linear_weight};


    // create top_l_2_linear_grad_input tensor
    const unsigned top_l_2_linear_grad_input_sizes[] = {128, 1, 1, 1024};
    uint64_t top_l_2_linear_grad_input_dram;
    unsigned top_l_2_linear_grad_input_size = 128*1*1*1024;
    unsigned top_l_2_linear_grad_input_size_in_bytes = top_l_2_linear_grad_input_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_2_linear_grad_input_size_in_bytes, &top_l_2_linear_grad_input_dram, "top_l_2_linear_grad_input");
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_grad_input dram malloc failed!");
    synLaunchTensorInfo top_l_2_linear_grad_input_tr_info = {"top_l_2_linear_grad_input",
                                                             top_l_2_linear_grad_input_dram};
    UNUSED(top_l_2_linear_grad_input_tr_info); // For single op tests
    synTensor top_l_2_linear_grad_input = createTensor(4U, syn_type_bf16, top_l_2_linear_grad_input_sizes, true, "top_l_2_linear_grad_input");
    UNUSED(top_l_2_linear_grad_input); // For single op tests

    synTensor top_l_2_linear_dedx_out_vec[1] = {top_l_2_linear_grad_input};


    status = synNodeCreate(graphHandle, top_l_2_linear_dedx_in_vec, top_l_2_linear_dedx_out_vec, 2, 1, (void *)&top_l_2_linear_dedx_kernel_params, sizeof(top_l_2_linear_dedx_kernel_params), "dedx", "top_l_2_linear_dedx", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_2_linear_dedx failed!");

    /*************
     * top_l_2_linear_dedw node
     * inputs: [top_l_2_relu_grad_input(128, 1, 1, 1024)(dtype=bf16), top_l_0_relu_output(128, 1, 1, 1024)(dtype=bf16)]
     * output: [top_l_2_linear_weight_grad(1, 1, 1024, 1024)(dtype=float32)]
     *************/
    synConvolutionParams top_l_2_linear_dedw_kernel_params;
    top_l_2_linear_dedw_kernel_params.dH = 1;
    top_l_2_linear_dedw_kernel_params.dW = 1;
    top_l_2_linear_dedw_kernel_params.kH = 1;
    top_l_2_linear_dedw_kernel_params.kW = 1;
    top_l_2_linear_dedw_kernel_params.padT = 0;
    top_l_2_linear_dedw_kernel_params.padB = 0;
    top_l_2_linear_dedw_kernel_params.padL = 0;
    top_l_2_linear_dedw_kernel_params.padR = 0;
    top_l_2_linear_dedw_kernel_params.dilH = 1;
    top_l_2_linear_dedw_kernel_params.dilW = 1;

    synTensor top_l_2_linear_dedw_in_vec[2] = {top_l_2_relu_grad_input, top_l_0_relu_output};


    // create top_l_2_linear_weight_grad tensor
    const unsigned top_l_2_linear_weight_grad_sizes[] = {1, 1, 1024, 1024};
    uint64_t top_l_2_linear_weight_grad_dram;
    unsigned top_l_2_linear_weight_grad_size = 1*1*1024*1024;
    unsigned top_l_2_linear_weight_grad_size_in_bytes = top_l_2_linear_weight_grad_size * sizeof(float) ;
    status = hbmAlloc(top_l_2_linear_weight_grad_size_in_bytes, &top_l_2_linear_weight_grad_dram, "top_l_2_linear_weight_grad");
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_weight_grad dram malloc failed!");
    synLaunchTensorInfo top_l_2_linear_weight_grad_tr_info = {"top_l_2_linear_weight_grad",
                                                              top_l_2_linear_weight_grad_dram};
    UNUSED(top_l_2_linear_weight_grad_tr_info); // For single op tests
    synTensor top_l_2_linear_weight_grad = createTensor(4U, syn_type_single, top_l_2_linear_weight_grad_sizes, true, "top_l_2_linear_weight_grad");
    UNUSED(top_l_2_linear_weight_grad); // For single op tests

    synTensor top_l_2_linear_dedw_out_vec[1] = {top_l_2_linear_weight_grad};


    status = synNodeCreate(graphHandle, top_l_2_linear_dedw_in_vec, top_l_2_linear_dedw_out_vec, 2, 1, (void *)&top_l_2_linear_dedw_kernel_params, sizeof(top_l_2_linear_dedw_kernel_params), "dedw", "top_l_2_linear_dedw", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_2_linear_dedw failed!");

    /*************
     * top_l_2_linear_dedb_top_l_2_relu_grad_input_reshape node
     * inputs: [top_l_2_relu_grad_input(128, 1, 1, 1024)(dtype=bf16)]
     * output: [top_l_2_linear_dedb_top_l_2_relu_grad_input_tensor_reshape(128, 1024)(dtype=bf16)]
     *************/

    synTensor top_l_2_linear_dedb_top_l_2_relu_grad_input_reshape_in_vec[1] = {top_l_2_relu_grad_input};


    // create top_l_2_linear_dedb_top_l_2_relu_grad_input_tensor_reshape tensor
    const unsigned top_l_2_linear_dedb_top_l_2_relu_grad_input_tensor_reshape_sizes[] = {128, 1024};
    synTensor top_l_2_linear_dedb_top_l_2_relu_grad_input_tensor_reshape = createTensor(2U, syn_type_bf16, top_l_2_linear_dedb_top_l_2_relu_grad_input_tensor_reshape_sizes, false, "top_l_2_linear_dedb_top_l_2_relu_grad_input_tensor_reshape");
    UNUSED(top_l_2_linear_dedb_top_l_2_relu_grad_input_tensor_reshape); // For single op tests

    synTensor top_l_2_linear_dedb_top_l_2_relu_grad_input_reshape_out_vec[1] = {top_l_2_linear_dedb_top_l_2_relu_grad_input_tensor_reshape};


    status = synNodeCreate(graphHandle, top_l_2_linear_dedb_top_l_2_relu_grad_input_reshape_in_vec, top_l_2_linear_dedb_top_l_2_relu_grad_input_reshape_out_vec, 1, 1, nullptr, 0, "reshape", "top_l_2_linear_dedb_top_l_2_relu_grad_input_reshape", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_2_linear_dedb_top_l_2_relu_grad_input_reshape failed!");

    /*************
     * top_l_2_linear_dedb node
     * inputs: [top_l_2_linear_dedb_top_l_2_relu_grad_input_tensor_reshape(128, 1024)(dtype=bf16)]
     * output: [top_l_2_linear_bias_grad(1024,)(dtype=float32)]
     *************/
    ns_Reduction::Params top_l_2_linear_dedb_kernel_params;
    top_l_2_linear_dedb_kernel_params.reductionDimension = 1;

    synTensor top_l_2_linear_dedb_in_vec[1] = {top_l_2_linear_dedb_top_l_2_relu_grad_input_tensor_reshape};


    // create top_l_2_linear_bias_grad tensor
    const unsigned top_l_2_linear_bias_grad_sizes[] = {1024,};
    uint64_t top_l_2_linear_bias_grad_dram;
    unsigned top_l_2_linear_bias_grad_size = 1024;
    unsigned top_l_2_linear_bias_grad_size_in_bytes = top_l_2_linear_bias_grad_size * sizeof(float) ;
    status = hbmAlloc(top_l_2_linear_bias_grad_size_in_bytes, &top_l_2_linear_bias_grad_dram, "top_l_2_linear_bias_grad");
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_bias_grad dram malloc failed!");
    synLaunchTensorInfo top_l_2_linear_bias_grad_tr_info = {"top_l_2_linear_bias_grad", top_l_2_linear_bias_grad_dram};
    UNUSED(top_l_2_linear_bias_grad_tr_info); // For single op tests
    synTensor top_l_2_linear_bias_grad = createTensor(1U, syn_type_single, top_l_2_linear_bias_grad_sizes, true, "top_l_2_linear_bias_grad");
    UNUSED(top_l_2_linear_bias_grad); // For single op tests

    synTensor top_l_2_linear_dedb_out_vec[1] = {top_l_2_linear_bias_grad};


    status = synNodeCreate(graphHandle, top_l_2_linear_dedb_in_vec, top_l_2_linear_dedb_out_vec, 1, 1, (void *)&top_l_2_linear_dedb_kernel_params, sizeof(top_l_2_linear_dedb_kernel_params), "reduce_sum_fwd_bf16", "top_l_2_linear_dedb", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_2_linear_dedb failed!");

    /*************
     * top_l_0_relu_bwd node
     * inputs: [top_l_2_linear_grad_input(128, 1, 1, 1024)(dtype=bf16), top_l_0_relu_output(128, 1, 1, 1024)(dtype=bf16)]
     * output: [top_l_0_relu_grad_input(128, 1, 1, 1024)(dtype=bf16)]
     *************/

    synTensor top_l_0_relu_bwd_in_vec[2] = {top_l_2_linear_grad_input, top_l_0_relu_output};


    // create top_l_0_relu_grad_input tensor
    const unsigned top_l_0_relu_grad_input_sizes[] = {128, 1, 1, 1024};
    synTensor top_l_0_relu_grad_input = createTensor(4U, syn_type_bf16, top_l_0_relu_grad_input_sizes, false, "top_l_0_relu_grad_input");
    UNUSED(top_l_0_relu_grad_input); // For single op tests

    synTensor top_l_0_relu_bwd_out_vec[1] = {top_l_0_relu_grad_input};


    status = synNodeCreate(graphHandle, top_l_0_relu_bwd_in_vec, top_l_0_relu_bwd_out_vec, 2, 1, nullptr, 0, "relu_bwd_bf16", "top_l_0_relu_bwd", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_0_relu_bwd failed!");

    /*************
     * top_l_0_linear_dedx node
     * inputs: [top_l_0_relu_grad_input(128, 1, 1, 1024)(dtype=bf16), top_l_0_linear_weight(1, 1, 383, 1024)(dtype=bf16)]
     * output: [top_l_0_linear_grad_input(128, 1, 1, 383)(dtype=bf16)]
     *************/
    synConvolutionParams top_l_0_linear_dedx_kernel_params;
    top_l_0_linear_dedx_kernel_params.dH = 1;
    top_l_0_linear_dedx_kernel_params.dW = 1;
    top_l_0_linear_dedx_kernel_params.kH = 1;
    top_l_0_linear_dedx_kernel_params.kW = 1;
    top_l_0_linear_dedx_kernel_params.padT = 0;
    top_l_0_linear_dedx_kernel_params.padB = 0;
    top_l_0_linear_dedx_kernel_params.padL = 0;
    top_l_0_linear_dedx_kernel_params.padR = 0;
    top_l_0_linear_dedx_kernel_params.dilH = 1;
    top_l_0_linear_dedx_kernel_params.dilW = 1;

    synTensor top_l_0_linear_dedx_in_vec[2] = {top_l_0_relu_grad_input, top_l_0_linear_weight};


    // create top_l_0_linear_grad_input tensor
    const unsigned top_l_0_linear_grad_input_sizes[] = {128, 1, 1, 383};
    uint64_t top_l_0_linear_grad_input_dram;
    unsigned top_l_0_linear_grad_input_size = 128*1*1*383;
    unsigned top_l_0_linear_grad_input_size_in_bytes = top_l_0_linear_grad_input_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_0_linear_grad_input_size_in_bytes, &top_l_0_linear_grad_input_dram, "top_l_0_linear_grad_input");
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_grad_input dram malloc failed!");
    synLaunchTensorInfo top_l_0_linear_grad_input_tr_info = {"top_l_0_linear_grad_input",
                                                             top_l_0_linear_grad_input_dram};
    UNUSED(top_l_0_linear_grad_input_tr_info); // For single op tests
    synTensor top_l_0_linear_grad_input = createTensor(4U, syn_type_bf16, top_l_0_linear_grad_input_sizes, true, "top_l_0_linear_grad_input");
    UNUSED(top_l_0_linear_grad_input); // For single op tests

    synTensor top_l_0_linear_dedx_out_vec[1] = {top_l_0_linear_grad_input};


    status = synNodeCreate(graphHandle, top_l_0_linear_dedx_in_vec, top_l_0_linear_dedx_out_vec, 2, 1, (void *)&top_l_0_linear_dedx_kernel_params, sizeof(top_l_0_linear_dedx_kernel_params), "dedx", "top_l_0_linear_dedx", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_0_linear_dedx failed!");

    /*************
     * top_l_0_linear_dedw_concat_interact1_output_reshape node
     * inputs: [concat_interact1_output(128, 383)(dtype=bf16)]
     * output: [top_l_0_linear_dedw_concat_interact1_output_tensor_reshape(128, 1, 1, 383)(dtype=bf16)]
     *************/

    synTensor top_l_0_linear_dedw_concat_interact1_output_reshape_in_vec[1] = {concat_interact1_output};


    // create top_l_0_linear_dedw_concat_interact1_output_tensor_reshape tensor
    const unsigned top_l_0_linear_dedw_concat_interact1_output_tensor_reshape_sizes[] = {128, 1, 1, 383};
    synTensor top_l_0_linear_dedw_concat_interact1_output_tensor_reshape = createTensor(4U, syn_type_bf16, top_l_0_linear_dedw_concat_interact1_output_tensor_reshape_sizes, false, "top_l_0_linear_dedw_concat_interact1_output_tensor_reshape");
    UNUSED(top_l_0_linear_dedw_concat_interact1_output_tensor_reshape); // For single op tests

    synTensor top_l_0_linear_dedw_concat_interact1_output_reshape_out_vec[1] = {top_l_0_linear_dedw_concat_interact1_output_tensor_reshape};


    status = synNodeCreate(graphHandle, top_l_0_linear_dedw_concat_interact1_output_reshape_in_vec, top_l_0_linear_dedw_concat_interact1_output_reshape_out_vec, 1, 1, nullptr, 0, "reshape", "top_l_0_linear_dedw_concat_interact1_output_reshape", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_0_linear_dedw_concat_interact1_output_reshape failed!");

    /*************
     * top_l_0_linear_dedw node
     * inputs: [top_l_0_relu_grad_input(128, 1, 1, 1024)(dtype=bf16), top_l_0_linear_dedw_concat_interact1_output_tensor_reshape(128, 1, 1, 383)(dtype=bf16)]
     * output: [top_l_0_linear_weight_grad(1, 1, 383, 1024)(dtype=float32)]
     *************/
    synConvolutionParams top_l_0_linear_dedw_kernel_params;
    top_l_0_linear_dedw_kernel_params.dH = 1;
    top_l_0_linear_dedw_kernel_params.dW = 1;
    top_l_0_linear_dedw_kernel_params.kH = 1;
    top_l_0_linear_dedw_kernel_params.kW = 1;
    top_l_0_linear_dedw_kernel_params.padT = 0;
    top_l_0_linear_dedw_kernel_params.padB = 0;
    top_l_0_linear_dedw_kernel_params.padL = 0;
    top_l_0_linear_dedw_kernel_params.padR = 0;
    top_l_0_linear_dedw_kernel_params.dilH = 1;
    top_l_0_linear_dedw_kernel_params.dilW = 1;

    synTensor top_l_0_linear_dedw_in_vec[2] = {top_l_0_relu_grad_input, top_l_0_linear_dedw_concat_interact1_output_tensor_reshape};


    // create top_l_0_linear_weight_grad tensor
    const unsigned top_l_0_linear_weight_grad_sizes[] = {1, 1, 383, 1024};
    uint64_t top_l_0_linear_weight_grad_dram;
    unsigned top_l_0_linear_weight_grad_size = 1*1*383*1024;
    unsigned top_l_0_linear_weight_grad_size_in_bytes = top_l_0_linear_weight_grad_size * sizeof(float) ;
    status = hbmAlloc(top_l_0_linear_weight_grad_size_in_bytes, &top_l_0_linear_weight_grad_dram, "top_l_0_linear_weight_grad");
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_weight_grad dram malloc failed!");
    synLaunchTensorInfo top_l_0_linear_weight_grad_tr_info = {"top_l_0_linear_weight_grad",
                                                              top_l_0_linear_weight_grad_dram};
    UNUSED(top_l_0_linear_weight_grad_tr_info); // For single op tests
    synTensor top_l_0_linear_weight_grad = createTensor(4U, syn_type_single, top_l_0_linear_weight_grad_sizes, true, "top_l_0_linear_weight_grad");
    UNUSED(top_l_0_linear_weight_grad); // For single op tests

    synTensor top_l_0_linear_dedw_out_vec[1] = {top_l_0_linear_weight_grad};


    status = synNodeCreate(graphHandle, top_l_0_linear_dedw_in_vec, top_l_0_linear_dedw_out_vec, 2, 1, (void *)&top_l_0_linear_dedw_kernel_params, sizeof(top_l_0_linear_dedw_kernel_params), "dedw", "top_l_0_linear_dedw", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_0_linear_dedw failed!");

    /*************
     * top_l_0_linear_dedb_top_l_0_relu_grad_input_reshape node
     * inputs: [top_l_0_relu_grad_input(128, 1, 1, 1024)(dtype=bf16)]
     * output: [top_l_0_linear_dedb_top_l_0_relu_grad_input_tensor_reshape(128, 1024)(dtype=bf16)]
     *************/

    synTensor top_l_0_linear_dedb_top_l_0_relu_grad_input_reshape_in_vec[1] = {top_l_0_relu_grad_input};


    // create top_l_0_linear_dedb_top_l_0_relu_grad_input_tensor_reshape tensor
    const unsigned top_l_0_linear_dedb_top_l_0_relu_grad_input_tensor_reshape_sizes[] = {128, 1024};
    synTensor top_l_0_linear_dedb_top_l_0_relu_grad_input_tensor_reshape = createTensor(2U, syn_type_bf16, top_l_0_linear_dedb_top_l_0_relu_grad_input_tensor_reshape_sizes, false, "top_l_0_linear_dedb_top_l_0_relu_grad_input_tensor_reshape");
    UNUSED(top_l_0_linear_dedb_top_l_0_relu_grad_input_tensor_reshape); // For single op tests

    synTensor top_l_0_linear_dedb_top_l_0_relu_grad_input_reshape_out_vec[1] = {top_l_0_linear_dedb_top_l_0_relu_grad_input_tensor_reshape};


    status = synNodeCreate(graphHandle, top_l_0_linear_dedb_top_l_0_relu_grad_input_reshape_in_vec, top_l_0_linear_dedb_top_l_0_relu_grad_input_reshape_out_vec, 1, 1, nullptr, 0, "reshape", "top_l_0_linear_dedb_top_l_0_relu_grad_input_reshape", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_0_linear_dedb_top_l_0_relu_grad_input_reshape failed!");

    /*************
     * top_l_0_linear_dedb node
     * inputs: [top_l_0_linear_dedb_top_l_0_relu_grad_input_tensor_reshape(128, 1024)(dtype=bf16)]
     * output: [top_l_0_linear_bias_grad(1024,)(dtype=float32)]
     *************/
    ns_Reduction::Params top_l_0_linear_dedb_kernel_params;
    top_l_0_linear_dedb_kernel_params.reductionDimension = 1;

    synTensor top_l_0_linear_dedb_in_vec[1] = {top_l_0_linear_dedb_top_l_0_relu_grad_input_tensor_reshape};


    // create top_l_0_linear_bias_grad tensor
    const unsigned top_l_0_linear_bias_grad_sizes[] = {1024,};
    uint64_t top_l_0_linear_bias_grad_dram;
    unsigned top_l_0_linear_bias_grad_size = 1024;
    unsigned top_l_0_linear_bias_grad_size_in_bytes = top_l_0_linear_bias_grad_size * sizeof(float) ;
    status = hbmAlloc(top_l_0_linear_bias_grad_size_in_bytes, &top_l_0_linear_bias_grad_dram, "top_l_0_linear_bias_grad");
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_bias_grad dram malloc failed!");
    synLaunchTensorInfo top_l_0_linear_bias_grad_tr_info = {"top_l_0_linear_bias_grad", top_l_0_linear_bias_grad_dram};
    UNUSED(top_l_0_linear_bias_grad_tr_info); // For single op tests
    synTensor top_l_0_linear_bias_grad = createTensor(1U, syn_type_single, top_l_0_linear_bias_grad_sizes, true, "top_l_0_linear_bias_grad");
    UNUSED(top_l_0_linear_bias_grad); // For single op tests

    synTensor top_l_0_linear_dedb_out_vec[1] = {top_l_0_linear_bias_grad};


    status = synNodeCreate(graphHandle, top_l_0_linear_dedb_in_vec, top_l_0_linear_dedb_out_vec, 1, 1, (void *)&top_l_0_linear_dedb_kernel_params, sizeof(top_l_0_linear_dedb_kernel_params), "reduce_sum_fwd_bf16", "top_l_0_linear_dedb", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_0_linear_dedb failed!");

    /*************
     * concat_interact1_dedx_top_l_0_linear_grad_input_reshape node
     * inputs: [top_l_0_linear_grad_input(128, 1, 1, 383)(dtype=bf16)]
     * output: [concat_interact1_dedx_top_l_0_linear_grad_input_tensor_reshape(128, 383)(dtype=bf16)]
     *************/

    synTensor concat_interact1_dedx_top_l_0_linear_grad_input_reshape_in_vec[1] = {top_l_0_linear_grad_input};


    // create concat_interact1_dedx_top_l_0_linear_grad_input_tensor_reshape tensor
    const unsigned concat_interact1_dedx_top_l_0_linear_grad_input_tensor_reshape_sizes[] = {128, 383};
    uint64_t concat_interact1_dedx_top_l_0_linear_grad_input_tensor_reshape_dram;
    unsigned concat_interact1_dedx_top_l_0_linear_grad_input_tensor_reshape_size = 128*383;
    unsigned concat_interact1_dedx_top_l_0_linear_grad_input_tensor_reshape_size_in_bytes = concat_interact1_dedx_top_l_0_linear_grad_input_tensor_reshape_size * sizeof(bfloat16) ;
    status = hbmAlloc(concat_interact1_dedx_top_l_0_linear_grad_input_tensor_reshape_size_in_bytes, &concat_interact1_dedx_top_l_0_linear_grad_input_tensor_reshape_dram, "concat_interact1_dedx_top_l_0_linear_grad_input_tensor_reshape");
    ASSERT_TRUE(status == synSuccess && "concat_interact1_dedx_top_l_0_linear_grad_input_tensor_reshape dram malloc failed!");
    synLaunchTensorInfo concat_interact1_dedx_top_l_0_linear_grad_input_tensor_reshape_tr_info = {
        "concat_interact1_dedx_top_l_0_linear_grad_input_tensor_reshape",
        concat_interact1_dedx_top_l_0_linear_grad_input_tensor_reshape_dram};
    UNUSED(concat_interact1_dedx_top_l_0_linear_grad_input_tensor_reshape_tr_info); // For single op tests
    synTensor concat_interact1_dedx_top_l_0_linear_grad_input_tensor_reshape = createTensor(2U, syn_type_bf16, concat_interact1_dedx_top_l_0_linear_grad_input_tensor_reshape_sizes, true, "concat_interact1_dedx_top_l_0_linear_grad_input_tensor_reshape");
    UNUSED(concat_interact1_dedx_top_l_0_linear_grad_input_tensor_reshape); // For single op tests

    synTensor concat_interact1_dedx_top_l_0_linear_grad_input_reshape_out_vec[1] = {concat_interact1_dedx_top_l_0_linear_grad_input_tensor_reshape};


    status = synNodeCreate(graphHandle, concat_interact1_dedx_top_l_0_linear_grad_input_reshape_in_vec, concat_interact1_dedx_top_l_0_linear_grad_input_reshape_out_vec, 1, 1, nullptr, 0, "reshape", "concat_interact1_dedx_top_l_0_linear_grad_input_reshape", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for concat_interact1_dedx_top_l_0_linear_grad_input_reshape failed!");

    /*************
     * concat_interact1_dedx node
     * inputs: [concat_interact1_dedx_top_l_0_linear_grad_input_tensor_reshape(128, 383)(dtype=bf16)]
     * output: [concat_interact1_grad_input0(128, 32)(dtype=bf16), concat_interact1_grad_input1(128, 351)(dtype=bf16)]
     *************/
    unsigned concat_interact1_dedx_kernel_params;
    concat_interact1_dedx_kernel_params = 0;

    synTensor concat_interact1_dedx_in_vec[1] = {concat_interact1_dedx_top_l_0_linear_grad_input_tensor_reshape};


    // create concat_interact1_grad_input0 tensor
    const unsigned concat_interact1_grad_input0_sizes[] = {128, 32};
    synTensor concat_interact1_grad_input0 = createTensor(2U, syn_type_bf16, concat_interact1_grad_input0_sizes, false, "concat_interact1_grad_input0");
    UNUSED(concat_interact1_grad_input0); // For single op tests

    // create concat_interact1_grad_input1 tensor
    const unsigned concat_interact1_grad_input1_sizes[] = {128, 351};
    synTensor concat_interact1_grad_input1 = createTensor(2U, syn_type_bf16, concat_interact1_grad_input1_sizes, false, "concat_interact1_grad_input1");
    UNUSED(concat_interact1_grad_input1); // For single op tests

    synTensor concat_interact1_dedx_out_vec[2] = {concat_interact1_grad_input0, concat_interact1_grad_input1};


    status = synNodeCreate(graphHandle, concat_interact1_dedx_in_vec, concat_interact1_dedx_out_vec, 1, 2, (void *)&concat_interact1_dedx_kernel_params, sizeof(concat_interact1_dedx_kernel_params), "split", "concat_interact1_dedx", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for concat_interact1_dedx failed!");

    /*************
     * tril_indices_dedx node
     * inputs: [tril_grad_buffer[128, 729](dtype=bf16), tril_indices_broadcast[128, 351](dtype=int32), concat_interact1_grad_input1(128, 351)(dtype=bf16)]
     * output: [tril_indices_grad_input(128, 729)(dtype=bf16)]
     *************/
    ns_ScatterKernel::Params tril_indices_dedx_kernel_params;
    tril_indices_dedx_kernel_params.axis = 0;

    // create tril_grad_buffer tensor
    const unsigned tril_grad_buffer_sizes[] = {128, 729};
    uint64_t tril_grad_buffer_dram;
    unsigned tril_grad_buffer_size = 128*729;
    unsigned tril_grad_buffer_size_in_bytes = tril_grad_buffer_size * sizeof(bfloat16) ;
    status = hbmAlloc(tril_grad_buffer_size_in_bytes, &tril_grad_buffer_dram, "tril_grad_buffer");
    ASSERT_TRUE(status == synSuccess && "tril_grad_buffer dram malloc failed!");
    synLaunchTensorInfo tril_grad_buffer_tr_info = {"tril_grad_buffer", tril_grad_buffer_dram};
    UNUSED(tril_grad_buffer_tr_info); // For single op tests
    synTensor tril_grad_buffer = createTensor(2U, syn_type_bf16, tril_grad_buffer_sizes, true, "tril_grad_buffer");
    UNUSED(tril_grad_buffer); // For single op tests

    // create tril_indices_broadcast tensor
    const unsigned tril_indices_broadcast_sizes[] = {128, 351};
    uint64_t tril_indices_broadcast_dram;
    unsigned tril_indices_broadcast_size = 128*351;
    unsigned tril_indices_broadcast_size_in_bytes = tril_indices_broadcast_size * sizeof(int32_t) ;
    status = hbmAlloc(tril_indices_broadcast_size_in_bytes, &tril_indices_broadcast_dram, "tril_indices_broadcast");
    ASSERT_TRUE(status == synSuccess && "tril_indices_broadcast dram malloc failed!");
    synLaunchTensorInfo tril_indices_broadcast_tr_info = {"tril_indices_broadcast", tril_indices_broadcast_dram};
    UNUSED(tril_indices_broadcast_tr_info); // For single op tests
    synTensor tril_indices_broadcast = createTensor(2U, syn_type_int32, tril_indices_broadcast_sizes, true, "tril_indices_broadcast");
    UNUSED(tril_indices_broadcast); // For single op tests

    synTensor tril_indices_dedx_in_vec[3] = {tril_grad_buffer, tril_indices_broadcast, concat_interact1_grad_input1};


    // create tril_indices_grad_input tensor
    const unsigned tril_indices_grad_input_sizes[] = {128, 729};
    uint64_t tril_indices_grad_input_dram;
    unsigned tril_indices_grad_input_size = 128*729;
    unsigned tril_indices_grad_input_size_in_bytes = tril_indices_grad_input_size * sizeof(bfloat16) ;
    status = hbmAlloc(tril_indices_grad_input_size_in_bytes, &tril_indices_grad_input_dram, "tril_indices_grad_input");
    ASSERT_TRUE(status == synSuccess && "tril_indices_grad_input dram malloc failed!");
    synLaunchTensorInfo tril_indices_grad_input_tr_info = {"tril_indices_grad_input", tril_indices_grad_input_dram};
    UNUSED(tril_indices_grad_input_tr_info); // For single op tests
    synTensor tril_indices_grad_input = createTensor(2U, syn_type_bf16, tril_indices_grad_input_sizes, true, "tril_indices_grad_input");
    UNUSED(tril_indices_grad_input); // For single op tests

    synTensor tril_indices_dedx_out_vec[1] = {tril_indices_grad_input};


    status = synNodeCreate(graphHandle, tril_indices_dedx_in_vec, tril_indices_dedx_out_vec, 3, 1, (void *)&tril_indices_dedx_kernel_params, sizeof(tril_indices_dedx_kernel_params), "gather_bwd_bf16", "tril_indices_dedx", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for tril_indices_dedx failed!");

    /*************
     * reshape_tril_dedx node
     * inputs: [tril_indices_grad_input(128, 729)(dtype=bf16)]
     * output: [reshape_tril_grad_input(128, 27, 27)(dtype=bf16)]
     *************/

    synTensor reshape_tril_dedx_in_vec[1] = {tril_indices_grad_input};


    // create reshape_tril_grad_input tensor
    const unsigned reshape_tril_grad_input_sizes[] = {128, 27, 27};
    uint64_t reshape_tril_grad_input_dram;
    unsigned reshape_tril_grad_input_size = 128*27*27;
    unsigned reshape_tril_grad_input_size_in_bytes = reshape_tril_grad_input_size * sizeof(bfloat16) ;
    status = hbmAlloc(reshape_tril_grad_input_size_in_bytes, &reshape_tril_grad_input_dram, "reshape_tril_grad_input");
    ASSERT_TRUE(status == synSuccess && "reshape_tril_grad_input dram malloc failed!");
    synLaunchTensorInfo reshape_tril_grad_input_tr_info = {"reshape_tril_grad_input", reshape_tril_grad_input_dram};
    UNUSED(reshape_tril_grad_input_tr_info); // For single op tests
    synTensor reshape_tril_grad_input = createTensor(3U, syn_type_bf16, reshape_tril_grad_input_sizes, true, "reshape_tril_grad_input");
    UNUSED(reshape_tril_grad_input); // For single op tests

    synTensor reshape_tril_dedx_out_vec[1] = {reshape_tril_grad_input};


    status = synNodeCreate(graphHandle, reshape_tril_dedx_in_vec, reshape_tril_dedx_out_vec, 1, 1, nullptr, 0, "reshape", "reshape_tril_dedx", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for reshape_tril_dedx failed!");

    /*************
     * bmm_interact_dedx node
     * inputs: [reshape_tril_grad_input(128, 27, 27)(dtype=bf16), reshape_bmm_output(128, 27, 32)(dtype=bf16)]
     * output: [bmm_interact_grad_input0(128, 27, 32)(dtype=float32)]
     *************/
    synGEMMParams bmm_interact_dedx_kernel_params;
    bmm_interact_dedx_kernel_params.transpose_a = false;
    bmm_interact_dedx_kernel_params.transpose_b = true;

    synTensor bmm_interact_dedx_in_vec[2] = {reshape_tril_grad_input, reshape_bmm_output};


    // create bmm_interact_grad_input0 tensor
    const unsigned bmm_interact_grad_input0_sizes[] = {128, 27, 32};
    uint64_t bmm_interact_grad_input0_dram;
    unsigned bmm_interact_grad_input0_size = 128*27*32;
    unsigned bmm_interact_grad_input0_size_in_bytes = bmm_interact_grad_input0_size * sizeof(float) ;
    status = hbmAlloc(bmm_interact_grad_input0_size_in_bytes, &bmm_interact_grad_input0_dram, "bmm_interact_grad_input0");
    ASSERT_TRUE(status == synSuccess && "bmm_interact_grad_input0 dram malloc failed!");
    synLaunchTensorInfo bmm_interact_grad_input0_tr_info = {"bmm_interact_grad_input0", bmm_interact_grad_input0_dram};
    UNUSED(bmm_interact_grad_input0_tr_info); // For single op tests
    synTensor bmm_interact_grad_input0 = createTensor(3U, syn_type_single, bmm_interact_grad_input0_sizes, true, "bmm_interact_grad_input0");
    UNUSED(bmm_interact_grad_input0); // For single op tests

    synTensor bmm_interact_dedx_out_vec[1] = {bmm_interact_grad_input0};


    status = synNodeCreate(graphHandle, bmm_interact_dedx_in_vec, bmm_interact_dedx_out_vec, 2, 1, (void *)&bmm_interact_dedx_kernel_params, sizeof(bmm_interact_dedx_kernel_params), "batch_gemm_dedx", "bmm_interact_dedx", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bmm_interact_dedx failed!");

    /*************
     * bmm_interact_dedw node
     * inputs: [reshape_tril_grad_input(128, 27, 27)(dtype=bf16), reshape_bmm_output(128, 27, 32)(dtype=bf16)]
     * output: [bmm_interact_grad_input1(128, 32, 27)(dtype=float32)]
     *************/
    synGEMMParams bmm_interact_dedw_kernel_params;
    bmm_interact_dedw_kernel_params.transpose_a = true;
    bmm_interact_dedw_kernel_params.transpose_b = false;

    synTensor bmm_interact_dedw_in_vec[2] = {reshape_tril_grad_input, reshape_bmm_output};


    // create bmm_interact_grad_input1 tensor
    const unsigned bmm_interact_grad_input1_sizes[] = {128, 32, 27};
    synTensor bmm_interact_grad_input1 = createTensor(3U, syn_type_single, bmm_interact_grad_input1_sizes, false, "bmm_interact_grad_input1");
    UNUSED(bmm_interact_grad_input1); // For single op tests

    synTensor bmm_interact_dedw_out_vec[1] = {bmm_interact_grad_input1};


    status = synNodeCreate(graphHandle, bmm_interact_dedw_in_vec, bmm_interact_dedw_out_vec, 2, 1, (void *)&bmm_interact_dedw_kernel_params, sizeof(bmm_interact_dedw_kernel_params), "batch_gemm_dedw", "bmm_interact_dedw", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bmm_interact_dedw failed!");

    /*************
     * bmm_dedw_out_transpose node
     * inputs: [bmm_interact_grad_input1(128, 32, 27)(dtype=float32)]
     * output: [bmm_interact_grad_input1_transpose(128, 27, 32)(dtype=float32)]
     *************/
    ns_TransposeKernel::Params bmm_dedw_out_transpose_kernel_params;
    bmm_dedw_out_transpose_kernel_params.axes[0] = 1;
    bmm_dedw_out_transpose_kernel_params.axes[1] = 0;
    bmm_dedw_out_transpose_kernel_params.axes[2] = 2;
    bmm_dedw_out_transpose_kernel_params.axes[3] = 3;

    synTensor bmm_dedw_out_transpose_in_vec[1] = {bmm_interact_grad_input1};


    // create bmm_interact_grad_input1_transpose tensor
    const unsigned bmm_interact_grad_input1_transpose_sizes[] = {128, 27, 32};
    synTensor bmm_interact_grad_input1_transpose = createTensor(3U, syn_type_single, bmm_interact_grad_input1_transpose_sizes, false, "bmm_interact_grad_input1_transpose");
    UNUSED(bmm_interact_grad_input1_transpose); // For single op tests

    synTensor bmm_dedw_out_transpose_out_vec[1] = {bmm_interact_grad_input1_transpose};


    status = synNodeCreate(graphHandle, bmm_dedw_out_transpose_in_vec, bmm_dedw_out_transpose_out_vec, 1, 1, (void *)&bmm_dedw_out_transpose_kernel_params, sizeof(bmm_dedw_out_transpose_kernel_params), "transpose_fwd_f32", "bmm_dedw_out_transpose", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bmm_dedw_out_transpose failed!");

    /*************
     * add_grads_bmm node
     * inputs: [bmm_interact_grad_input0(128, 27, 32)(dtype=float32), bmm_interact_grad_input1_transpose(128, 27, 32)(dtype=float32)]
     * output: [add_grads_bmm_output(128, 27, 32)(dtype=float32)]
     *************/

    synTensor add_grads_bmm_in_vec[2] = {bmm_interact_grad_input0, bmm_interact_grad_input1_transpose};


    // create add_grads_bmm_output tensor
    const unsigned add_grads_bmm_output_sizes[] = {128, 27, 32};
    uint64_t add_grads_bmm_output_dram;
    unsigned add_grads_bmm_output_size = 128*27*32;
    unsigned add_grads_bmm_output_size_in_bytes = add_grads_bmm_output_size * sizeof(float) ;
    status = hbmAlloc(add_grads_bmm_output_size_in_bytes, &add_grads_bmm_output_dram, "add_grads_bmm_output");
    ASSERT_TRUE(status == synSuccess && "add_grads_bmm_output dram malloc failed!");
    synLaunchTensorInfo add_grads_bmm_output_tr_info = {"add_grads_bmm_output", add_grads_bmm_output_dram};
    UNUSED(add_grads_bmm_output_tr_info); // For single op tests
    synTensor add_grads_bmm_output = createTensor(3U, syn_type_single, add_grads_bmm_output_sizes, true, "add_grads_bmm_output");
    UNUSED(add_grads_bmm_output); // For single op tests

    synTensor add_grads_bmm_out_vec[1] = {add_grads_bmm_output};


    status = synNodeCreate(graphHandle, add_grads_bmm_in_vec, add_grads_bmm_out_vec, 2, 1, nullptr, 0, "add_fwd_f32", "add_grads_bmm", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for add_grads_bmm failed!");

    /*************
     * reshape_bmm_dedx node
     * inputs: [add_grads_bmm_output(128, 27, 32)(dtype=float32)]
     * output: [reshape_bmm_grad_input(128, 864)(dtype=float32)]
     *************/

    synTensor reshape_bmm_dedx_in_vec[1] = {add_grads_bmm_output};


    // create reshape_bmm_grad_input tensor
    const unsigned reshape_bmm_grad_input_sizes[] = {128, 864};
    synTensor reshape_bmm_grad_input = createTensor(2U, syn_type_single, reshape_bmm_grad_input_sizes, false, "reshape_bmm_grad_input");
    UNUSED(reshape_bmm_grad_input); // For single op tests

    synTensor reshape_bmm_dedx_out_vec[1] = {reshape_bmm_grad_input};


    status = synNodeCreate(graphHandle, reshape_bmm_dedx_in_vec, reshape_bmm_dedx_out_vec, 1, 1, nullptr, 0, "reshape", "reshape_bmm_dedx", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for reshape_bmm_dedx failed!");

    /*************
     * concat_interact0_dedx node
     * inputs: [reshape_bmm_grad_input(128, 864)(dtype=float32)]
     * output: [concat_interact0_grad_input0(128, 32)(dtype=float32), concat_interact0_grad_input1(128, 32)(dtype=float32), concat_interact0_grad_input2(128, 32)(dtype=float32), concat_interact0_grad_input3(128, 32)(dtype=float32), concat_interact0_grad_input4(128, 32)(dtype=float32), concat_interact0_grad_input5(128, 32)(dtype=float32), concat_interact0_grad_input6(128, 32)(dtype=float32), concat_interact0_grad_input7(128, 32)(dtype=float32), concat_interact0_grad_input8(128, 32)(dtype=float32), concat_interact0_grad_input9(128, 32)(dtype=float32), concat_interact0_grad_input10(128, 32)(dtype=float32), concat_interact0_grad_input11(128, 32)(dtype=float32), concat_interact0_grad_input12(128, 32)(dtype=float32), concat_interact0_grad_input13(128, 32)(dtype=float32), concat_interact0_grad_input14(128, 32)(dtype=float32), concat_interact0_grad_input15(128, 32)(dtype=float32), concat_interact0_grad_input16(128, 32)(dtype=float32), concat_interact0_grad_input17(128, 32)(dtype=float32), concat_interact0_grad_input18(128, 32)(dtype=float32), concat_interact0_grad_input19(128, 32)(dtype=float32), concat_interact0_grad_input20(128, 32)(dtype=float32), concat_interact0_grad_input21(128, 32)(dtype=float32), concat_interact0_grad_input22(128, 32)(dtype=float32), concat_interact0_grad_input23(128, 32)(dtype=float32), concat_interact0_grad_input24(128, 32)(dtype=float32), concat_interact0_grad_input25(128, 32)(dtype=float32), concat_interact0_grad_input26(128, 32)(dtype=float32)]
     *************/
    unsigned concat_interact0_dedx_kernel_params;
    concat_interact0_dedx_kernel_params = 0;

    synTensor concat_interact0_dedx_in_vec[1] = {reshape_bmm_grad_input};


    // create concat_interact0_grad_input0 tensor
    const unsigned concat_interact0_grad_input0_sizes[] = {128, 32};
    synTensor concat_interact0_grad_input0 = createTensor(2U, syn_type_single, concat_interact0_grad_input0_sizes, false, "concat_interact0_grad_input0");
    UNUSED(concat_interact0_grad_input0); // For single op tests

    // create concat_interact0_grad_input1 tensor
    const unsigned concat_interact0_grad_input1_sizes[] = {128, 32};
    synTensor concat_interact0_grad_input1 = createTensor(2U, syn_type_single, concat_interact0_grad_input1_sizes, false, "concat_interact0_grad_input1");
    UNUSED(concat_interact0_grad_input1); // For single op tests

    // create concat_interact0_grad_input2 tensor
    const unsigned concat_interact0_grad_input2_sizes[] = {128, 32};
    synTensor concat_interact0_grad_input2 = createTensor(2U, syn_type_single, concat_interact0_grad_input2_sizes, false, "concat_interact0_grad_input2");
    UNUSED(concat_interact0_grad_input2); // For single op tests

    // create concat_interact0_grad_input3 tensor
    const unsigned concat_interact0_grad_input3_sizes[] = {128, 32};
    synTensor concat_interact0_grad_input3 = createTensor(2U, syn_type_single, concat_interact0_grad_input3_sizes, false, "concat_interact0_grad_input3");
    UNUSED(concat_interact0_grad_input3); // For single op tests

    // create concat_interact0_grad_input4 tensor
    const unsigned concat_interact0_grad_input4_sizes[] = {128, 32};
    synTensor concat_interact0_grad_input4 = createTensor(2U, syn_type_single, concat_interact0_grad_input4_sizes, false, "concat_interact0_grad_input4");
    UNUSED(concat_interact0_grad_input4); // For single op tests

    // create concat_interact0_grad_input5 tensor
    const unsigned concat_interact0_grad_input5_sizes[] = {128, 32};
    synTensor concat_interact0_grad_input5 = createTensor(2U, syn_type_single, concat_interact0_grad_input5_sizes, false, "concat_interact0_grad_input5");
    UNUSED(concat_interact0_grad_input5); // For single op tests

    // create concat_interact0_grad_input6 tensor
    const unsigned concat_interact0_grad_input6_sizes[] = {128, 32};
    synTensor concat_interact0_grad_input6 = createTensor(2U, syn_type_single, concat_interact0_grad_input6_sizes, false, "concat_interact0_grad_input6");
    UNUSED(concat_interact0_grad_input6); // For single op tests

    // create concat_interact0_grad_input7 tensor
    const unsigned concat_interact0_grad_input7_sizes[] = {128, 32};
    synTensor concat_interact0_grad_input7 = createTensor(2U, syn_type_single, concat_interact0_grad_input7_sizes, false, "concat_interact0_grad_input7");
    UNUSED(concat_interact0_grad_input7); // For single op tests

    // create concat_interact0_grad_input8 tensor
    const unsigned concat_interact0_grad_input8_sizes[] = {128, 32};
    synTensor concat_interact0_grad_input8 = createTensor(2U, syn_type_single, concat_interact0_grad_input8_sizes, false, "concat_interact0_grad_input8");
    UNUSED(concat_interact0_grad_input8); // For single op tests

    // create concat_interact0_grad_input9 tensor
    const unsigned concat_interact0_grad_input9_sizes[] = {128, 32};
    synTensor concat_interact0_grad_input9 = createTensor(2U, syn_type_single, concat_interact0_grad_input9_sizes, false, "concat_interact0_grad_input9");
    UNUSED(concat_interact0_grad_input9); // For single op tests

    // create concat_interact0_grad_input10 tensor
    const unsigned concat_interact0_grad_input10_sizes[] = {128, 32};
    synTensor concat_interact0_grad_input10 = createTensor(2U, syn_type_single, concat_interact0_grad_input10_sizes, false, "concat_interact0_grad_input10");
    UNUSED(concat_interact0_grad_input10); // For single op tests

    // create concat_interact0_grad_input11 tensor
    const unsigned concat_interact0_grad_input11_sizes[] = {128, 32};
    synTensor concat_interact0_grad_input11 = createTensor(2U, syn_type_single, concat_interact0_grad_input11_sizes, false, "concat_interact0_grad_input11");
    UNUSED(concat_interact0_grad_input11); // For single op tests

    // create concat_interact0_grad_input12 tensor
    const unsigned concat_interact0_grad_input12_sizes[] = {128, 32};
    synTensor concat_interact0_grad_input12 = createTensor(2U, syn_type_single, concat_interact0_grad_input12_sizes, false, "concat_interact0_grad_input12");
    UNUSED(concat_interact0_grad_input12); // For single op tests

    // create concat_interact0_grad_input13 tensor
    const unsigned concat_interact0_grad_input13_sizes[] = {128, 32};
    synTensor concat_interact0_grad_input13 = createTensor(2U, syn_type_single, concat_interact0_grad_input13_sizes, false, "concat_interact0_grad_input13");
    UNUSED(concat_interact0_grad_input13); // For single op tests

    // create concat_interact0_grad_input14 tensor
    const unsigned concat_interact0_grad_input14_sizes[] = {128, 32};
    synTensor concat_interact0_grad_input14 = createTensor(2U, syn_type_single, concat_interact0_grad_input14_sizes, false, "concat_interact0_grad_input14");
    UNUSED(concat_interact0_grad_input14); // For single op tests

    // create concat_interact0_grad_input15 tensor
    const unsigned concat_interact0_grad_input15_sizes[] = {128, 32};
    synTensor concat_interact0_grad_input15 = createTensor(2U, syn_type_single, concat_interact0_grad_input15_sizes, false, "concat_interact0_grad_input15");
    UNUSED(concat_interact0_grad_input15); // For single op tests

    // create concat_interact0_grad_input16 tensor
    const unsigned concat_interact0_grad_input16_sizes[] = {128, 32};
    synTensor concat_interact0_grad_input16 = createTensor(2U, syn_type_single, concat_interact0_grad_input16_sizes, false, "concat_interact0_grad_input16");
    UNUSED(concat_interact0_grad_input16); // For single op tests

    // create concat_interact0_grad_input17 tensor
    const unsigned concat_interact0_grad_input17_sizes[] = {128, 32};
    synTensor concat_interact0_grad_input17 = createTensor(2U, syn_type_single, concat_interact0_grad_input17_sizes, false, "concat_interact0_grad_input17");
    UNUSED(concat_interact0_grad_input17); // For single op tests

    // create concat_interact0_grad_input18 tensor
    const unsigned concat_interact0_grad_input18_sizes[] = {128, 32};
    synTensor concat_interact0_grad_input18 = createTensor(2U, syn_type_single, concat_interact0_grad_input18_sizes, false, "concat_interact0_grad_input18");
    UNUSED(concat_interact0_grad_input18); // For single op tests

    // create concat_interact0_grad_input19 tensor
    const unsigned concat_interact0_grad_input19_sizes[] = {128, 32};
    synTensor concat_interact0_grad_input19 = createTensor(2U, syn_type_single, concat_interact0_grad_input19_sizes, false, "concat_interact0_grad_input19");
    UNUSED(concat_interact0_grad_input19); // For single op tests

    // create concat_interact0_grad_input20 tensor
    const unsigned concat_interact0_grad_input20_sizes[] = {128, 32};
    synTensor concat_interact0_grad_input20 = createTensor(2U, syn_type_single, concat_interact0_grad_input20_sizes, false, "concat_interact0_grad_input20");
    UNUSED(concat_interact0_grad_input20); // For single op tests

    // create concat_interact0_grad_input21 tensor
    const unsigned concat_interact0_grad_input21_sizes[] = {128, 32};
    synTensor concat_interact0_grad_input21 = createTensor(2U, syn_type_single, concat_interact0_grad_input21_sizes, false, "concat_interact0_grad_input21");
    UNUSED(concat_interact0_grad_input21); // For single op tests

    // create concat_interact0_grad_input22 tensor
    const unsigned concat_interact0_grad_input22_sizes[] = {128, 32};
    synTensor concat_interact0_grad_input22 = createTensor(2U, syn_type_single, concat_interact0_grad_input22_sizes, false, "concat_interact0_grad_input22");
    UNUSED(concat_interact0_grad_input22); // For single op tests

    // create concat_interact0_grad_input23 tensor
    const unsigned concat_interact0_grad_input23_sizes[] = {128, 32};
    synTensor concat_interact0_grad_input23 = createTensor(2U, syn_type_single, concat_interact0_grad_input23_sizes, false, "concat_interact0_grad_input23");
    UNUSED(concat_interact0_grad_input23); // For single op tests

    // create concat_interact0_grad_input24 tensor
    const unsigned concat_interact0_grad_input24_sizes[] = {128, 32};
    synTensor concat_interact0_grad_input24 = createTensor(2U, syn_type_single, concat_interact0_grad_input24_sizes, false, "concat_interact0_grad_input24");
    UNUSED(concat_interact0_grad_input24); // For single op tests

    // create concat_interact0_grad_input25 tensor
    const unsigned concat_interact0_grad_input25_sizes[] = {128, 32};
    synTensor concat_interact0_grad_input25 = createTensor(2U, syn_type_single, concat_interact0_grad_input25_sizes, false, "concat_interact0_grad_input25");
    UNUSED(concat_interact0_grad_input25); // For single op tests

    // create concat_interact0_grad_input26 tensor
    const unsigned concat_interact0_grad_input26_sizes[] = {128, 32};
    synTensor concat_interact0_grad_input26 = createTensor(2U, syn_type_single, concat_interact0_grad_input26_sizes, false, "concat_interact0_grad_input26");
    UNUSED(concat_interact0_grad_input26); // For single op tests

    synTensor concat_interact0_dedx_out_vec[27] = {concat_interact0_grad_input0, concat_interact0_grad_input1, concat_interact0_grad_input2, concat_interact0_grad_input3, concat_interact0_grad_input4, concat_interact0_grad_input5, concat_interact0_grad_input6, concat_interact0_grad_input7, concat_interact0_grad_input8, concat_interact0_grad_input9, concat_interact0_grad_input10, concat_interact0_grad_input11, concat_interact0_grad_input12, concat_interact0_grad_input13, concat_interact0_grad_input14, concat_interact0_grad_input15, concat_interact0_grad_input16, concat_interact0_grad_input17, concat_interact0_grad_input18, concat_interact0_grad_input19, concat_interact0_grad_input20, concat_interact0_grad_input21, concat_interact0_grad_input22, concat_interact0_grad_input23, concat_interact0_grad_input24, concat_interact0_grad_input25, concat_interact0_grad_input26};


    status = synNodeCreate(graphHandle, concat_interact0_dedx_in_vec, concat_interact0_dedx_out_vec, 1, 27, (void *)&concat_interact0_dedx_kernel_params, sizeof(concat_interact0_dedx_kernel_params), "split", "concat_interact0_dedx", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for concat_interact0_dedx failed!");

    /*************
     * add_grads_concat_cast node
     * inputs: [concat_interact0_grad_input0(128, 32)(dtype=float32)]
     * output: [concat_interact0_grad_input0_cast_BF16[128, 32](dtype=bf16)]
     *************/

    synTensor add_grads_concat_cast_in_vec[1] = {concat_interact0_grad_input0};


    // create concat_interact0_grad_input0_cast_BF16 tensor
    const unsigned concat_interact0_grad_input0_cast_BF16_sizes[] = {128, 32};
    synTensor concat_interact0_grad_input0_cast_BF16 = createTensor(2U, syn_type_bf16, concat_interact0_grad_input0_cast_BF16_sizes, false, "concat_interact0_grad_input0_cast_BF16");
    UNUSED(concat_interact0_grad_input0_cast_BF16); // For single op tests

    synTensor add_grads_concat_cast_out_vec[1] = {concat_interact0_grad_input0_cast_BF16};


    status = synNodeCreate(graphHandle, add_grads_concat_cast_in_vec, add_grads_concat_cast_out_vec, 1, 1, nullptr, 0, "cast_f32_to_bf16", "add_grads_concat_cast", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for add_grads_concat_cast failed!");

    /*************
     * add_grads_concat node
     * inputs: [concat_interact1_grad_input0(128, 32)(dtype=bf16), concat_interact0_grad_input0_cast_BF16[128, 32](dtype=bf16)]
     * output: [add_grads_concat_output(128, 32)(dtype=bf16)]
     *************/

    synTensor add_grads_concat_in_vec[2] = {concat_interact1_grad_input0, concat_interact0_grad_input0_cast_BF16};


    // create add_grads_concat_output tensor
    const unsigned add_grads_concat_output_sizes[] = {128, 32};
    uint64_t add_grads_concat_output_dram;
    unsigned add_grads_concat_output_size = 128*32;
    unsigned add_grads_concat_output_size_in_bytes = add_grads_concat_output_size * sizeof(bfloat16) ;
    status = hbmAlloc(add_grads_concat_output_size_in_bytes, &add_grads_concat_output_dram, "add_grads_concat_output");
    ASSERT_TRUE(status == synSuccess && "add_grads_concat_output dram malloc failed!");
    synLaunchTensorInfo add_grads_concat_output_tr_info = {"add_grads_concat_output", add_grads_concat_output_dram};
    UNUSED(add_grads_concat_output_tr_info); // For single op tests
    synTensor add_grads_concat_output = createTensor(2U, syn_type_bf16, add_grads_concat_output_sizes, true, "add_grads_concat_output");
    UNUSED(add_grads_concat_output); // For single op tests

    synTensor add_grads_concat_out_vec[1] = {add_grads_concat_output};


    status = synNodeCreate(graphHandle, add_grads_concat_in_vec, add_grads_concat_out_vec, 2, 1, nullptr, 0, "add_fwd_bf16", "add_grads_concat", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for add_grads_concat failed!");

    /*************
     * emb_0_embbag_dedw_SLS node
     * inputs: [concat_interact0_grad_input1(128, 32)(dtype=float32), emb_0_embbag_dedw_grad_indices[128](dtype=int32), emb_0_embbag_dedw_lengths[128](dtype=int32), emb_0_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_0_embbag_dedw_grad_inter(128, 32)(dtype=float32)]
     *************/
    ns_SparseLengthsSum::Params emb_0_embbag_dedw_SLS_kernel_params;
    emb_0_embbag_dedw_SLS_kernel_params.mode = EMBEDDED_SC_ZP;

    // create emb_0_embbag_dedw_grad_indices tensor
    const unsigned emb_0_embbag_dedw_grad_indices_sizes[] = {128,};
    uint64_t emb_0_embbag_dedw_grad_indices_dram;
    unsigned emb_0_embbag_dedw_grad_indices_size = 128;
    unsigned emb_0_embbag_dedw_grad_indices_size_in_bytes = emb_0_embbag_dedw_grad_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_0_embbag_dedw_grad_indices_size_in_bytes, &emb_0_embbag_dedw_grad_indices_dram, "emb_0_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_dedw_grad_indices dram malloc failed!");
    synLaunchTensorInfo emb_0_embbag_dedw_grad_indices_tr_info = {"emb_0_embbag_dedw_grad_indices",
                                                                  emb_0_embbag_dedw_grad_indices_dram};
    UNUSED(emb_0_embbag_dedw_grad_indices_tr_info); // For single op tests
    synTensor emb_0_embbag_dedw_grad_indices = createTensor(1U, syn_type_int32, emb_0_embbag_dedw_grad_indices_sizes, true, "emb_0_embbag_dedw_grad_indices");
    UNUSED(emb_0_embbag_dedw_grad_indices); // For single op tests

    // create emb_0_embbag_dedw_lengths tensor
    const unsigned emb_0_embbag_dedw_lengths_sizes[] = {128,};
    uint64_t emb_0_embbag_dedw_lengths_dram;
    unsigned emb_0_embbag_dedw_lengths_size = 128;
    unsigned emb_0_embbag_dedw_lengths_size_in_bytes = emb_0_embbag_dedw_lengths_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_0_embbag_dedw_lengths_size_in_bytes, &emb_0_embbag_dedw_lengths_dram, "emb_0_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_dedw_lengths dram malloc failed!");
    synLaunchTensorInfo emb_0_embbag_dedw_lengths_tr_info = {"emb_0_embbag_dedw_lengths",
                                                             emb_0_embbag_dedw_lengths_dram};
    UNUSED(emb_0_embbag_dedw_lengths_tr_info); // For single op tests
    synTensor emb_0_embbag_dedw_lengths = createTensor(1U, syn_type_int32, emb_0_embbag_dedw_lengths_sizes, true, "emb_0_embbag_dedw_lengths");
    UNUSED(emb_0_embbag_dedw_lengths); // For single op tests

    // create emb_0_embbag_valid_indices tensor
    const unsigned emb_0_embbag_valid_indices_sizes[] = {1,};
    uint64_t emb_0_embbag_valid_indices_dram;
    unsigned emb_0_embbag_valid_indices_size = 1;
    unsigned emb_0_embbag_valid_indices_size_in_bytes = emb_0_embbag_valid_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_0_embbag_valid_indices_size_in_bytes, &emb_0_embbag_valid_indices_dram, "emb_0_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_valid_indices dram malloc failed!");
    synLaunchTensorInfo emb_0_embbag_valid_indices_tr_info = {"emb_0_embbag_valid_indices",
                                                              emb_0_embbag_valid_indices_dram};
    UNUSED(emb_0_embbag_valid_indices_tr_info); // For single op tests
    synTensor emb_0_embbag_valid_indices = createTensor(1U, syn_type_int32, emb_0_embbag_valid_indices_sizes, true, "emb_0_embbag_valid_indices");
    UNUSED(emb_0_embbag_valid_indices); // For single op tests

    synTensor emb_0_embbag_dedw_SLS_in_vec[4] = {concat_interact0_grad_input1, emb_0_embbag_dedw_grad_indices, emb_0_embbag_dedw_lengths, emb_0_embbag_valid_indices};


    // create emb_0_embbag_dedw_grad_inter tensor
    const unsigned emb_0_embbag_dedw_grad_inter_sizes[] = {128, 32};
    synTensor emb_0_embbag_dedw_grad_inter = createTensor(2U, syn_type_single, emb_0_embbag_dedw_grad_inter_sizes, false, "emb_0_embbag_dedw_grad_inter");
    UNUSED(emb_0_embbag_dedw_grad_inter); // For single op tests

    synTensor emb_0_embbag_dedw_SLS_out_vec[1] = {emb_0_embbag_dedw_grad_inter};


    status = synNodeCreate(graphHandle, emb_0_embbag_dedw_SLS_in_vec, emb_0_embbag_dedw_SLS_out_vec, 4, 1, (void *)&emb_0_embbag_dedw_SLS_kernel_params, sizeof(emb_0_embbag_dedw_SLS_kernel_params), "sparse_lengths_sum_fwd_f32", "emb_0_embbag_dedw_SLS", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_0_embbag_dedw_SLS failed!");

    /*************
     * emb_0_embbag_dedw_EMB node
     * inputs: [emb_0_embbag_dedw_grad_inter(128, 32)(dtype=float32), emb_0_embbag_weight_golden[1460, 32](dtype=float32), emb_0_embbag_momentum[1460, 32](dtype=float32), emb_0_embbag_dedw_param_table_indices[128](dtype=int32), emb_0_offset_shape[128](dtype=int32), emb_0_embbag_timestamp[1](dtype=int32), emb_0_embbag_rate[1](dtype=float32), emb_0_embbag_valid_indices[1](dtype=int32), emb_0_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_0_embbag_dedw_weight_output_golden(1460, 32)(dtype=float32), emb_0_embbag_dedw_momentum_output(1460, 32)(dtype=float32), emb_0_embbag_dedw_weight_output(1460, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_0_embbag_dedw_EMB_kernel_params;
    emb_0_embbag_dedw_EMB_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_0_embbag_dedw_EMB_kernel_params.sgd.wd = 0;
    emb_0_embbag_dedw_EMB_kernel_params.sgd.mom = 1;
    emb_0_embbag_dedw_EMB_kernel_params.sgd.damp = 0;
    emb_0_embbag_dedw_EMB_kernel_params.sgd.nesterov = false;

    // create emb_0_embbag_weight_golden tensor
    const unsigned emb_0_embbag_weight_golden_sizes[] = {1460, 32};
    uint64_t emb_0_embbag_weight_golden_dram;
    unsigned emb_0_embbag_weight_golden_size = 1460*32;
    unsigned emb_0_embbag_weight_golden_size_in_bytes = emb_0_embbag_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(emb_0_embbag_weight_golden_size_in_bytes, &emb_0_embbag_weight_golden_dram, "emb_0_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_weight_golden dram malloc failed!");
    synLaunchTensorInfo emb_0_embbag_weight_golden_tr_info = {"emb_0_embbag_weight_golden",
                                                              emb_0_embbag_weight_golden_dram};
    UNUSED(emb_0_embbag_weight_golden_tr_info); // For single op tests
    synTensor emb_0_embbag_weight_golden = createTensor(2U, syn_type_single, emb_0_embbag_weight_golden_sizes, true, "emb_0_embbag_weight_golden");
    UNUSED(emb_0_embbag_weight_golden); // For single op tests

    // create emb_0_embbag_momentum tensor
    const unsigned emb_0_embbag_momentum_sizes[] = {1460, 32};
    uint64_t emb_0_embbag_momentum_dram;
    unsigned emb_0_embbag_momentum_size = 1460*32;
    unsigned emb_0_embbag_momentum_size_in_bytes = emb_0_embbag_momentum_size * sizeof(float) ;
    status = hbmAlloc(emb_0_embbag_momentum_size_in_bytes, &emb_0_embbag_momentum_dram, "emb_0_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_momentum dram malloc failed!");
    synLaunchTensorInfo emb_0_embbag_momentum_tr_info = {"emb_0_embbag_momentum", emb_0_embbag_momentum_dram};
    UNUSED(emb_0_embbag_momentum_tr_info); // For single op tests
    synTensor emb_0_embbag_momentum = createTensor(2U, syn_type_single, emb_0_embbag_momentum_sizes, true, "emb_0_embbag_momentum");
    UNUSED(emb_0_embbag_momentum); // For single op tests

    // create emb_0_embbag_dedw_param_table_indices tensor
    const unsigned emb_0_embbag_dedw_param_table_indices_sizes[] = {128,};
    uint64_t emb_0_embbag_dedw_param_table_indices_dram;
    unsigned emb_0_embbag_dedw_param_table_indices_size = 128;
    unsigned emb_0_embbag_dedw_param_table_indices_size_in_bytes = emb_0_embbag_dedw_param_table_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_0_embbag_dedw_param_table_indices_size_in_bytes, &emb_0_embbag_dedw_param_table_indices_dram, "emb_0_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_dedw_param_table_indices dram malloc failed!");
    synLaunchTensorInfo emb_0_embbag_dedw_param_table_indices_tr_info = {"emb_0_embbag_dedw_param_table_indices",
                                                                         emb_0_embbag_dedw_param_table_indices_dram};
    UNUSED(emb_0_embbag_dedw_param_table_indices_tr_info); // For single op tests
    synTensor emb_0_embbag_dedw_param_table_indices = createTensor(1U, syn_type_int32, emb_0_embbag_dedw_param_table_indices_sizes, true, "emb_0_embbag_dedw_param_table_indices");
    UNUSED(emb_0_embbag_dedw_param_table_indices); // For single op tests

    // create emb_0_offset_shape tensor
    const unsigned emb_0_offset_shape_sizes[] = {128,};
    uint64_t emb_0_offset_shape_dram;
    unsigned emb_0_offset_shape_size = 128;
    unsigned emb_0_offset_shape_size_in_bytes = emb_0_offset_shape_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_0_offset_shape_size_in_bytes, &emb_0_offset_shape_dram, "emb_0_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_0_offset_shape dram malloc failed!");
    synLaunchTensorInfo emb_0_offset_shape_tr_info = {"emb_0_offset_shape", emb_0_offset_shape_dram};
    UNUSED(emb_0_offset_shape_tr_info); // For single op tests
    synTensor emb_0_offset_shape = createTensor(1U, syn_type_int32, emb_0_offset_shape_sizes, true, "emb_0_offset_shape");
    UNUSED(emb_0_offset_shape); // For single op tests

    // create emb_0_embbag_timestamp tensor
    const unsigned emb_0_embbag_timestamp_sizes[] = {1,};
    uint64_t emb_0_embbag_timestamp_dram;
    unsigned emb_0_embbag_timestamp_size = 1;
    unsigned emb_0_embbag_timestamp_size_in_bytes = emb_0_embbag_timestamp_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_0_embbag_timestamp_size_in_bytes, &emb_0_embbag_timestamp_dram, "emb_0_embbag_timestamp");
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_timestamp dram malloc failed!");
    synLaunchTensorInfo emb_0_embbag_timestamp_tr_info = {"emb_0_embbag_timestamp", emb_0_embbag_timestamp_dram};
    UNUSED(emb_0_embbag_timestamp_tr_info); // For single op tests
    synTensor emb_0_embbag_timestamp = createTensor(1U, syn_type_int32, emb_0_embbag_timestamp_sizes, true, "emb_0_embbag_timestamp");
    UNUSED(emb_0_embbag_timestamp); // For single op tests

    // create emb_0_embbag_rate tensor
    const unsigned emb_0_embbag_rate_sizes[] = {1,};
    uint64_t emb_0_embbag_rate_dram;
    unsigned emb_0_embbag_rate_size = 1;
    unsigned emb_0_embbag_rate_size_in_bytes = emb_0_embbag_rate_size * sizeof(float) ;
    status = hbmAlloc(emb_0_embbag_rate_size_in_bytes, &emb_0_embbag_rate_dram, "emb_0_embbag_rate");
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_rate dram malloc failed!");
    synLaunchTensorInfo emb_0_embbag_rate_tr_info = {"emb_0_embbag_rate", emb_0_embbag_rate_dram};
    UNUSED(emb_0_embbag_rate_tr_info); // For single op tests
    synTensor emb_0_embbag_rate = createTensor(1U, syn_type_single, emb_0_embbag_rate_sizes, true, "emb_0_embbag_rate");
    UNUSED(emb_0_embbag_rate); // For single op tests

    synTensor emb_0_embbag_dedw_EMB_in_vec[9] = {emb_0_embbag_dedw_grad_inter, emb_0_embbag_weight_golden, emb_0_embbag_momentum, emb_0_embbag_dedw_param_table_indices, emb_0_offset_shape, emb_0_embbag_timestamp, emb_0_embbag_rate, emb_0_embbag_valid_indices, emb_0_embbag_valid_indices};


    // create emb_0_embbag_dedw_weight_output_golden tensor
    const unsigned emb_0_embbag_dedw_weight_output_golden_sizes[] = {1460, 32};
    uint64_t emb_0_embbag_dedw_weight_output_golden_dram = emb_0_embbag_weight_golden_dram;
    synLaunchTensorInfo emb_0_embbag_dedw_weight_output_golden_tr_info = {"emb_0_embbag_dedw_weight_output_golden",
                                                                          emb_0_embbag_dedw_weight_output_golden_dram};
    UNUSED(emb_0_embbag_dedw_weight_output_golden_tr_info); // For single op tests
    synTensor emb_0_embbag_dedw_weight_output_golden = createTensor(2U, syn_type_single, emb_0_embbag_dedw_weight_output_golden_sizes, true, "emb_0_embbag_dedw_weight_output_golden");
    UNUSED(emb_0_embbag_dedw_weight_output_golden); // For single op tests

    // create emb_0_embbag_dedw_momentum_output tensor
    const unsigned emb_0_embbag_dedw_momentum_output_sizes[] = {1460, 32};
    uint64_t emb_0_embbag_dedw_momentum_output_dram;
    unsigned emb_0_embbag_dedw_momentum_output_size = 1460*32;
    unsigned emb_0_embbag_dedw_momentum_output_size_in_bytes = emb_0_embbag_dedw_momentum_output_size * sizeof(float) ;
    status = hbmAlloc(emb_0_embbag_dedw_momentum_output_size_in_bytes, &emb_0_embbag_dedw_momentum_output_dram, "emb_0_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_dedw_momentum_output dram malloc failed!");
    synLaunchTensorInfo emb_0_embbag_dedw_momentum_output_tr_info = {"emb_0_embbag_dedw_momentum_output",
                                                                     emb_0_embbag_dedw_momentum_output_dram};
    UNUSED(emb_0_embbag_dedw_momentum_output_tr_info); // For single op tests
    synTensor emb_0_embbag_dedw_momentum_output = createTensor(2U, syn_type_single, emb_0_embbag_dedw_momentum_output_sizes, true, "emb_0_embbag_dedw_momentum_output");
    UNUSED(emb_0_embbag_dedw_momentum_output); // For single op tests

    // create emb_0_embbag_dedw_weight_output tensor
    const unsigned emb_0_embbag_dedw_weight_output_sizes[] = {1460, 32};
    uint64_t emb_0_embbag_dedw_weight_output_dram = emb_0_embbag_weight_dram;
    synLaunchTensorInfo emb_0_embbag_dedw_weight_output_tr_info = {"emb_0_embbag_dedw_weight_output",
                                                                   emb_0_embbag_dedw_weight_output_dram};
    UNUSED(emb_0_embbag_dedw_weight_output_tr_info); // For single op tests
    synTensor emb_0_embbag_dedw_weight_output = createTensor(2U, syn_type_bf16, emb_0_embbag_dedw_weight_output_sizes, true, "emb_0_embbag_dedw_weight_output");
    UNUSED(emb_0_embbag_dedw_weight_output); // For single op tests

    synTensor emb_0_embbag_dedw_EMB_out_vec[3] = {emb_0_embbag_dedw_weight_output_golden, emb_0_embbag_dedw_momentum_output, emb_0_embbag_dedw_weight_output};


    status = synNodeCreate(graphHandle, emb_0_embbag_dedw_EMB_in_vec, emb_0_embbag_dedw_EMB_out_vec, 9, 3, (void *)&emb_0_embbag_dedw_EMB_kernel_params, sizeof(emb_0_embbag_dedw_EMB_kernel_params), "embedding_bag_sgd_bwd_f32", "emb_0_embbag_dedw_EMB", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_0_embbag_dedw_EMB failed!");

    /*************
     * emb_1_embbag_dedw_SLS node
     * inputs: [concat_interact0_grad_input2(128, 32)(dtype=float32), emb_1_embbag_dedw_grad_indices[128](dtype=int32), emb_1_embbag_dedw_lengths[128](dtype=int32), emb_1_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_1_embbag_dedw_grad_inter(128, 32)(dtype=float32)]
     *************/
    ns_SparseLengthsSum::Params emb_1_embbag_dedw_SLS_kernel_params;
    emb_1_embbag_dedw_SLS_kernel_params.mode = EMBEDDED_SC_ZP;

    // create emb_1_embbag_dedw_grad_indices tensor
    const unsigned emb_1_embbag_dedw_grad_indices_sizes[] = {128,};
    uint64_t emb_1_embbag_dedw_grad_indices_dram;
    unsigned emb_1_embbag_dedw_grad_indices_size = 128;
    unsigned emb_1_embbag_dedw_grad_indices_size_in_bytes = emb_1_embbag_dedw_grad_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_1_embbag_dedw_grad_indices_size_in_bytes, &emb_1_embbag_dedw_grad_indices_dram, "emb_1_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_1_embbag_dedw_grad_indices dram malloc failed!");
    synLaunchTensorInfo emb_1_embbag_dedw_grad_indices_tr_info = {"emb_1_embbag_dedw_grad_indices",
                                                                  emb_1_embbag_dedw_grad_indices_dram};
    UNUSED(emb_1_embbag_dedw_grad_indices_tr_info); // For single op tests
    synTensor emb_1_embbag_dedw_grad_indices = createTensor(1U, syn_type_int32, emb_1_embbag_dedw_grad_indices_sizes, true, "emb_1_embbag_dedw_grad_indices");
    UNUSED(emb_1_embbag_dedw_grad_indices); // For single op tests

    // create emb_1_embbag_dedw_lengths tensor
    const unsigned emb_1_embbag_dedw_lengths_sizes[] = {128,};
    uint64_t emb_1_embbag_dedw_lengths_dram;
    unsigned emb_1_embbag_dedw_lengths_size = 128;
    unsigned emb_1_embbag_dedw_lengths_size_in_bytes = emb_1_embbag_dedw_lengths_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_1_embbag_dedw_lengths_size_in_bytes, &emb_1_embbag_dedw_lengths_dram, "emb_1_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_1_embbag_dedw_lengths dram malloc failed!");
    synLaunchTensorInfo emb_1_embbag_dedw_lengths_tr_info = {"emb_1_embbag_dedw_lengths",
                                                             emb_1_embbag_dedw_lengths_dram};
    UNUSED(emb_1_embbag_dedw_lengths_tr_info); // For single op tests
    synTensor emb_1_embbag_dedw_lengths = createTensor(1U, syn_type_int32, emb_1_embbag_dedw_lengths_sizes, true, "emb_1_embbag_dedw_lengths");
    UNUSED(emb_1_embbag_dedw_lengths); // For single op tests

    // create emb_1_embbag_valid_indices tensor
    const unsigned emb_1_embbag_valid_indices_sizes[] = {1,};
    uint64_t emb_1_embbag_valid_indices_dram;
    unsigned emb_1_embbag_valid_indices_size = 1;
    unsigned emb_1_embbag_valid_indices_size_in_bytes = emb_1_embbag_valid_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_1_embbag_valid_indices_size_in_bytes, &emb_1_embbag_valid_indices_dram, "emb_1_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_1_embbag_valid_indices dram malloc failed!");
    synLaunchTensorInfo emb_1_embbag_valid_indices_tr_info = {"emb_1_embbag_valid_indices",
                                                              emb_1_embbag_valid_indices_dram};
    UNUSED(emb_1_embbag_valid_indices_tr_info); // For single op tests
    synTensor emb_1_embbag_valid_indices = createTensor(1U, syn_type_int32, emb_1_embbag_valid_indices_sizes, true, "emb_1_embbag_valid_indices");
    UNUSED(emb_1_embbag_valid_indices); // For single op tests

    synTensor emb_1_embbag_dedw_SLS_in_vec[4] = {concat_interact0_grad_input2, emb_1_embbag_dedw_grad_indices, emb_1_embbag_dedw_lengths, emb_1_embbag_valid_indices};


    // create emb_1_embbag_dedw_grad_inter tensor
    const unsigned emb_1_embbag_dedw_grad_inter_sizes[] = {128, 32};
    synTensor emb_1_embbag_dedw_grad_inter = createTensor(2U, syn_type_single, emb_1_embbag_dedw_grad_inter_sizes, false, "emb_1_embbag_dedw_grad_inter");
    UNUSED(emb_1_embbag_dedw_grad_inter); // For single op tests

    synTensor emb_1_embbag_dedw_SLS_out_vec[1] = {emb_1_embbag_dedw_grad_inter};


    status = synNodeCreate(graphHandle, emb_1_embbag_dedw_SLS_in_vec, emb_1_embbag_dedw_SLS_out_vec, 4, 1, (void *)&emb_1_embbag_dedw_SLS_kernel_params, sizeof(emb_1_embbag_dedw_SLS_kernel_params), "sparse_lengths_sum_fwd_f32", "emb_1_embbag_dedw_SLS", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_1_embbag_dedw_SLS failed!");

    /*************
     * emb_1_embbag_dedw_EMB node
     * inputs: [emb_1_embbag_dedw_grad_inter(128, 32)(dtype=float32), emb_1_embbag_weight_golden[579, 32](dtype=float32), emb_1_embbag_momentum[579, 32](dtype=float32), emb_1_embbag_dedw_param_table_indices[128](dtype=int32), emb_1_offset_shape[128](dtype=int32), emb_0_embbag_timestamp[1](dtype=int32), emb_0_embbag_rate[1](dtype=float32), emb_1_embbag_valid_indices[1](dtype=int32), emb_1_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_1_embbag_dedw_weight_output_golden(579, 32)(dtype=float32), emb_1_embbag_dedw_momentum_output(579, 32)(dtype=float32), emb_1_embbag_dedw_weight_output(579, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_1_embbag_dedw_EMB_kernel_params;
    emb_1_embbag_dedw_EMB_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_1_embbag_dedw_EMB_kernel_params.sgd.wd = 0;
    emb_1_embbag_dedw_EMB_kernel_params.sgd.mom = 1;
    emb_1_embbag_dedw_EMB_kernel_params.sgd.damp = 0;
    emb_1_embbag_dedw_EMB_kernel_params.sgd.nesterov = false;

    // create emb_1_embbag_weight_golden tensor
    const unsigned emb_1_embbag_weight_golden_sizes[] = {579, 32};
    uint64_t emb_1_embbag_weight_golden_dram;
    unsigned emb_1_embbag_weight_golden_size = 579*32;
    unsigned emb_1_embbag_weight_golden_size_in_bytes = emb_1_embbag_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(emb_1_embbag_weight_golden_size_in_bytes, &emb_1_embbag_weight_golden_dram, "emb_1_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_1_embbag_weight_golden dram malloc failed!");
    synLaunchTensorInfo emb_1_embbag_weight_golden_tr_info = {"emb_1_embbag_weight_golden",
                                                              emb_1_embbag_weight_golden_dram};
    UNUSED(emb_1_embbag_weight_golden_tr_info); // For single op tests
    synTensor emb_1_embbag_weight_golden = createTensor(2U, syn_type_single, emb_1_embbag_weight_golden_sizes, true, "emb_1_embbag_weight_golden");
    UNUSED(emb_1_embbag_weight_golden); // For single op tests

    // create emb_1_embbag_momentum tensor
    const unsigned emb_1_embbag_momentum_sizes[] = {579, 32};
    uint64_t emb_1_embbag_momentum_dram;
    unsigned emb_1_embbag_momentum_size = 579*32;
    unsigned emb_1_embbag_momentum_size_in_bytes = emb_1_embbag_momentum_size * sizeof(float) ;
    status = hbmAlloc(emb_1_embbag_momentum_size_in_bytes, &emb_1_embbag_momentum_dram, "emb_1_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_1_embbag_momentum dram malloc failed!");
    synLaunchTensorInfo emb_1_embbag_momentum_tr_info = {"emb_1_embbag_momentum", emb_1_embbag_momentum_dram};
    UNUSED(emb_1_embbag_momentum_tr_info); // For single op tests
    synTensor emb_1_embbag_momentum = createTensor(2U, syn_type_single, emb_1_embbag_momentum_sizes, true, "emb_1_embbag_momentum");
    UNUSED(emb_1_embbag_momentum); // For single op tests

    // create emb_1_embbag_dedw_param_table_indices tensor
    const unsigned emb_1_embbag_dedw_param_table_indices_sizes[] = {128,};
    uint64_t emb_1_embbag_dedw_param_table_indices_dram;
    unsigned emb_1_embbag_dedw_param_table_indices_size = 128;
    unsigned emb_1_embbag_dedw_param_table_indices_size_in_bytes = emb_1_embbag_dedw_param_table_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_1_embbag_dedw_param_table_indices_size_in_bytes, &emb_1_embbag_dedw_param_table_indices_dram, "emb_1_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_1_embbag_dedw_param_table_indices dram malloc failed!");
    synLaunchTensorInfo emb_1_embbag_dedw_param_table_indices_tr_info = {"emb_1_embbag_dedw_param_table_indices",
                                                                         emb_1_embbag_dedw_param_table_indices_dram};
    UNUSED(emb_1_embbag_dedw_param_table_indices_tr_info); // For single op tests
    synTensor emb_1_embbag_dedw_param_table_indices = createTensor(1U, syn_type_int32, emb_1_embbag_dedw_param_table_indices_sizes, true, "emb_1_embbag_dedw_param_table_indices");
    UNUSED(emb_1_embbag_dedw_param_table_indices); // For single op tests

    // create emb_1_offset_shape tensor
    const unsigned emb_1_offset_shape_sizes[] = {128,};
    uint64_t emb_1_offset_shape_dram;
    unsigned emb_1_offset_shape_size = 128;
    unsigned emb_1_offset_shape_size_in_bytes = emb_1_offset_shape_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_1_offset_shape_size_in_bytes, &emb_1_offset_shape_dram, "emb_1_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_1_offset_shape dram malloc failed!");
    synLaunchTensorInfo emb_1_offset_shape_tr_info = {"emb_1_offset_shape", emb_1_offset_shape_dram};
    UNUSED(emb_1_offset_shape_tr_info); // For single op tests
    synTensor emb_1_offset_shape = createTensor(1U, syn_type_int32, emb_1_offset_shape_sizes, true, "emb_1_offset_shape");
    UNUSED(emb_1_offset_shape); // For single op tests

    synTensor emb_1_embbag_dedw_EMB_in_vec[9] = {emb_1_embbag_dedw_grad_inter, emb_1_embbag_weight_golden, emb_1_embbag_momentum, emb_1_embbag_dedw_param_table_indices, emb_1_offset_shape, emb_0_embbag_timestamp, emb_0_embbag_rate, emb_1_embbag_valid_indices, emb_1_embbag_valid_indices};


    // create emb_1_embbag_dedw_weight_output_golden tensor
    const unsigned emb_1_embbag_dedw_weight_output_golden_sizes[] = {579, 32};
    uint64_t emb_1_embbag_dedw_weight_output_golden_dram = emb_1_embbag_weight_golden_dram;
    synLaunchTensorInfo emb_1_embbag_dedw_weight_output_golden_tr_info = {"emb_1_embbag_dedw_weight_output_golden",
                                                                          emb_1_embbag_dedw_weight_output_golden_dram};
    UNUSED(emb_1_embbag_dedw_weight_output_golden_tr_info); // For single op tests
    synTensor emb_1_embbag_dedw_weight_output_golden = createTensor(2U, syn_type_single, emb_1_embbag_dedw_weight_output_golden_sizes, true, "emb_1_embbag_dedw_weight_output_golden");
    UNUSED(emb_1_embbag_dedw_weight_output_golden); // For single op tests

    // create emb_1_embbag_dedw_momentum_output tensor
    const unsigned emb_1_embbag_dedw_momentum_output_sizes[] = {579, 32};
    uint64_t emb_1_embbag_dedw_momentum_output_dram;
    unsigned emb_1_embbag_dedw_momentum_output_size = 579*32;
    unsigned emb_1_embbag_dedw_momentum_output_size_in_bytes = emb_1_embbag_dedw_momentum_output_size * sizeof(float) ;
    status = hbmAlloc(emb_1_embbag_dedw_momentum_output_size_in_bytes, &emb_1_embbag_dedw_momentum_output_dram, "emb_1_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_1_embbag_dedw_momentum_output dram malloc failed!");
    synLaunchTensorInfo emb_1_embbag_dedw_momentum_output_tr_info = {"emb_1_embbag_dedw_momentum_output",
                                                                     emb_1_embbag_dedw_momentum_output_dram};
    UNUSED(emb_1_embbag_dedw_momentum_output_tr_info); // For single op tests
    synTensor emb_1_embbag_dedw_momentum_output = createTensor(2U, syn_type_single, emb_1_embbag_dedw_momentum_output_sizes, true, "emb_1_embbag_dedw_momentum_output");
    UNUSED(emb_1_embbag_dedw_momentum_output); // For single op tests

    // create emb_1_embbag_dedw_weight_output tensor
    const unsigned emb_1_embbag_dedw_weight_output_sizes[] = {579, 32};
    uint64_t emb_1_embbag_dedw_weight_output_dram = emb_1_embbag_weight_dram;
    synLaunchTensorInfo emb_1_embbag_dedw_weight_output_tr_info = {"emb_1_embbag_dedw_weight_output",
                                                                   emb_1_embbag_dedw_weight_output_dram};
    UNUSED(emb_1_embbag_dedw_weight_output_tr_info); // For single op tests
    synTensor emb_1_embbag_dedw_weight_output = createTensor(2U, syn_type_bf16, emb_1_embbag_dedw_weight_output_sizes, true, "emb_1_embbag_dedw_weight_output");
    UNUSED(emb_1_embbag_dedw_weight_output); // For single op tests

    synTensor emb_1_embbag_dedw_EMB_out_vec[3] = {emb_1_embbag_dedw_weight_output_golden, emb_1_embbag_dedw_momentum_output, emb_1_embbag_dedw_weight_output};


    status = synNodeCreate(graphHandle, emb_1_embbag_dedw_EMB_in_vec, emb_1_embbag_dedw_EMB_out_vec, 9, 3, (void *)&emb_1_embbag_dedw_EMB_kernel_params, sizeof(emb_1_embbag_dedw_EMB_kernel_params), "embedding_bag_sgd_bwd_f32", "emb_1_embbag_dedw_EMB", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_1_embbag_dedw_EMB failed!");

    /*************
     * emb_2_embbag_dedw_SLS node
     * inputs: [concat_interact0_grad_input3(128, 32)(dtype=float32), emb_2_embbag_dedw_grad_indices[128](dtype=int32), emb_2_embbag_dedw_lengths[128](dtype=int32), emb_2_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_2_embbag_dedw_grad_inter(128, 32)(dtype=float32)]
     *************/
    ns_SparseLengthsSum::Params emb_2_embbag_dedw_SLS_kernel_params;
    emb_2_embbag_dedw_SLS_kernel_params.mode = EMBEDDED_SC_ZP;

    // create emb_2_embbag_dedw_grad_indices tensor
    const unsigned emb_2_embbag_dedw_grad_indices_sizes[] = {128,};
    uint64_t emb_2_embbag_dedw_grad_indices_dram;
    unsigned emb_2_embbag_dedw_grad_indices_size = 128;
    unsigned emb_2_embbag_dedw_grad_indices_size_in_bytes = emb_2_embbag_dedw_grad_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_2_embbag_dedw_grad_indices_size_in_bytes, &emb_2_embbag_dedw_grad_indices_dram, "emb_2_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_2_embbag_dedw_grad_indices dram malloc failed!");
    synLaunchTensorInfo emb_2_embbag_dedw_grad_indices_tr_info = {"emb_2_embbag_dedw_grad_indices",
                                                                  emb_2_embbag_dedw_grad_indices_dram};
    UNUSED(emb_2_embbag_dedw_grad_indices_tr_info); // For single op tests
    synTensor emb_2_embbag_dedw_grad_indices = createTensor(1U, syn_type_int32, emb_2_embbag_dedw_grad_indices_sizes, true, "emb_2_embbag_dedw_grad_indices");
    UNUSED(emb_2_embbag_dedw_grad_indices); // For single op tests

    // create emb_2_embbag_dedw_lengths tensor
    const unsigned emb_2_embbag_dedw_lengths_sizes[] = {128,};
    uint64_t emb_2_embbag_dedw_lengths_dram;
    unsigned emb_2_embbag_dedw_lengths_size = 128;
    unsigned emb_2_embbag_dedw_lengths_size_in_bytes = emb_2_embbag_dedw_lengths_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_2_embbag_dedw_lengths_size_in_bytes, &emb_2_embbag_dedw_lengths_dram, "emb_2_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_2_embbag_dedw_lengths dram malloc failed!");
    synLaunchTensorInfo emb_2_embbag_dedw_lengths_tr_info = {"emb_2_embbag_dedw_lengths",
                                                             emb_2_embbag_dedw_lengths_dram};
    UNUSED(emb_2_embbag_dedw_lengths_tr_info); // For single op tests
    synTensor emb_2_embbag_dedw_lengths = createTensor(1U, syn_type_int32, emb_2_embbag_dedw_lengths_sizes, true, "emb_2_embbag_dedw_lengths");
    UNUSED(emb_2_embbag_dedw_lengths); // For single op tests

    // create emb_2_embbag_valid_indices tensor
    const unsigned emb_2_embbag_valid_indices_sizes[] = {1,};
    uint64_t emb_2_embbag_valid_indices_dram;
    unsigned emb_2_embbag_valid_indices_size = 1;
    unsigned emb_2_embbag_valid_indices_size_in_bytes = emb_2_embbag_valid_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_2_embbag_valid_indices_size_in_bytes, &emb_2_embbag_valid_indices_dram, "emb_2_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_2_embbag_valid_indices dram malloc failed!");
    synLaunchTensorInfo emb_2_embbag_valid_indices_tr_info = {"emb_2_embbag_valid_indices",
                                                              emb_2_embbag_valid_indices_dram};
    UNUSED(emb_2_embbag_valid_indices_tr_info); // For single op tests
    synTensor emb_2_embbag_valid_indices = createTensor(1U, syn_type_int32, emb_2_embbag_valid_indices_sizes, true, "emb_2_embbag_valid_indices");
    UNUSED(emb_2_embbag_valid_indices); // For single op tests

    synTensor emb_2_embbag_dedw_SLS_in_vec[4] = {concat_interact0_grad_input3, emb_2_embbag_dedw_grad_indices, emb_2_embbag_dedw_lengths, emb_2_embbag_valid_indices};


    // create emb_2_embbag_dedw_grad_inter tensor
    const unsigned emb_2_embbag_dedw_grad_inter_sizes[] = {128, 32};
    synTensor emb_2_embbag_dedw_grad_inter = createTensor(2U, syn_type_single, emb_2_embbag_dedw_grad_inter_sizes, false, "emb_2_embbag_dedw_grad_inter");
    UNUSED(emb_2_embbag_dedw_grad_inter); // For single op tests

    synTensor emb_2_embbag_dedw_SLS_out_vec[1] = {emb_2_embbag_dedw_grad_inter};


    status = synNodeCreate(graphHandle, emb_2_embbag_dedw_SLS_in_vec, emb_2_embbag_dedw_SLS_out_vec, 4, 1, (void *)&emb_2_embbag_dedw_SLS_kernel_params, sizeof(emb_2_embbag_dedw_SLS_kernel_params), "sparse_lengths_sum_fwd_f32", "emb_2_embbag_dedw_SLS", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_2_embbag_dedw_SLS failed!");

    /*************
     * emb_2_embbag_dedw_EMB node
     * inputs: [emb_2_embbag_dedw_grad_inter(128, 32)(dtype=float32), emb_2_embbag_weight_golden[8832328, 32](dtype=float32), emb_2_embbag_momentum[8832328, 32](dtype=float32), emb_2_embbag_dedw_param_table_indices[128](dtype=int32), emb_2_offset_shape[128](dtype=int32), emb_0_embbag_timestamp[1](dtype=int32), emb_0_embbag_rate[1](dtype=float32), emb_2_embbag_valid_indices[1](dtype=int32), emb_2_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_2_embbag_dedw_weight_output_golden(8832328, 32)(dtype=float32), emb_2_embbag_dedw_momentum_output(8832328, 32)(dtype=float32), emb_2_embbag_dedw_weight_output(8832328, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_2_embbag_dedw_EMB_kernel_params;
    emb_2_embbag_dedw_EMB_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_2_embbag_dedw_EMB_kernel_params.sgd.wd = 0;
    emb_2_embbag_dedw_EMB_kernel_params.sgd.mom = 1;
    emb_2_embbag_dedw_EMB_kernel_params.sgd.damp = 0;
    emb_2_embbag_dedw_EMB_kernel_params.sgd.nesterov = false;

    // create emb_2_embbag_weight_golden tensor
    const unsigned emb_2_embbag_weight_golden_sizes[] = {8832328, 32};
    uint64_t emb_2_embbag_weight_golden_dram;
    unsigned emb_2_embbag_weight_golden_size = 8832328*32;
    unsigned emb_2_embbag_weight_golden_size_in_bytes = emb_2_embbag_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(emb_2_embbag_weight_golden_size_in_bytes, &emb_2_embbag_weight_golden_dram, "emb_2_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_2_embbag_weight_golden dram malloc failed!");
    synLaunchTensorInfo emb_2_embbag_weight_golden_tr_info = {"emb_2_embbag_weight_golden",
                                                              emb_2_embbag_weight_golden_dram};
    UNUSED(emb_2_embbag_weight_golden_tr_info); // For single op tests
    synTensor emb_2_embbag_weight_golden = createTensor(2U, syn_type_single, emb_2_embbag_weight_golden_sizes, true, "emb_2_embbag_weight_golden");
    UNUSED(emb_2_embbag_weight_golden); // For single op tests

    // create emb_2_embbag_momentum tensor
    const unsigned emb_2_embbag_momentum_sizes[] = {8832328, 32};
    uint64_t emb_2_embbag_momentum_dram;
    unsigned emb_2_embbag_momentum_size = 8832328*32;
    unsigned emb_2_embbag_momentum_size_in_bytes = emb_2_embbag_momentum_size * sizeof(float) ;
    status = hbmAlloc(emb_2_embbag_momentum_size_in_bytes, &emb_2_embbag_momentum_dram, "emb_2_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_2_embbag_momentum dram malloc failed!");
    synLaunchTensorInfo emb_2_embbag_momentum_tr_info = {"emb_2_embbag_momentum", emb_2_embbag_momentum_dram};
    UNUSED(emb_2_embbag_momentum_tr_info); // For single op tests
    synTensor emb_2_embbag_momentum = createTensor(2U, syn_type_single, emb_2_embbag_momentum_sizes, true, "emb_2_embbag_momentum");
    UNUSED(emb_2_embbag_momentum); // For single op tests

    // create emb_2_embbag_dedw_param_table_indices tensor
    const unsigned emb_2_embbag_dedw_param_table_indices_sizes[] = {128,};
    uint64_t emb_2_embbag_dedw_param_table_indices_dram;
    unsigned emb_2_embbag_dedw_param_table_indices_size = 128;
    unsigned emb_2_embbag_dedw_param_table_indices_size_in_bytes = emb_2_embbag_dedw_param_table_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_2_embbag_dedw_param_table_indices_size_in_bytes, &emb_2_embbag_dedw_param_table_indices_dram, "emb_2_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_2_embbag_dedw_param_table_indices dram malloc failed!");
    synLaunchTensorInfo emb_2_embbag_dedw_param_table_indices_tr_info = {"emb_2_embbag_dedw_param_table_indices",
                                                                         emb_2_embbag_dedw_param_table_indices_dram};
    UNUSED(emb_2_embbag_dedw_param_table_indices_tr_info); // For single op tests
    synTensor emb_2_embbag_dedw_param_table_indices = createTensor(1U, syn_type_int32, emb_2_embbag_dedw_param_table_indices_sizes, true, "emb_2_embbag_dedw_param_table_indices");
    UNUSED(emb_2_embbag_dedw_param_table_indices); // For single op tests

    // create emb_2_offset_shape tensor
    const unsigned emb_2_offset_shape_sizes[] = {128,};
    uint64_t emb_2_offset_shape_dram;
    unsigned emb_2_offset_shape_size = 128;
    unsigned emb_2_offset_shape_size_in_bytes = emb_2_offset_shape_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_2_offset_shape_size_in_bytes, &emb_2_offset_shape_dram, "emb_2_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_2_offset_shape dram malloc failed!");
    synLaunchTensorInfo emb_2_offset_shape_tr_info = {"emb_2_offset_shape", emb_2_offset_shape_dram};
    UNUSED(emb_2_offset_shape_tr_info); // For single op tests
    synTensor emb_2_offset_shape = createTensor(1U, syn_type_int32, emb_2_offset_shape_sizes, true, "emb_2_offset_shape");
    UNUSED(emb_2_offset_shape); // For single op tests

    synTensor emb_2_embbag_dedw_EMB_in_vec[9] = {emb_2_embbag_dedw_grad_inter, emb_2_embbag_weight_golden, emb_2_embbag_momentum, emb_2_embbag_dedw_param_table_indices, emb_2_offset_shape, emb_0_embbag_timestamp, emb_0_embbag_rate, emb_2_embbag_valid_indices, emb_2_embbag_valid_indices};


    // create emb_2_embbag_dedw_weight_output_golden tensor
    const unsigned emb_2_embbag_dedw_weight_output_golden_sizes[] = {8832328, 32};
    uint64_t emb_2_embbag_dedw_weight_output_golden_dram = emb_2_embbag_weight_golden_dram;
    synLaunchTensorInfo emb_2_embbag_dedw_weight_output_golden_tr_info = {"emb_2_embbag_dedw_weight_output_golden",
                                                                          emb_2_embbag_dedw_weight_output_golden_dram};
    UNUSED(emb_2_embbag_dedw_weight_output_golden_tr_info); // For single op tests
    synTensor emb_2_embbag_dedw_weight_output_golden = createTensor(2U, syn_type_single, emb_2_embbag_dedw_weight_output_golden_sizes, true, "emb_2_embbag_dedw_weight_output_golden");
    UNUSED(emb_2_embbag_dedw_weight_output_golden); // For single op tests

    // create emb_2_embbag_dedw_momentum_output tensor
    const unsigned emb_2_embbag_dedw_momentum_output_sizes[] = {8832328, 32};
    uint64_t emb_2_embbag_dedw_momentum_output_dram;
    unsigned emb_2_embbag_dedw_momentum_output_size = 8832328*32;
    unsigned emb_2_embbag_dedw_momentum_output_size_in_bytes = emb_2_embbag_dedw_momentum_output_size * sizeof(float) ;
    status = hbmAlloc(emb_2_embbag_dedw_momentum_output_size_in_bytes, &emb_2_embbag_dedw_momentum_output_dram, "emb_2_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_2_embbag_dedw_momentum_output dram malloc failed!");
    synLaunchTensorInfo emb_2_embbag_dedw_momentum_output_tr_info = {"emb_2_embbag_dedw_momentum_output",
                                                                     emb_2_embbag_dedw_momentum_output_dram};
    UNUSED(emb_2_embbag_dedw_momentum_output_tr_info); // For single op tests
    synTensor emb_2_embbag_dedw_momentum_output = createTensor(2U, syn_type_single, emb_2_embbag_dedw_momentum_output_sizes, true, "emb_2_embbag_dedw_momentum_output");
    UNUSED(emb_2_embbag_dedw_momentum_output); // For single op tests

    // create emb_2_embbag_dedw_weight_output tensor
    const unsigned emb_2_embbag_dedw_weight_output_sizes[] = {8832328, 32};
    uint64_t emb_2_embbag_dedw_weight_output_dram = emb_2_embbag_weight_dram;
    synLaunchTensorInfo emb_2_embbag_dedw_weight_output_tr_info = {"emb_2_embbag_dedw_weight_output",
                                                                   emb_2_embbag_dedw_weight_output_dram};
    UNUSED(emb_2_embbag_dedw_weight_output_tr_info); // For single op tests
    synTensor emb_2_embbag_dedw_weight_output = createTensor(2U, syn_type_bf16, emb_2_embbag_dedw_weight_output_sizes, true, "emb_2_embbag_dedw_weight_output");
    UNUSED(emb_2_embbag_dedw_weight_output); // For single op tests

    synTensor emb_2_embbag_dedw_EMB_out_vec[3] = {emb_2_embbag_dedw_weight_output_golden, emb_2_embbag_dedw_momentum_output, emb_2_embbag_dedw_weight_output};


    status = synNodeCreate(graphHandle, emb_2_embbag_dedw_EMB_in_vec, emb_2_embbag_dedw_EMB_out_vec, 9, 3, (void *)&emb_2_embbag_dedw_EMB_kernel_params, sizeof(emb_2_embbag_dedw_EMB_kernel_params), "embedding_bag_sgd_bwd_f32", "emb_2_embbag_dedw_EMB", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_2_embbag_dedw_EMB failed!");

    /*************
     * emb_3_embbag_dedw_SLS node
     * inputs: [concat_interact0_grad_input4(128, 32)(dtype=float32), emb_3_embbag_dedw_grad_indices[128](dtype=int32), emb_3_embbag_dedw_lengths[128](dtype=int32), emb_3_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_3_embbag_dedw_grad_inter(128, 32)(dtype=float32)]
     *************/
    ns_SparseLengthsSum::Params emb_3_embbag_dedw_SLS_kernel_params;
    emb_3_embbag_dedw_SLS_kernel_params.mode = EMBEDDED_SC_ZP;

    // create emb_3_embbag_dedw_grad_indices tensor
    const unsigned emb_3_embbag_dedw_grad_indices_sizes[] = {128,};
    uint64_t emb_3_embbag_dedw_grad_indices_dram;
    unsigned emb_3_embbag_dedw_grad_indices_size = 128;
    unsigned emb_3_embbag_dedw_grad_indices_size_in_bytes = emb_3_embbag_dedw_grad_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_3_embbag_dedw_grad_indices_size_in_bytes, &emb_3_embbag_dedw_grad_indices_dram, "emb_3_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_3_embbag_dedw_grad_indices dram malloc failed!");
    synLaunchTensorInfo emb_3_embbag_dedw_grad_indices_tr_info = {"emb_3_embbag_dedw_grad_indices",
                                                                  emb_3_embbag_dedw_grad_indices_dram};
    UNUSED(emb_3_embbag_dedw_grad_indices_tr_info); // For single op tests
    synTensor emb_3_embbag_dedw_grad_indices = createTensor(1U, syn_type_int32, emb_3_embbag_dedw_grad_indices_sizes, true, "emb_3_embbag_dedw_grad_indices");
    UNUSED(emb_3_embbag_dedw_grad_indices); // For single op tests

    // create emb_3_embbag_dedw_lengths tensor
    const unsigned emb_3_embbag_dedw_lengths_sizes[] = {128,};
    uint64_t emb_3_embbag_dedw_lengths_dram;
    unsigned emb_3_embbag_dedw_lengths_size = 128;
    unsigned emb_3_embbag_dedw_lengths_size_in_bytes = emb_3_embbag_dedw_lengths_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_3_embbag_dedw_lengths_size_in_bytes, &emb_3_embbag_dedw_lengths_dram, "emb_3_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_3_embbag_dedw_lengths dram malloc failed!");
    synLaunchTensorInfo emb_3_embbag_dedw_lengths_tr_info = {"emb_3_embbag_dedw_lengths",
                                                             emb_3_embbag_dedw_lengths_dram};
    UNUSED(emb_3_embbag_dedw_lengths_tr_info); // For single op tests
    synTensor emb_3_embbag_dedw_lengths = createTensor(1U, syn_type_int32, emb_3_embbag_dedw_lengths_sizes, true, "emb_3_embbag_dedw_lengths");
    UNUSED(emb_3_embbag_dedw_lengths); // For single op tests

    // create emb_3_embbag_valid_indices tensor
    const unsigned emb_3_embbag_valid_indices_sizes[] = {1,};
    uint64_t emb_3_embbag_valid_indices_dram;
    unsigned emb_3_embbag_valid_indices_size = 1;
    unsigned emb_3_embbag_valid_indices_size_in_bytes = emb_3_embbag_valid_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_3_embbag_valid_indices_size_in_bytes, &emb_3_embbag_valid_indices_dram, "emb_3_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_3_embbag_valid_indices dram malloc failed!");
    synLaunchTensorInfo emb_3_embbag_valid_indices_tr_info = {"emb_3_embbag_valid_indices",
                                                              emb_3_embbag_valid_indices_dram};
    UNUSED(emb_3_embbag_valid_indices_tr_info); // For single op tests
    synTensor emb_3_embbag_valid_indices = createTensor(1U, syn_type_int32, emb_3_embbag_valid_indices_sizes, true, "emb_3_embbag_valid_indices");
    UNUSED(emb_3_embbag_valid_indices); // For single op tests

    synTensor emb_3_embbag_dedw_SLS_in_vec[4] = {concat_interact0_grad_input4, emb_3_embbag_dedw_grad_indices, emb_3_embbag_dedw_lengths, emb_3_embbag_valid_indices};


    // create emb_3_embbag_dedw_grad_inter tensor
    const unsigned emb_3_embbag_dedw_grad_inter_sizes[] = {128, 32};
    synTensor emb_3_embbag_dedw_grad_inter = createTensor(2U, syn_type_single, emb_3_embbag_dedw_grad_inter_sizes, false, "emb_3_embbag_dedw_grad_inter");
    UNUSED(emb_3_embbag_dedw_grad_inter); // For single op tests

    synTensor emb_3_embbag_dedw_SLS_out_vec[1] = {emb_3_embbag_dedw_grad_inter};


    status = synNodeCreate(graphHandle, emb_3_embbag_dedw_SLS_in_vec, emb_3_embbag_dedw_SLS_out_vec, 4, 1, (void *)&emb_3_embbag_dedw_SLS_kernel_params, sizeof(emb_3_embbag_dedw_SLS_kernel_params), "sparse_lengths_sum_fwd_f32", "emb_3_embbag_dedw_SLS", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_3_embbag_dedw_SLS failed!");

    /*************
     * emb_3_embbag_dedw_EMB node
     * inputs: [emb_3_embbag_dedw_grad_inter(128, 32)(dtype=float32), emb_3_embbag_weight_golden[1965470, 32](dtype=float32), emb_3_embbag_momentum[1965470, 32](dtype=float32), emb_3_embbag_dedw_param_table_indices[128](dtype=int32), emb_3_offset_shape[128](dtype=int32), emb_0_embbag_timestamp[1](dtype=int32), emb_0_embbag_rate[1](dtype=float32), emb_3_embbag_valid_indices[1](dtype=int32), emb_3_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_3_embbag_dedw_weight_output_golden(1965470, 32)(dtype=float32), emb_3_embbag_dedw_momentum_output(1965470, 32)(dtype=float32), emb_3_embbag_dedw_weight_output(1965470, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_3_embbag_dedw_EMB_kernel_params;
    emb_3_embbag_dedw_EMB_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_3_embbag_dedw_EMB_kernel_params.sgd.wd = 0;
    emb_3_embbag_dedw_EMB_kernel_params.sgd.mom = 1;
    emb_3_embbag_dedw_EMB_kernel_params.sgd.damp = 0;
    emb_3_embbag_dedw_EMB_kernel_params.sgd.nesterov = false;

    // create emb_3_embbag_weight_golden tensor
    const unsigned emb_3_embbag_weight_golden_sizes[] = {1965470, 32};
    uint64_t emb_3_embbag_weight_golden_dram;
    unsigned emb_3_embbag_weight_golden_size = 1965470*32;
    unsigned emb_3_embbag_weight_golden_size_in_bytes = emb_3_embbag_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(emb_3_embbag_weight_golden_size_in_bytes, &emb_3_embbag_weight_golden_dram, "emb_3_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_3_embbag_weight_golden dram malloc failed!");
    synLaunchTensorInfo emb_3_embbag_weight_golden_tr_info = {"emb_3_embbag_weight_golden",
                                                              emb_3_embbag_weight_golden_dram};
    UNUSED(emb_3_embbag_weight_golden_tr_info); // For single op tests
    synTensor emb_3_embbag_weight_golden = createTensor(2U, syn_type_single, emb_3_embbag_weight_golden_sizes, true, "emb_3_embbag_weight_golden");
    UNUSED(emb_3_embbag_weight_golden); // For single op tests

    // create emb_3_embbag_momentum tensor
    const unsigned emb_3_embbag_momentum_sizes[] = {1965470, 32};
    uint64_t emb_3_embbag_momentum_dram;
    unsigned emb_3_embbag_momentum_size = 1965470*32;
    unsigned emb_3_embbag_momentum_size_in_bytes = emb_3_embbag_momentum_size * sizeof(float) ;
    status = hbmAlloc(emb_3_embbag_momentum_size_in_bytes, &emb_3_embbag_momentum_dram, "emb_3_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_3_embbag_momentum dram malloc failed!");
    synLaunchTensorInfo emb_3_embbag_momentum_tr_info = {"emb_3_embbag_momentum", emb_3_embbag_momentum_dram};
    UNUSED(emb_3_embbag_momentum_tr_info); // For single op tests
    synTensor emb_3_embbag_momentum = createTensor(2U, syn_type_single, emb_3_embbag_momentum_sizes, true, "emb_3_embbag_momentum");
    UNUSED(emb_3_embbag_momentum); // For single op tests

    // create emb_3_embbag_dedw_param_table_indices tensor
    const unsigned emb_3_embbag_dedw_param_table_indices_sizes[] = {128,};
    uint64_t emb_3_embbag_dedw_param_table_indices_dram;
    unsigned emb_3_embbag_dedw_param_table_indices_size = 128;
    unsigned emb_3_embbag_dedw_param_table_indices_size_in_bytes = emb_3_embbag_dedw_param_table_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_3_embbag_dedw_param_table_indices_size_in_bytes, &emb_3_embbag_dedw_param_table_indices_dram, "emb_3_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_3_embbag_dedw_param_table_indices dram malloc failed!");
    synLaunchTensorInfo emb_3_embbag_dedw_param_table_indices_tr_info = {"emb_3_embbag_dedw_param_table_indices",
                                                                         emb_3_embbag_dedw_param_table_indices_dram};
    UNUSED(emb_3_embbag_dedw_param_table_indices_tr_info); // For single op tests
    synTensor emb_3_embbag_dedw_param_table_indices = createTensor(1U, syn_type_int32, emb_3_embbag_dedw_param_table_indices_sizes, true, "emb_3_embbag_dedw_param_table_indices");
    UNUSED(emb_3_embbag_dedw_param_table_indices); // For single op tests

    // create emb_3_offset_shape tensor
    const unsigned emb_3_offset_shape_sizes[] = {128,};
    uint64_t emb_3_offset_shape_dram;
    unsigned emb_3_offset_shape_size = 128;
    unsigned emb_3_offset_shape_size_in_bytes = emb_3_offset_shape_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_3_offset_shape_size_in_bytes, &emb_3_offset_shape_dram, "emb_3_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_3_offset_shape dram malloc failed!");
    synLaunchTensorInfo emb_3_offset_shape_tr_info = {"emb_3_offset_shape", emb_3_offset_shape_dram};
    UNUSED(emb_3_offset_shape_tr_info); // For single op tests
    synTensor emb_3_offset_shape = createTensor(1U, syn_type_int32, emb_3_offset_shape_sizes, true, "emb_3_offset_shape");
    UNUSED(emb_3_offset_shape); // For single op tests

    synTensor emb_3_embbag_dedw_EMB_in_vec[9] = {emb_3_embbag_dedw_grad_inter, emb_3_embbag_weight_golden, emb_3_embbag_momentum, emb_3_embbag_dedw_param_table_indices, emb_3_offset_shape, emb_0_embbag_timestamp, emb_0_embbag_rate, emb_3_embbag_valid_indices, emb_3_embbag_valid_indices};


    // create emb_3_embbag_dedw_weight_output_golden tensor
    const unsigned emb_3_embbag_dedw_weight_output_golden_sizes[] = {1965470, 32};
    uint64_t emb_3_embbag_dedw_weight_output_golden_dram = emb_3_embbag_weight_golden_dram;
    synLaunchTensorInfo emb_3_embbag_dedw_weight_output_golden_tr_info = {"emb_3_embbag_dedw_weight_output_golden",
                                                                          emb_3_embbag_dedw_weight_output_golden_dram};
    UNUSED(emb_3_embbag_dedw_weight_output_golden_tr_info); // For single op tests
    synTensor emb_3_embbag_dedw_weight_output_golden = createTensor(2U, syn_type_single, emb_3_embbag_dedw_weight_output_golden_sizes, true, "emb_3_embbag_dedw_weight_output_golden");
    UNUSED(emb_3_embbag_dedw_weight_output_golden); // For single op tests

    // create emb_3_embbag_dedw_momentum_output tensor
    const unsigned emb_3_embbag_dedw_momentum_output_sizes[] = {1965470, 32};
    uint64_t emb_3_embbag_dedw_momentum_output_dram;
    unsigned emb_3_embbag_dedw_momentum_output_size = 1965470*32;
    unsigned emb_3_embbag_dedw_momentum_output_size_in_bytes = emb_3_embbag_dedw_momentum_output_size * sizeof(float) ;
    status = hbmAlloc(emb_3_embbag_dedw_momentum_output_size_in_bytes, &emb_3_embbag_dedw_momentum_output_dram, "emb_3_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_3_embbag_dedw_momentum_output dram malloc failed!");
    synLaunchTensorInfo emb_3_embbag_dedw_momentum_output_tr_info = {"emb_3_embbag_dedw_momentum_output",
                                                                     emb_3_embbag_dedw_momentum_output_dram};
    UNUSED(emb_3_embbag_dedw_momentum_output_tr_info); // For single op tests
    synTensor emb_3_embbag_dedw_momentum_output = createTensor(2U, syn_type_single, emb_3_embbag_dedw_momentum_output_sizes, true, "emb_3_embbag_dedw_momentum_output");
    UNUSED(emb_3_embbag_dedw_momentum_output); // For single op tests

    // create emb_3_embbag_dedw_weight_output tensor
    const unsigned emb_3_embbag_dedw_weight_output_sizes[] = {1965470, 32};
    uint64_t emb_3_embbag_dedw_weight_output_dram = emb_3_embbag_weight_dram;
    synLaunchTensorInfo emb_3_embbag_dedw_weight_output_tr_info = {"emb_3_embbag_dedw_weight_output",
                                                                   emb_3_embbag_dedw_weight_output_dram};
    UNUSED(emb_3_embbag_dedw_weight_output_tr_info); // For single op tests
    synTensor emb_3_embbag_dedw_weight_output = createTensor(2U, syn_type_bf16, emb_3_embbag_dedw_weight_output_sizes, true, "emb_3_embbag_dedw_weight_output");
    UNUSED(emb_3_embbag_dedw_weight_output); // For single op tests

    synTensor emb_3_embbag_dedw_EMB_out_vec[3] = {emb_3_embbag_dedw_weight_output_golden, emb_3_embbag_dedw_momentum_output, emb_3_embbag_dedw_weight_output};


    status = synNodeCreate(graphHandle, emb_3_embbag_dedw_EMB_in_vec, emb_3_embbag_dedw_EMB_out_vec, 9, 3, (void *)&emb_3_embbag_dedw_EMB_kernel_params, sizeof(emb_3_embbag_dedw_EMB_kernel_params), "embedding_bag_sgd_bwd_f32", "emb_3_embbag_dedw_EMB", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_3_embbag_dedw_EMB failed!");

    /*************
     * emb_4_embbag_dedw_SLS node
     * inputs: [concat_interact0_grad_input5(128, 32)(dtype=float32), emb_4_embbag_dedw_grad_indices[128](dtype=int32), emb_4_embbag_dedw_lengths[128](dtype=int32), emb_4_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_4_embbag_dedw_grad_inter(128, 32)(dtype=float32)]
     *************/
    ns_SparseLengthsSum::Params emb_4_embbag_dedw_SLS_kernel_params;
    emb_4_embbag_dedw_SLS_kernel_params.mode = EMBEDDED_SC_ZP;

    // create emb_4_embbag_dedw_grad_indices tensor
    const unsigned emb_4_embbag_dedw_grad_indices_sizes[] = {128,};
    uint64_t emb_4_embbag_dedw_grad_indices_dram;
    unsigned emb_4_embbag_dedw_grad_indices_size = 128;
    unsigned emb_4_embbag_dedw_grad_indices_size_in_bytes = emb_4_embbag_dedw_grad_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_4_embbag_dedw_grad_indices_size_in_bytes, &emb_4_embbag_dedw_grad_indices_dram, "emb_4_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_4_embbag_dedw_grad_indices dram malloc failed!");
    synLaunchTensorInfo emb_4_embbag_dedw_grad_indices_tr_info = {"emb_4_embbag_dedw_grad_indices",
                                                                  emb_4_embbag_dedw_grad_indices_dram};
    UNUSED(emb_4_embbag_dedw_grad_indices_tr_info); // For single op tests
    synTensor emb_4_embbag_dedw_grad_indices = createTensor(1U, syn_type_int32, emb_4_embbag_dedw_grad_indices_sizes, true, "emb_4_embbag_dedw_grad_indices");
    UNUSED(emb_4_embbag_dedw_grad_indices); // For single op tests

    // create emb_4_embbag_dedw_lengths tensor
    const unsigned emb_4_embbag_dedw_lengths_sizes[] = {128,};
    uint64_t emb_4_embbag_dedw_lengths_dram;
    unsigned emb_4_embbag_dedw_lengths_size = 128;
    unsigned emb_4_embbag_dedw_lengths_size_in_bytes = emb_4_embbag_dedw_lengths_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_4_embbag_dedw_lengths_size_in_bytes, &emb_4_embbag_dedw_lengths_dram, "emb_4_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_4_embbag_dedw_lengths dram malloc failed!");
    synLaunchTensorInfo emb_4_embbag_dedw_lengths_tr_info = {"emb_4_embbag_dedw_lengths",
                                                             emb_4_embbag_dedw_lengths_dram};
    UNUSED(emb_4_embbag_dedw_lengths_tr_info); // For single op tests
    synTensor emb_4_embbag_dedw_lengths = createTensor(1U, syn_type_int32, emb_4_embbag_dedw_lengths_sizes, true, "emb_4_embbag_dedw_lengths");
    UNUSED(emb_4_embbag_dedw_lengths); // For single op tests

    // create emb_4_embbag_valid_indices tensor
    const unsigned emb_4_embbag_valid_indices_sizes[] = {1,};
    uint64_t emb_4_embbag_valid_indices_dram;
    unsigned emb_4_embbag_valid_indices_size = 1;
    unsigned emb_4_embbag_valid_indices_size_in_bytes = emb_4_embbag_valid_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_4_embbag_valid_indices_size_in_bytes, &emb_4_embbag_valid_indices_dram, "emb_4_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_4_embbag_valid_indices dram malloc failed!");
    synLaunchTensorInfo emb_4_embbag_valid_indices_tr_info = {"emb_4_embbag_valid_indices",
                                                              emb_4_embbag_valid_indices_dram};
    UNUSED(emb_4_embbag_valid_indices_tr_info); // For single op tests
    synTensor emb_4_embbag_valid_indices = createTensor(1U, syn_type_int32, emb_4_embbag_valid_indices_sizes, true, "emb_4_embbag_valid_indices");
    UNUSED(emb_4_embbag_valid_indices); // For single op tests

    synTensor emb_4_embbag_dedw_SLS_in_vec[4] = {concat_interact0_grad_input5, emb_4_embbag_dedw_grad_indices, emb_4_embbag_dedw_lengths, emb_4_embbag_valid_indices};


    // create emb_4_embbag_dedw_grad_inter tensor
    const unsigned emb_4_embbag_dedw_grad_inter_sizes[] = {128, 32};
    synTensor emb_4_embbag_dedw_grad_inter = createTensor(2U, syn_type_single, emb_4_embbag_dedw_grad_inter_sizes, false, "emb_4_embbag_dedw_grad_inter");
    UNUSED(emb_4_embbag_dedw_grad_inter); // For single op tests

    synTensor emb_4_embbag_dedw_SLS_out_vec[1] = {emb_4_embbag_dedw_grad_inter};


    status = synNodeCreate(graphHandle, emb_4_embbag_dedw_SLS_in_vec, emb_4_embbag_dedw_SLS_out_vec, 4, 1, (void *)&emb_4_embbag_dedw_SLS_kernel_params, sizeof(emb_4_embbag_dedw_SLS_kernel_params), "sparse_lengths_sum_fwd_f32", "emb_4_embbag_dedw_SLS", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_4_embbag_dedw_SLS failed!");

    /*************
     * emb_4_embbag_dedw_EMB node
     * inputs: [emb_4_embbag_dedw_grad_inter(128, 32)(dtype=float32), emb_4_embbag_weight_golden[305, 32](dtype=float32), emb_4_embbag_momentum[305, 32](dtype=float32), emb_4_embbag_dedw_param_table_indices[128](dtype=int32), emb_4_offset_shape[128](dtype=int32), emb_0_embbag_timestamp[1](dtype=int32), emb_0_embbag_rate[1](dtype=float32), emb_4_embbag_valid_indices[1](dtype=int32), emb_4_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_4_embbag_dedw_weight_output_golden(305, 32)(dtype=float32), emb_4_embbag_dedw_momentum_output(305, 32)(dtype=float32), emb_4_embbag_dedw_weight_output(305, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_4_embbag_dedw_EMB_kernel_params;
    emb_4_embbag_dedw_EMB_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_4_embbag_dedw_EMB_kernel_params.sgd.wd = 0;
    emb_4_embbag_dedw_EMB_kernel_params.sgd.mom = 1;
    emb_4_embbag_dedw_EMB_kernel_params.sgd.damp = 0;
    emb_4_embbag_dedw_EMB_kernel_params.sgd.nesterov = false;

    // create emb_4_embbag_weight_golden tensor
    const unsigned emb_4_embbag_weight_golden_sizes[] = {305, 32};
    uint64_t emb_4_embbag_weight_golden_dram;
    unsigned emb_4_embbag_weight_golden_size = 305*32;
    unsigned emb_4_embbag_weight_golden_size_in_bytes = emb_4_embbag_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(emb_4_embbag_weight_golden_size_in_bytes, &emb_4_embbag_weight_golden_dram, "emb_4_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_4_embbag_weight_golden dram malloc failed!");
    synLaunchTensorInfo emb_4_embbag_weight_golden_tr_info = {"emb_4_embbag_weight_golden",
                                                              emb_4_embbag_weight_golden_dram};
    UNUSED(emb_4_embbag_weight_golden_tr_info); // For single op tests
    synTensor emb_4_embbag_weight_golden = createTensor(2U, syn_type_single, emb_4_embbag_weight_golden_sizes, true, "emb_4_embbag_weight_golden");
    UNUSED(emb_4_embbag_weight_golden); // For single op tests

    // create emb_4_embbag_momentum tensor
    const unsigned emb_4_embbag_momentum_sizes[] = {305, 32};
    uint64_t emb_4_embbag_momentum_dram;
    unsigned emb_4_embbag_momentum_size = 305*32;
    unsigned emb_4_embbag_momentum_size_in_bytes = emb_4_embbag_momentum_size * sizeof(float) ;
    status = hbmAlloc(emb_4_embbag_momentum_size_in_bytes, &emb_4_embbag_momentum_dram, "emb_4_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_4_embbag_momentum dram malloc failed!");
    synLaunchTensorInfo emb_4_embbag_momentum_tr_info = {"emb_4_embbag_momentum", emb_4_embbag_momentum_dram};
    UNUSED(emb_4_embbag_momentum_tr_info); // For single op tests
    synTensor emb_4_embbag_momentum = createTensor(2U, syn_type_single, emb_4_embbag_momentum_sizes, true, "emb_4_embbag_momentum");
    UNUSED(emb_4_embbag_momentum); // For single op tests

    // create emb_4_embbag_dedw_param_table_indices tensor
    const unsigned emb_4_embbag_dedw_param_table_indices_sizes[] = {128,};
    uint64_t emb_4_embbag_dedw_param_table_indices_dram;
    unsigned emb_4_embbag_dedw_param_table_indices_size = 128;
    unsigned emb_4_embbag_dedw_param_table_indices_size_in_bytes = emb_4_embbag_dedw_param_table_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_4_embbag_dedw_param_table_indices_size_in_bytes, &emb_4_embbag_dedw_param_table_indices_dram, "emb_4_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_4_embbag_dedw_param_table_indices dram malloc failed!");
    synLaunchTensorInfo emb_4_embbag_dedw_param_table_indices_tr_info = {"emb_4_embbag_dedw_param_table_indices",
                                                                         emb_4_embbag_dedw_param_table_indices_dram};
    UNUSED(emb_4_embbag_dedw_param_table_indices_tr_info); // For single op tests
    synTensor emb_4_embbag_dedw_param_table_indices = createTensor(1U, syn_type_int32, emb_4_embbag_dedw_param_table_indices_sizes, true, "emb_4_embbag_dedw_param_table_indices");
    UNUSED(emb_4_embbag_dedw_param_table_indices); // For single op tests

    // create emb_4_offset_shape tensor
    const unsigned emb_4_offset_shape_sizes[] = {128,};
    uint64_t emb_4_offset_shape_dram;
    unsigned emb_4_offset_shape_size = 128;
    unsigned emb_4_offset_shape_size_in_bytes = emb_4_offset_shape_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_4_offset_shape_size_in_bytes, &emb_4_offset_shape_dram, "emb_4_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_4_offset_shape dram malloc failed!");
    synLaunchTensorInfo emb_4_offset_shape_tr_info = {"emb_4_offset_shape", emb_4_offset_shape_dram};
    UNUSED(emb_4_offset_shape_tr_info); // For single op tests
    synTensor emb_4_offset_shape = createTensor(1U, syn_type_int32, emb_4_offset_shape_sizes, true, "emb_4_offset_shape");
    UNUSED(emb_4_offset_shape); // For single op tests

    synTensor emb_4_embbag_dedw_EMB_in_vec[9] = {emb_4_embbag_dedw_grad_inter, emb_4_embbag_weight_golden, emb_4_embbag_momentum, emb_4_embbag_dedw_param_table_indices, emb_4_offset_shape, emb_0_embbag_timestamp, emb_0_embbag_rate, emb_4_embbag_valid_indices, emb_4_embbag_valid_indices};


    // create emb_4_embbag_dedw_weight_output_golden tensor
    const unsigned emb_4_embbag_dedw_weight_output_golden_sizes[] = {305, 32};
    uint64_t emb_4_embbag_dedw_weight_output_golden_dram = emb_4_embbag_weight_golden_dram;
    synLaunchTensorInfo emb_4_embbag_dedw_weight_output_golden_tr_info = {"emb_4_embbag_dedw_weight_output_golden",
                                                                          emb_4_embbag_dedw_weight_output_golden_dram};
    UNUSED(emb_4_embbag_dedw_weight_output_golden_tr_info); // For single op tests
    synTensor emb_4_embbag_dedw_weight_output_golden = createTensor(2U, syn_type_single, emb_4_embbag_dedw_weight_output_golden_sizes, true, "emb_4_embbag_dedw_weight_output_golden");
    UNUSED(emb_4_embbag_dedw_weight_output_golden); // For single op tests

    // create emb_4_embbag_dedw_momentum_output tensor
    const unsigned emb_4_embbag_dedw_momentum_output_sizes[] = {305, 32};
    uint64_t emb_4_embbag_dedw_momentum_output_dram;
    unsigned emb_4_embbag_dedw_momentum_output_size = 305*32;
    unsigned emb_4_embbag_dedw_momentum_output_size_in_bytes = emb_4_embbag_dedw_momentum_output_size * sizeof(float) ;
    status = hbmAlloc(emb_4_embbag_dedw_momentum_output_size_in_bytes, &emb_4_embbag_dedw_momentum_output_dram, "emb_4_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_4_embbag_dedw_momentum_output dram malloc failed!");
    synLaunchTensorInfo emb_4_embbag_dedw_momentum_output_tr_info = {"emb_4_embbag_dedw_momentum_output",
                                                                     emb_4_embbag_dedw_momentum_output_dram};
    UNUSED(emb_4_embbag_dedw_momentum_output_tr_info); // For single op tests
    synTensor emb_4_embbag_dedw_momentum_output = createTensor(2U, syn_type_single, emb_4_embbag_dedw_momentum_output_sizes, true, "emb_4_embbag_dedw_momentum_output");
    UNUSED(emb_4_embbag_dedw_momentum_output); // For single op tests

    // create emb_4_embbag_dedw_weight_output tensor
    const unsigned emb_4_embbag_dedw_weight_output_sizes[] = {305, 32};
    uint64_t emb_4_embbag_dedw_weight_output_dram = emb_4_embbag_weight_dram;
    synLaunchTensorInfo emb_4_embbag_dedw_weight_output_tr_info = {"emb_4_embbag_dedw_weight_output",
                                                                   emb_4_embbag_dedw_weight_output_dram};
    UNUSED(emb_4_embbag_dedw_weight_output_tr_info); // For single op tests
    synTensor emb_4_embbag_dedw_weight_output = createTensor(2U, syn_type_bf16, emb_4_embbag_dedw_weight_output_sizes, true, "emb_4_embbag_dedw_weight_output");
    UNUSED(emb_4_embbag_dedw_weight_output); // For single op tests

    synTensor emb_4_embbag_dedw_EMB_out_vec[3] = {emb_4_embbag_dedw_weight_output_golden, emb_4_embbag_dedw_momentum_output, emb_4_embbag_dedw_weight_output};


    status = synNodeCreate(graphHandle, emb_4_embbag_dedw_EMB_in_vec, emb_4_embbag_dedw_EMB_out_vec, 9, 3, (void *)&emb_4_embbag_dedw_EMB_kernel_params, sizeof(emb_4_embbag_dedw_EMB_kernel_params), "embedding_bag_sgd_bwd_f32", "emb_4_embbag_dedw_EMB", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_4_embbag_dedw_EMB failed!");

    /*************
     * emb_5_embbag_dedw_SLS node
     * inputs: [concat_interact0_grad_input6(128, 32)(dtype=float32), emb_5_embbag_dedw_grad_indices[128](dtype=int32), emb_5_embbag_dedw_lengths[128](dtype=int32), emb_5_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_5_embbag_dedw_grad_inter(128, 32)(dtype=float32)]
     *************/
    ns_SparseLengthsSum::Params emb_5_embbag_dedw_SLS_kernel_params;
    emb_5_embbag_dedw_SLS_kernel_params.mode = EMBEDDED_SC_ZP;

    // create emb_5_embbag_dedw_grad_indices tensor
    const unsigned emb_5_embbag_dedw_grad_indices_sizes[] = {128,};
    uint64_t emb_5_embbag_dedw_grad_indices_dram;
    unsigned emb_5_embbag_dedw_grad_indices_size = 128;
    unsigned emb_5_embbag_dedw_grad_indices_size_in_bytes = emb_5_embbag_dedw_grad_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_5_embbag_dedw_grad_indices_size_in_bytes, &emb_5_embbag_dedw_grad_indices_dram, "emb_5_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_5_embbag_dedw_grad_indices dram malloc failed!");
    synLaunchTensorInfo emb_5_embbag_dedw_grad_indices_tr_info = {"emb_5_embbag_dedw_grad_indices",
                                                                  emb_5_embbag_dedw_grad_indices_dram};
    UNUSED(emb_5_embbag_dedw_grad_indices_tr_info); // For single op tests
    synTensor emb_5_embbag_dedw_grad_indices = createTensor(1U, syn_type_int32, emb_5_embbag_dedw_grad_indices_sizes, true, "emb_5_embbag_dedw_grad_indices");
    UNUSED(emb_5_embbag_dedw_grad_indices); // For single op tests

    // create emb_5_embbag_dedw_lengths tensor
    const unsigned emb_5_embbag_dedw_lengths_sizes[] = {128,};
    uint64_t emb_5_embbag_dedw_lengths_dram;
    unsigned emb_5_embbag_dedw_lengths_size = 128;
    unsigned emb_5_embbag_dedw_lengths_size_in_bytes = emb_5_embbag_dedw_lengths_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_5_embbag_dedw_lengths_size_in_bytes, &emb_5_embbag_dedw_lengths_dram, "emb_5_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_5_embbag_dedw_lengths dram malloc failed!");
    synLaunchTensorInfo emb_5_embbag_dedw_lengths_tr_info = {"emb_5_embbag_dedw_lengths",
                                                             emb_5_embbag_dedw_lengths_dram};
    UNUSED(emb_5_embbag_dedw_lengths_tr_info); // For single op tests
    synTensor emb_5_embbag_dedw_lengths = createTensor(1U, syn_type_int32, emb_5_embbag_dedw_lengths_sizes, true, "emb_5_embbag_dedw_lengths");
    UNUSED(emb_5_embbag_dedw_lengths); // For single op tests

    // create emb_5_embbag_valid_indices tensor
    const unsigned emb_5_embbag_valid_indices_sizes[] = {1,};
    uint64_t emb_5_embbag_valid_indices_dram;
    unsigned emb_5_embbag_valid_indices_size = 1;
    unsigned emb_5_embbag_valid_indices_size_in_bytes = emb_5_embbag_valid_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_5_embbag_valid_indices_size_in_bytes, &emb_5_embbag_valid_indices_dram, "emb_5_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_5_embbag_valid_indices dram malloc failed!");
    synLaunchTensorInfo emb_5_embbag_valid_indices_tr_info = {"emb_5_embbag_valid_indices",
                                                              emb_5_embbag_valid_indices_dram};
    UNUSED(emb_5_embbag_valid_indices_tr_info); // For single op tests
    synTensor emb_5_embbag_valid_indices = createTensor(1U, syn_type_int32, emb_5_embbag_valid_indices_sizes, true, "emb_5_embbag_valid_indices");
    UNUSED(emb_5_embbag_valid_indices); // For single op tests

    synTensor emb_5_embbag_dedw_SLS_in_vec[4] = {concat_interact0_grad_input6, emb_5_embbag_dedw_grad_indices, emb_5_embbag_dedw_lengths, emb_5_embbag_valid_indices};


    // create emb_5_embbag_dedw_grad_inter tensor
    const unsigned emb_5_embbag_dedw_grad_inter_sizes[] = {128, 32};
    synTensor emb_5_embbag_dedw_grad_inter = createTensor(2U, syn_type_single, emb_5_embbag_dedw_grad_inter_sizes, false, "emb_5_embbag_dedw_grad_inter");
    UNUSED(emb_5_embbag_dedw_grad_inter); // For single op tests

    synTensor emb_5_embbag_dedw_SLS_out_vec[1] = {emb_5_embbag_dedw_grad_inter};


    status = synNodeCreate(graphHandle, emb_5_embbag_dedw_SLS_in_vec, emb_5_embbag_dedw_SLS_out_vec, 4, 1, (void *)&emb_5_embbag_dedw_SLS_kernel_params, sizeof(emb_5_embbag_dedw_SLS_kernel_params), "sparse_lengths_sum_fwd_f32", "emb_5_embbag_dedw_SLS", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_5_embbag_dedw_SLS failed!");

    /*************
     * emb_5_embbag_dedw_EMB node
     * inputs: [emb_5_embbag_dedw_grad_inter(128, 32)(dtype=float32), emb_5_embbag_weight_golden[24, 32](dtype=float32), emb_5_embbag_momentum[24, 32](dtype=float32), emb_5_embbag_dedw_param_table_indices[128](dtype=int32), emb_5_offset_shape[128](dtype=int32), emb_0_embbag_timestamp[1](dtype=int32), emb_0_embbag_rate[1](dtype=float32), emb_5_embbag_valid_indices[1](dtype=int32), emb_5_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_5_embbag_dedw_weight_output_golden(24, 32)(dtype=float32), emb_5_embbag_dedw_momentum_output(24, 32)(dtype=float32), emb_5_embbag_dedw_weight_output(24, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_5_embbag_dedw_EMB_kernel_params;
    emb_5_embbag_dedw_EMB_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_5_embbag_dedw_EMB_kernel_params.sgd.wd = 0;
    emb_5_embbag_dedw_EMB_kernel_params.sgd.mom = 1;
    emb_5_embbag_dedw_EMB_kernel_params.sgd.damp = 0;
    emb_5_embbag_dedw_EMB_kernel_params.sgd.nesterov = false;

    // create emb_5_embbag_weight_golden tensor
    const unsigned emb_5_embbag_weight_golden_sizes[] = {24, 32};
    uint64_t emb_5_embbag_weight_golden_dram;
    unsigned emb_5_embbag_weight_golden_size = 24*32;
    unsigned emb_5_embbag_weight_golden_size_in_bytes = emb_5_embbag_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(emb_5_embbag_weight_golden_size_in_bytes, &emb_5_embbag_weight_golden_dram, "emb_5_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_5_embbag_weight_golden dram malloc failed!");
    synLaunchTensorInfo emb_5_embbag_weight_golden_tr_info = {"emb_5_embbag_weight_golden",
                                                              emb_5_embbag_weight_golden_dram};
    UNUSED(emb_5_embbag_weight_golden_tr_info); // For single op tests
    synTensor emb_5_embbag_weight_golden = createTensor(2U, syn_type_single, emb_5_embbag_weight_golden_sizes, true, "emb_5_embbag_weight_golden");
    UNUSED(emb_5_embbag_weight_golden); // For single op tests

    // create emb_5_embbag_momentum tensor
    const unsigned emb_5_embbag_momentum_sizes[] = {24, 32};
    uint64_t emb_5_embbag_momentum_dram;
    unsigned emb_5_embbag_momentum_size = 24*32;
    unsigned emb_5_embbag_momentum_size_in_bytes = emb_5_embbag_momentum_size * sizeof(float) ;
    status = hbmAlloc(emb_5_embbag_momentum_size_in_bytes, &emb_5_embbag_momentum_dram, "emb_5_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_5_embbag_momentum dram malloc failed!");
    synLaunchTensorInfo emb_5_embbag_momentum_tr_info = {"emb_5_embbag_momentum", emb_5_embbag_momentum_dram};
    UNUSED(emb_5_embbag_momentum_tr_info); // For single op tests
    synTensor emb_5_embbag_momentum = createTensor(2U, syn_type_single, emb_5_embbag_momentum_sizes, true, "emb_5_embbag_momentum");
    UNUSED(emb_5_embbag_momentum); // For single op tests

    // create emb_5_embbag_dedw_param_table_indices tensor
    const unsigned emb_5_embbag_dedw_param_table_indices_sizes[] = {128,};
    uint64_t emb_5_embbag_dedw_param_table_indices_dram;
    unsigned emb_5_embbag_dedw_param_table_indices_size = 128;
    unsigned emb_5_embbag_dedw_param_table_indices_size_in_bytes = emb_5_embbag_dedw_param_table_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_5_embbag_dedw_param_table_indices_size_in_bytes, &emb_5_embbag_dedw_param_table_indices_dram, "emb_5_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_5_embbag_dedw_param_table_indices dram malloc failed!");
    synLaunchTensorInfo emb_5_embbag_dedw_param_table_indices_tr_info = {"emb_5_embbag_dedw_param_table_indices",
                                                                         emb_5_embbag_dedw_param_table_indices_dram};
    UNUSED(emb_5_embbag_dedw_param_table_indices_tr_info); // For single op tests
    synTensor emb_5_embbag_dedw_param_table_indices = createTensor(1U, syn_type_int32, emb_5_embbag_dedw_param_table_indices_sizes, true, "emb_5_embbag_dedw_param_table_indices");
    UNUSED(emb_5_embbag_dedw_param_table_indices); // For single op tests

    // create emb_5_offset_shape tensor
    const unsigned emb_5_offset_shape_sizes[] = {128,};
    uint64_t emb_5_offset_shape_dram;
    unsigned emb_5_offset_shape_size = 128;
    unsigned emb_5_offset_shape_size_in_bytes = emb_5_offset_shape_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_5_offset_shape_size_in_bytes, &emb_5_offset_shape_dram, "emb_5_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_5_offset_shape dram malloc failed!");
    synLaunchTensorInfo emb_5_offset_shape_tr_info = {"emb_5_offset_shape", emb_5_offset_shape_dram};
    UNUSED(emb_5_offset_shape_tr_info); // For single op tests
    synTensor emb_5_offset_shape = createTensor(1U, syn_type_int32, emb_5_offset_shape_sizes, true, "emb_5_offset_shape");
    UNUSED(emb_5_offset_shape); // For single op tests

    synTensor emb_5_embbag_dedw_EMB_in_vec[9] = {emb_5_embbag_dedw_grad_inter, emb_5_embbag_weight_golden, emb_5_embbag_momentum, emb_5_embbag_dedw_param_table_indices, emb_5_offset_shape, emb_0_embbag_timestamp, emb_0_embbag_rate, emb_5_embbag_valid_indices, emb_5_embbag_valid_indices};


    // create emb_5_embbag_dedw_weight_output_golden tensor
    const unsigned emb_5_embbag_dedw_weight_output_golden_sizes[] = {24, 32};
    uint64_t emb_5_embbag_dedw_weight_output_golden_dram = emb_5_embbag_weight_golden_dram;
    synLaunchTensorInfo emb_5_embbag_dedw_weight_output_golden_tr_info = {"emb_5_embbag_dedw_weight_output_golden",
                                                                          emb_5_embbag_dedw_weight_output_golden_dram};
    UNUSED(emb_5_embbag_dedw_weight_output_golden_tr_info); // For single op tests
    synTensor emb_5_embbag_dedw_weight_output_golden = createTensor(2U, syn_type_single, emb_5_embbag_dedw_weight_output_golden_sizes, true, "emb_5_embbag_dedw_weight_output_golden");
    UNUSED(emb_5_embbag_dedw_weight_output_golden); // For single op tests

    // create emb_5_embbag_dedw_momentum_output tensor
    const unsigned emb_5_embbag_dedw_momentum_output_sizes[] = {24, 32};
    uint64_t emb_5_embbag_dedw_momentum_output_dram;
    unsigned emb_5_embbag_dedw_momentum_output_size = 24*32;
    unsigned emb_5_embbag_dedw_momentum_output_size_in_bytes = emb_5_embbag_dedw_momentum_output_size * sizeof(float) ;
    status = hbmAlloc(emb_5_embbag_dedw_momentum_output_size_in_bytes, &emb_5_embbag_dedw_momentum_output_dram, "emb_5_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_5_embbag_dedw_momentum_output dram malloc failed!");
    synLaunchTensorInfo emb_5_embbag_dedw_momentum_output_tr_info = {"emb_5_embbag_dedw_momentum_output",
                                                                     emb_5_embbag_dedw_momentum_output_dram};
    UNUSED(emb_5_embbag_dedw_momentum_output_tr_info); // For single op tests
    synTensor emb_5_embbag_dedw_momentum_output = createTensor(2U, syn_type_single, emb_5_embbag_dedw_momentum_output_sizes, true, "emb_5_embbag_dedw_momentum_output");
    UNUSED(emb_5_embbag_dedw_momentum_output); // For single op tests

    // create emb_5_embbag_dedw_weight_output tensor
    const unsigned emb_5_embbag_dedw_weight_output_sizes[] = {24, 32};
    uint64_t emb_5_embbag_dedw_weight_output_dram = emb_5_embbag_weight_dram;
    synLaunchTensorInfo emb_5_embbag_dedw_weight_output_tr_info = {"emb_5_embbag_dedw_weight_output",
                                                                   emb_5_embbag_dedw_weight_output_dram};
    UNUSED(emb_5_embbag_dedw_weight_output_tr_info); // For single op tests
    synTensor emb_5_embbag_dedw_weight_output = createTensor(2U, syn_type_bf16, emb_5_embbag_dedw_weight_output_sizes, true, "emb_5_embbag_dedw_weight_output");
    UNUSED(emb_5_embbag_dedw_weight_output); // For single op tests

    synTensor emb_5_embbag_dedw_EMB_out_vec[3] = {emb_5_embbag_dedw_weight_output_golden, emb_5_embbag_dedw_momentum_output, emb_5_embbag_dedw_weight_output};


    status = synNodeCreate(graphHandle, emb_5_embbag_dedw_EMB_in_vec, emb_5_embbag_dedw_EMB_out_vec, 9, 3, (void *)&emb_5_embbag_dedw_EMB_kernel_params, sizeof(emb_5_embbag_dedw_EMB_kernel_params), "embedding_bag_sgd_bwd_f32", "emb_5_embbag_dedw_EMB", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_5_embbag_dedw_EMB failed!");

    /*************
     * emb_6_embbag_dedw_SLS node
     * inputs: [concat_interact0_grad_input7(128, 32)(dtype=float32), emb_6_embbag_dedw_grad_indices[128](dtype=int32), emb_6_embbag_dedw_lengths[128](dtype=int32), emb_6_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_6_embbag_dedw_grad_inter(128, 32)(dtype=float32)]
     *************/
    ns_SparseLengthsSum::Params emb_6_embbag_dedw_SLS_kernel_params;
    emb_6_embbag_dedw_SLS_kernel_params.mode = EMBEDDED_SC_ZP;

    // create emb_6_embbag_dedw_grad_indices tensor
    const unsigned emb_6_embbag_dedw_grad_indices_sizes[] = {128,};
    uint64_t emb_6_embbag_dedw_grad_indices_dram;
    unsigned emb_6_embbag_dedw_grad_indices_size = 128;
    unsigned emb_6_embbag_dedw_grad_indices_size_in_bytes = emb_6_embbag_dedw_grad_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_6_embbag_dedw_grad_indices_size_in_bytes, &emb_6_embbag_dedw_grad_indices_dram, "emb_6_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_6_embbag_dedw_grad_indices dram malloc failed!");
    synLaunchTensorInfo emb_6_embbag_dedw_grad_indices_tr_info = {"emb_6_embbag_dedw_grad_indices",
                                                                  emb_6_embbag_dedw_grad_indices_dram};
    UNUSED(emb_6_embbag_dedw_grad_indices_tr_info); // For single op tests
    synTensor emb_6_embbag_dedw_grad_indices = createTensor(1U, syn_type_int32, emb_6_embbag_dedw_grad_indices_sizes, true, "emb_6_embbag_dedw_grad_indices");
    UNUSED(emb_6_embbag_dedw_grad_indices); // For single op tests

    // create emb_6_embbag_dedw_lengths tensor
    const unsigned emb_6_embbag_dedw_lengths_sizes[] = {128,};
    uint64_t emb_6_embbag_dedw_lengths_dram;
    unsigned emb_6_embbag_dedw_lengths_size = 128;
    unsigned emb_6_embbag_dedw_lengths_size_in_bytes = emb_6_embbag_dedw_lengths_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_6_embbag_dedw_lengths_size_in_bytes, &emb_6_embbag_dedw_lengths_dram, "emb_6_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_6_embbag_dedw_lengths dram malloc failed!");
    synLaunchTensorInfo emb_6_embbag_dedw_lengths_tr_info = {"emb_6_embbag_dedw_lengths",
                                                             emb_6_embbag_dedw_lengths_dram};
    UNUSED(emb_6_embbag_dedw_lengths_tr_info); // For single op tests
    synTensor emb_6_embbag_dedw_lengths = createTensor(1U, syn_type_int32, emb_6_embbag_dedw_lengths_sizes, true, "emb_6_embbag_dedw_lengths");
    UNUSED(emb_6_embbag_dedw_lengths); // For single op tests

    // create emb_6_embbag_valid_indices tensor
    const unsigned emb_6_embbag_valid_indices_sizes[] = {1,};
    uint64_t emb_6_embbag_valid_indices_dram;
    unsigned emb_6_embbag_valid_indices_size = 1;
    unsigned emb_6_embbag_valid_indices_size_in_bytes = emb_6_embbag_valid_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_6_embbag_valid_indices_size_in_bytes, &emb_6_embbag_valid_indices_dram, "emb_6_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_6_embbag_valid_indices dram malloc failed!");
    synLaunchTensorInfo emb_6_embbag_valid_indices_tr_info = {"emb_6_embbag_valid_indices",
                                                              emb_6_embbag_valid_indices_dram};
    UNUSED(emb_6_embbag_valid_indices_tr_info); // For single op tests
    synTensor emb_6_embbag_valid_indices = createTensor(1U, syn_type_int32, emb_6_embbag_valid_indices_sizes, true, "emb_6_embbag_valid_indices");
    UNUSED(emb_6_embbag_valid_indices); // For single op tests

    synTensor emb_6_embbag_dedw_SLS_in_vec[4] = {concat_interact0_grad_input7, emb_6_embbag_dedw_grad_indices, emb_6_embbag_dedw_lengths, emb_6_embbag_valid_indices};


    // create emb_6_embbag_dedw_grad_inter tensor
    const unsigned emb_6_embbag_dedw_grad_inter_sizes[] = {128, 32};
    synTensor emb_6_embbag_dedw_grad_inter = createTensor(2U, syn_type_single, emb_6_embbag_dedw_grad_inter_sizes, false, "emb_6_embbag_dedw_grad_inter");
    UNUSED(emb_6_embbag_dedw_grad_inter); // For single op tests

    synTensor emb_6_embbag_dedw_SLS_out_vec[1] = {emb_6_embbag_dedw_grad_inter};


    status = synNodeCreate(graphHandle, emb_6_embbag_dedw_SLS_in_vec, emb_6_embbag_dedw_SLS_out_vec, 4, 1, (void *)&emb_6_embbag_dedw_SLS_kernel_params, sizeof(emb_6_embbag_dedw_SLS_kernel_params), "sparse_lengths_sum_fwd_f32", "emb_6_embbag_dedw_SLS", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_6_embbag_dedw_SLS failed!");

    /*************
     * emb_6_embbag_dedw_EMB node
     * inputs: [emb_6_embbag_dedw_grad_inter(128, 32)(dtype=float32), emb_6_embbag_weight_golden[12453, 32](dtype=float32), emb_6_embbag_momentum[12453, 32](dtype=float32), emb_6_embbag_dedw_param_table_indices[128](dtype=int32), emb_6_offset_shape[128](dtype=int32), emb_0_embbag_timestamp[1](dtype=int32), emb_0_embbag_rate[1](dtype=float32), emb_6_embbag_valid_indices[1](dtype=int32), emb_6_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_6_embbag_dedw_weight_output_golden(12453, 32)(dtype=float32), emb_6_embbag_dedw_momentum_output(12453, 32)(dtype=float32), emb_6_embbag_dedw_weight_output(12453, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_6_embbag_dedw_EMB_kernel_params;
    emb_6_embbag_dedw_EMB_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_6_embbag_dedw_EMB_kernel_params.sgd.wd = 0;
    emb_6_embbag_dedw_EMB_kernel_params.sgd.mom = 1;
    emb_6_embbag_dedw_EMB_kernel_params.sgd.damp = 0;
    emb_6_embbag_dedw_EMB_kernel_params.sgd.nesterov = false;

    // create emb_6_embbag_weight_golden tensor
    const unsigned emb_6_embbag_weight_golden_sizes[] = {12453, 32};
    uint64_t emb_6_embbag_weight_golden_dram;
    unsigned emb_6_embbag_weight_golden_size = 12453*32;
    unsigned emb_6_embbag_weight_golden_size_in_bytes = emb_6_embbag_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(emb_6_embbag_weight_golden_size_in_bytes, &emb_6_embbag_weight_golden_dram, "emb_6_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_6_embbag_weight_golden dram malloc failed!");
    synLaunchTensorInfo emb_6_embbag_weight_golden_tr_info = {"emb_6_embbag_weight_golden",
                                                              emb_6_embbag_weight_golden_dram};
    UNUSED(emb_6_embbag_weight_golden_tr_info); // For single op tests
    synTensor emb_6_embbag_weight_golden = createTensor(2U, syn_type_single, emb_6_embbag_weight_golden_sizes, true, "emb_6_embbag_weight_golden");
    UNUSED(emb_6_embbag_weight_golden); // For single op tests

    // create emb_6_embbag_momentum tensor
    const unsigned emb_6_embbag_momentum_sizes[] = {12453, 32};
    uint64_t emb_6_embbag_momentum_dram;
    unsigned emb_6_embbag_momentum_size = 12453*32;
    unsigned emb_6_embbag_momentum_size_in_bytes = emb_6_embbag_momentum_size * sizeof(float) ;
    status = hbmAlloc(emb_6_embbag_momentum_size_in_bytes, &emb_6_embbag_momentum_dram, "emb_6_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_6_embbag_momentum dram malloc failed!");
    synLaunchTensorInfo emb_6_embbag_momentum_tr_info = {"emb_6_embbag_momentum", emb_6_embbag_momentum_dram};
    UNUSED(emb_6_embbag_momentum_tr_info); // For single op tests
    synTensor emb_6_embbag_momentum = createTensor(2U, syn_type_single, emb_6_embbag_momentum_sizes, true, "emb_6_embbag_momentum");
    UNUSED(emb_6_embbag_momentum); // For single op tests

    // create emb_6_embbag_dedw_param_table_indices tensor
    const unsigned emb_6_embbag_dedw_param_table_indices_sizes[] = {128,};
    uint64_t emb_6_embbag_dedw_param_table_indices_dram;
    unsigned emb_6_embbag_dedw_param_table_indices_size = 128;
    unsigned emb_6_embbag_dedw_param_table_indices_size_in_bytes = emb_6_embbag_dedw_param_table_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_6_embbag_dedw_param_table_indices_size_in_bytes, &emb_6_embbag_dedw_param_table_indices_dram, "emb_6_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_6_embbag_dedw_param_table_indices dram malloc failed!");
    synLaunchTensorInfo emb_6_embbag_dedw_param_table_indices_tr_info = {"emb_6_embbag_dedw_param_table_indices",
                                                                         emb_6_embbag_dedw_param_table_indices_dram};
    UNUSED(emb_6_embbag_dedw_param_table_indices_tr_info); // For single op tests
    synTensor emb_6_embbag_dedw_param_table_indices = createTensor(1U, syn_type_int32, emb_6_embbag_dedw_param_table_indices_sizes, true, "emb_6_embbag_dedw_param_table_indices");
    UNUSED(emb_6_embbag_dedw_param_table_indices); // For single op tests

    // create emb_6_offset_shape tensor
    const unsigned emb_6_offset_shape_sizes[] = {128,};
    uint64_t emb_6_offset_shape_dram;
    unsigned emb_6_offset_shape_size = 128;
    unsigned emb_6_offset_shape_size_in_bytes = emb_6_offset_shape_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_6_offset_shape_size_in_bytes, &emb_6_offset_shape_dram, "emb_6_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_6_offset_shape dram malloc failed!");
    synLaunchTensorInfo emb_6_offset_shape_tr_info = {"emb_6_offset_shape", emb_6_offset_shape_dram};
    UNUSED(emb_6_offset_shape_tr_info); // For single op tests
    synTensor emb_6_offset_shape = createTensor(1U, syn_type_int32, emb_6_offset_shape_sizes, true, "emb_6_offset_shape");
    UNUSED(emb_6_offset_shape); // For single op tests

    synTensor emb_6_embbag_dedw_EMB_in_vec[9] = {emb_6_embbag_dedw_grad_inter, emb_6_embbag_weight_golden, emb_6_embbag_momentum, emb_6_embbag_dedw_param_table_indices, emb_6_offset_shape, emb_0_embbag_timestamp, emb_0_embbag_rate, emb_6_embbag_valid_indices, emb_6_embbag_valid_indices};


    // create emb_6_embbag_dedw_weight_output_golden tensor
    const unsigned emb_6_embbag_dedw_weight_output_golden_sizes[] = {12453, 32};
    uint64_t emb_6_embbag_dedw_weight_output_golden_dram = emb_6_embbag_weight_golden_dram;
    synLaunchTensorInfo emb_6_embbag_dedw_weight_output_golden_tr_info = {"emb_6_embbag_dedw_weight_output_golden",
                                                                          emb_6_embbag_dedw_weight_output_golden_dram};
    UNUSED(emb_6_embbag_dedw_weight_output_golden_tr_info); // For single op tests
    synTensor emb_6_embbag_dedw_weight_output_golden = createTensor(2U, syn_type_single, emb_6_embbag_dedw_weight_output_golden_sizes, true, "emb_6_embbag_dedw_weight_output_golden");
    UNUSED(emb_6_embbag_dedw_weight_output_golden); // For single op tests

    // create emb_6_embbag_dedw_momentum_output tensor
    const unsigned emb_6_embbag_dedw_momentum_output_sizes[] = {12453, 32};
    uint64_t emb_6_embbag_dedw_momentum_output_dram;
    unsigned emb_6_embbag_dedw_momentum_output_size = 12453*32;
    unsigned emb_6_embbag_dedw_momentum_output_size_in_bytes = emb_6_embbag_dedw_momentum_output_size * sizeof(float) ;
    status = hbmAlloc(emb_6_embbag_dedw_momentum_output_size_in_bytes, &emb_6_embbag_dedw_momentum_output_dram, "emb_6_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_6_embbag_dedw_momentum_output dram malloc failed!");
    synLaunchTensorInfo emb_6_embbag_dedw_momentum_output_tr_info = {"emb_6_embbag_dedw_momentum_output",
                                                                     emb_6_embbag_dedw_momentum_output_dram};
    UNUSED(emb_6_embbag_dedw_momentum_output_tr_info); // For single op tests
    synTensor emb_6_embbag_dedw_momentum_output = createTensor(2U, syn_type_single, emb_6_embbag_dedw_momentum_output_sizes, true, "emb_6_embbag_dedw_momentum_output");
    UNUSED(emb_6_embbag_dedw_momentum_output); // For single op tests

    // create emb_6_embbag_dedw_weight_output tensor
    const unsigned emb_6_embbag_dedw_weight_output_sizes[] = {12453, 32};
    uint64_t emb_6_embbag_dedw_weight_output_dram = emb_6_embbag_weight_dram;
    synLaunchTensorInfo emb_6_embbag_dedw_weight_output_tr_info = {"emb_6_embbag_dedw_weight_output",
                                                                   emb_6_embbag_dedw_weight_output_dram};
    UNUSED(emb_6_embbag_dedw_weight_output_tr_info); // For single op tests
    synTensor emb_6_embbag_dedw_weight_output = createTensor(2U, syn_type_bf16, emb_6_embbag_dedw_weight_output_sizes, true, "emb_6_embbag_dedw_weight_output");
    UNUSED(emb_6_embbag_dedw_weight_output); // For single op tests

    synTensor emb_6_embbag_dedw_EMB_out_vec[3] = {emb_6_embbag_dedw_weight_output_golden, emb_6_embbag_dedw_momentum_output, emb_6_embbag_dedw_weight_output};


    status = synNodeCreate(graphHandle, emb_6_embbag_dedw_EMB_in_vec, emb_6_embbag_dedw_EMB_out_vec, 9, 3, (void *)&emb_6_embbag_dedw_EMB_kernel_params, sizeof(emb_6_embbag_dedw_EMB_kernel_params), "embedding_bag_sgd_bwd_f32", "emb_6_embbag_dedw_EMB", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_6_embbag_dedw_EMB failed!");

    /*************
     * emb_7_embbag_dedw_SLS node
     * inputs: [concat_interact0_grad_input8(128, 32)(dtype=float32), emb_7_embbag_dedw_grad_indices[128](dtype=int32), emb_7_embbag_dedw_lengths[128](dtype=int32), emb_7_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_7_embbag_dedw_grad_inter(128, 32)(dtype=float32)]
     *************/
    ns_SparseLengthsSum::Params emb_7_embbag_dedw_SLS_kernel_params;
    emb_7_embbag_dedw_SLS_kernel_params.mode = EMBEDDED_SC_ZP;

    // create emb_7_embbag_dedw_grad_indices tensor
    const unsigned emb_7_embbag_dedw_grad_indices_sizes[] = {128,};
    uint64_t emb_7_embbag_dedw_grad_indices_dram;
    unsigned emb_7_embbag_dedw_grad_indices_size = 128;
    unsigned emb_7_embbag_dedw_grad_indices_size_in_bytes = emb_7_embbag_dedw_grad_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_7_embbag_dedw_grad_indices_size_in_bytes, &emb_7_embbag_dedw_grad_indices_dram, "emb_7_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_7_embbag_dedw_grad_indices dram malloc failed!");
    synLaunchTensorInfo emb_7_embbag_dedw_grad_indices_tr_info = {"emb_7_embbag_dedw_grad_indices",
                                                                  emb_7_embbag_dedw_grad_indices_dram};
    UNUSED(emb_7_embbag_dedw_grad_indices_tr_info); // For single op tests
    synTensor emb_7_embbag_dedw_grad_indices = createTensor(1U, syn_type_int32, emb_7_embbag_dedw_grad_indices_sizes, true, "emb_7_embbag_dedw_grad_indices");
    UNUSED(emb_7_embbag_dedw_grad_indices); // For single op tests

    // create emb_7_embbag_dedw_lengths tensor
    const unsigned emb_7_embbag_dedw_lengths_sizes[] = {128,};
    uint64_t emb_7_embbag_dedw_lengths_dram;
    unsigned emb_7_embbag_dedw_lengths_size = 128;
    unsigned emb_7_embbag_dedw_lengths_size_in_bytes = emb_7_embbag_dedw_lengths_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_7_embbag_dedw_lengths_size_in_bytes, &emb_7_embbag_dedw_lengths_dram, "emb_7_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_7_embbag_dedw_lengths dram malloc failed!");
    synLaunchTensorInfo emb_7_embbag_dedw_lengths_tr_info = {"emb_7_embbag_dedw_lengths",
                                                             emb_7_embbag_dedw_lengths_dram};
    UNUSED(emb_7_embbag_dedw_lengths_tr_info); // For single op tests
    synTensor emb_7_embbag_dedw_lengths = createTensor(1U, syn_type_int32, emb_7_embbag_dedw_lengths_sizes, true, "emb_7_embbag_dedw_lengths");
    UNUSED(emb_7_embbag_dedw_lengths); // For single op tests

    // create emb_7_embbag_valid_indices tensor
    const unsigned emb_7_embbag_valid_indices_sizes[] = {1,};
    uint64_t emb_7_embbag_valid_indices_dram;
    unsigned emb_7_embbag_valid_indices_size = 1;
    unsigned emb_7_embbag_valid_indices_size_in_bytes = emb_7_embbag_valid_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_7_embbag_valid_indices_size_in_bytes, &emb_7_embbag_valid_indices_dram, "emb_7_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_7_embbag_valid_indices dram malloc failed!");
    synLaunchTensorInfo emb_7_embbag_valid_indices_tr_info = {"emb_7_embbag_valid_indices",
                                                              emb_7_embbag_valid_indices_dram};
    UNUSED(emb_7_embbag_valid_indices_tr_info); // For single op tests
    synTensor emb_7_embbag_valid_indices = createTensor(1U, syn_type_int32, emb_7_embbag_valid_indices_sizes, true, "emb_7_embbag_valid_indices");
    UNUSED(emb_7_embbag_valid_indices); // For single op tests

    synTensor emb_7_embbag_dedw_SLS_in_vec[4] = {concat_interact0_grad_input8, emb_7_embbag_dedw_grad_indices, emb_7_embbag_dedw_lengths, emb_7_embbag_valid_indices};


    // create emb_7_embbag_dedw_grad_inter tensor
    const unsigned emb_7_embbag_dedw_grad_inter_sizes[] = {128, 32};
    synTensor emb_7_embbag_dedw_grad_inter = createTensor(2U, syn_type_single, emb_7_embbag_dedw_grad_inter_sizes, false, "emb_7_embbag_dedw_grad_inter");
    UNUSED(emb_7_embbag_dedw_grad_inter); // For single op tests

    synTensor emb_7_embbag_dedw_SLS_out_vec[1] = {emb_7_embbag_dedw_grad_inter};


    status = synNodeCreate(graphHandle, emb_7_embbag_dedw_SLS_in_vec, emb_7_embbag_dedw_SLS_out_vec, 4, 1, (void *)&emb_7_embbag_dedw_SLS_kernel_params, sizeof(emb_7_embbag_dedw_SLS_kernel_params), "sparse_lengths_sum_fwd_f32", "emb_7_embbag_dedw_SLS", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_7_embbag_dedw_SLS failed!");

    /*************
     * emb_7_embbag_dedw_EMB node
     * inputs: [emb_7_embbag_dedw_grad_inter(128, 32)(dtype=float32), emb_7_embbag_weight_golden[633, 32](dtype=float32), emb_7_embbag_momentum[633, 32](dtype=float32), emb_7_embbag_dedw_param_table_indices[128](dtype=int32), emb_7_offset_shape[128](dtype=int32), emb_0_embbag_timestamp[1](dtype=int32), emb_0_embbag_rate[1](dtype=float32), emb_7_embbag_valid_indices[1](dtype=int32), emb_7_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_7_embbag_dedw_weight_output_golden(633, 32)(dtype=float32), emb_7_embbag_dedw_momentum_output(633, 32)(dtype=float32), emb_7_embbag_dedw_weight_output(633, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_7_embbag_dedw_EMB_kernel_params;
    emb_7_embbag_dedw_EMB_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_7_embbag_dedw_EMB_kernel_params.sgd.wd = 0;
    emb_7_embbag_dedw_EMB_kernel_params.sgd.mom = 1;
    emb_7_embbag_dedw_EMB_kernel_params.sgd.damp = 0;
    emb_7_embbag_dedw_EMB_kernel_params.sgd.nesterov = false;

    // create emb_7_embbag_weight_golden tensor
    const unsigned emb_7_embbag_weight_golden_sizes[] = {633, 32};
    uint64_t emb_7_embbag_weight_golden_dram;
    unsigned emb_7_embbag_weight_golden_size = 633*32;
    unsigned emb_7_embbag_weight_golden_size_in_bytes = emb_7_embbag_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(emb_7_embbag_weight_golden_size_in_bytes, &emb_7_embbag_weight_golden_dram, "emb_7_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_7_embbag_weight_golden dram malloc failed!");
    synLaunchTensorInfo emb_7_embbag_weight_golden_tr_info = {"emb_7_embbag_weight_golden",
                                                              emb_7_embbag_weight_golden_dram};
    UNUSED(emb_7_embbag_weight_golden_tr_info); // For single op tests
    synTensor emb_7_embbag_weight_golden = createTensor(2U, syn_type_single, emb_7_embbag_weight_golden_sizes, true, "emb_7_embbag_weight_golden");
    UNUSED(emb_7_embbag_weight_golden); // For single op tests

    // create emb_7_embbag_momentum tensor
    const unsigned emb_7_embbag_momentum_sizes[] = {633, 32};
    uint64_t emb_7_embbag_momentum_dram;
    unsigned emb_7_embbag_momentum_size = 633*32;
    unsigned emb_7_embbag_momentum_size_in_bytes = emb_7_embbag_momentum_size * sizeof(float) ;
    status = hbmAlloc(emb_7_embbag_momentum_size_in_bytes, &emb_7_embbag_momentum_dram, "emb_7_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_7_embbag_momentum dram malloc failed!");
    synLaunchTensorInfo emb_7_embbag_momentum_tr_info = {"emb_7_embbag_momentum", emb_7_embbag_momentum_dram};
    UNUSED(emb_7_embbag_momentum_tr_info); // For single op tests
    synTensor emb_7_embbag_momentum = createTensor(2U, syn_type_single, emb_7_embbag_momentum_sizes, true, "emb_7_embbag_momentum");
    UNUSED(emb_7_embbag_momentum); // For single op tests

    // create emb_7_embbag_dedw_param_table_indices tensor
    const unsigned emb_7_embbag_dedw_param_table_indices_sizes[] = {128,};
    uint64_t emb_7_embbag_dedw_param_table_indices_dram;
    unsigned emb_7_embbag_dedw_param_table_indices_size = 128;
    unsigned emb_7_embbag_dedw_param_table_indices_size_in_bytes = emb_7_embbag_dedw_param_table_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_7_embbag_dedw_param_table_indices_size_in_bytes, &emb_7_embbag_dedw_param_table_indices_dram, "emb_7_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_7_embbag_dedw_param_table_indices dram malloc failed!");
    synLaunchTensorInfo emb_7_embbag_dedw_param_table_indices_tr_info = {"emb_7_embbag_dedw_param_table_indices",
                                                                         emb_7_embbag_dedw_param_table_indices_dram};
    UNUSED(emb_7_embbag_dedw_param_table_indices_tr_info); // For single op tests
    synTensor emb_7_embbag_dedw_param_table_indices = createTensor(1U, syn_type_int32, emb_7_embbag_dedw_param_table_indices_sizes, true, "emb_7_embbag_dedw_param_table_indices");
    UNUSED(emb_7_embbag_dedw_param_table_indices); // For single op tests

    // create emb_7_offset_shape tensor
    const unsigned emb_7_offset_shape_sizes[] = {128,};
    uint64_t emb_7_offset_shape_dram;
    unsigned emb_7_offset_shape_size = 128;
    unsigned emb_7_offset_shape_size_in_bytes = emb_7_offset_shape_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_7_offset_shape_size_in_bytes, &emb_7_offset_shape_dram, "emb_7_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_7_offset_shape dram malloc failed!");
    synLaunchTensorInfo emb_7_offset_shape_tr_info = {"emb_7_offset_shape", emb_7_offset_shape_dram};
    UNUSED(emb_7_offset_shape_tr_info); // For single op tests
    synTensor emb_7_offset_shape = createTensor(1U, syn_type_int32, emb_7_offset_shape_sizes, true, "emb_7_offset_shape");
    UNUSED(emb_7_offset_shape); // For single op tests

    synTensor emb_7_embbag_dedw_EMB_in_vec[9] = {emb_7_embbag_dedw_grad_inter, emb_7_embbag_weight_golden, emb_7_embbag_momentum, emb_7_embbag_dedw_param_table_indices, emb_7_offset_shape, emb_0_embbag_timestamp, emb_0_embbag_rate, emb_7_embbag_valid_indices, emb_7_embbag_valid_indices};


    // create emb_7_embbag_dedw_weight_output_golden tensor
    const unsigned emb_7_embbag_dedw_weight_output_golden_sizes[] = {633, 32};
    uint64_t emb_7_embbag_dedw_weight_output_golden_dram = emb_7_embbag_weight_golden_dram;
    synLaunchTensorInfo emb_7_embbag_dedw_weight_output_golden_tr_info = {"emb_7_embbag_dedw_weight_output_golden",
                                                                          emb_7_embbag_dedw_weight_output_golden_dram};
    UNUSED(emb_7_embbag_dedw_weight_output_golden_tr_info); // For single op tests
    synTensor emb_7_embbag_dedw_weight_output_golden = createTensor(2U, syn_type_single, emb_7_embbag_dedw_weight_output_golden_sizes, true, "emb_7_embbag_dedw_weight_output_golden");
    UNUSED(emb_7_embbag_dedw_weight_output_golden); // For single op tests

    // create emb_7_embbag_dedw_momentum_output tensor
    const unsigned emb_7_embbag_dedw_momentum_output_sizes[] = {633, 32};
    uint64_t emb_7_embbag_dedw_momentum_output_dram;
    unsigned emb_7_embbag_dedw_momentum_output_size = 633*32;
    unsigned emb_7_embbag_dedw_momentum_output_size_in_bytes = emb_7_embbag_dedw_momentum_output_size * sizeof(float) ;
    status = hbmAlloc(emb_7_embbag_dedw_momentum_output_size_in_bytes, &emb_7_embbag_dedw_momentum_output_dram, "emb_7_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_7_embbag_dedw_momentum_output dram malloc failed!");
    synLaunchTensorInfo emb_7_embbag_dedw_momentum_output_tr_info = {"emb_7_embbag_dedw_momentum_output",
                                                                     emb_7_embbag_dedw_momentum_output_dram};
    UNUSED(emb_7_embbag_dedw_momentum_output_tr_info); // For single op tests
    synTensor emb_7_embbag_dedw_momentum_output = createTensor(2U, syn_type_single, emb_7_embbag_dedw_momentum_output_sizes, true, "emb_7_embbag_dedw_momentum_output");
    UNUSED(emb_7_embbag_dedw_momentum_output); // For single op tests

    // create emb_7_embbag_dedw_weight_output tensor
    const unsigned emb_7_embbag_dedw_weight_output_sizes[] = {633, 32};
    uint64_t emb_7_embbag_dedw_weight_output_dram = emb_7_embbag_weight_dram;
    synLaunchTensorInfo emb_7_embbag_dedw_weight_output_tr_info = {"emb_7_embbag_dedw_weight_output",
                                                                   emb_7_embbag_dedw_weight_output_dram};
    UNUSED(emb_7_embbag_dedw_weight_output_tr_info); // For single op tests
    synTensor emb_7_embbag_dedw_weight_output = createTensor(2U, syn_type_bf16, emb_7_embbag_dedw_weight_output_sizes, true, "emb_7_embbag_dedw_weight_output");
    UNUSED(emb_7_embbag_dedw_weight_output); // For single op tests

    synTensor emb_7_embbag_dedw_EMB_out_vec[3] = {emb_7_embbag_dedw_weight_output_golden, emb_7_embbag_dedw_momentum_output, emb_7_embbag_dedw_weight_output};


    status = synNodeCreate(graphHandle, emb_7_embbag_dedw_EMB_in_vec, emb_7_embbag_dedw_EMB_out_vec, 9, 3, (void *)&emb_7_embbag_dedw_EMB_kernel_params, sizeof(emb_7_embbag_dedw_EMB_kernel_params), "embedding_bag_sgd_bwd_f32", "emb_7_embbag_dedw_EMB", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_7_embbag_dedw_EMB failed!");

    /*************
     * emb_8_embbag_dedw_SLS node
     * inputs: [concat_interact0_grad_input9(128, 32)(dtype=float32), emb_8_embbag_dedw_grad_indices[128](dtype=int32), emb_8_embbag_dedw_lengths[128](dtype=int32), emb_8_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_8_embbag_dedw_grad_inter(128, 32)(dtype=float32)]
     *************/
    ns_SparseLengthsSum::Params emb_8_embbag_dedw_SLS_kernel_params;
    emb_8_embbag_dedw_SLS_kernel_params.mode = EMBEDDED_SC_ZP;

    // create emb_8_embbag_dedw_grad_indices tensor
    const unsigned emb_8_embbag_dedw_grad_indices_sizes[] = {128,};
    uint64_t emb_8_embbag_dedw_grad_indices_dram;
    unsigned emb_8_embbag_dedw_grad_indices_size = 128;
    unsigned emb_8_embbag_dedw_grad_indices_size_in_bytes = emb_8_embbag_dedw_grad_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_8_embbag_dedw_grad_indices_size_in_bytes, &emb_8_embbag_dedw_grad_indices_dram, "emb_8_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_8_embbag_dedw_grad_indices dram malloc failed!");
    synLaunchTensorInfo emb_8_embbag_dedw_grad_indices_tr_info = {"emb_8_embbag_dedw_grad_indices",
                                                                  emb_8_embbag_dedw_grad_indices_dram};
    UNUSED(emb_8_embbag_dedw_grad_indices_tr_info); // For single op tests
    synTensor emb_8_embbag_dedw_grad_indices = createTensor(1U, syn_type_int32, emb_8_embbag_dedw_grad_indices_sizes, true, "emb_8_embbag_dedw_grad_indices");
    UNUSED(emb_8_embbag_dedw_grad_indices); // For single op tests

    // create emb_8_embbag_dedw_lengths tensor
    const unsigned emb_8_embbag_dedw_lengths_sizes[] = {128,};
    uint64_t emb_8_embbag_dedw_lengths_dram;
    unsigned emb_8_embbag_dedw_lengths_size = 128;
    unsigned emb_8_embbag_dedw_lengths_size_in_bytes = emb_8_embbag_dedw_lengths_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_8_embbag_dedw_lengths_size_in_bytes, &emb_8_embbag_dedw_lengths_dram, "emb_8_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_8_embbag_dedw_lengths dram malloc failed!");
    synLaunchTensorInfo emb_8_embbag_dedw_lengths_tr_info = {"emb_8_embbag_dedw_lengths",
                                                             emb_8_embbag_dedw_lengths_dram};
    UNUSED(emb_8_embbag_dedw_lengths_tr_info); // For single op tests
    synTensor emb_8_embbag_dedw_lengths = createTensor(1U, syn_type_int32, emb_8_embbag_dedw_lengths_sizes, true, "emb_8_embbag_dedw_lengths");
    UNUSED(emb_8_embbag_dedw_lengths); // For single op tests

    // create emb_8_embbag_valid_indices tensor
    const unsigned emb_8_embbag_valid_indices_sizes[] = {1,};
    uint64_t emb_8_embbag_valid_indices_dram;
    unsigned emb_8_embbag_valid_indices_size = 1;
    unsigned emb_8_embbag_valid_indices_size_in_bytes = emb_8_embbag_valid_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_8_embbag_valid_indices_size_in_bytes, &emb_8_embbag_valid_indices_dram, "emb_8_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_8_embbag_valid_indices dram malloc failed!");
    synLaunchTensorInfo emb_8_embbag_valid_indices_tr_info = {"emb_8_embbag_valid_indices",
                                                              emb_8_embbag_valid_indices_dram};
    UNUSED(emb_8_embbag_valid_indices_tr_info); // For single op tests
    synTensor emb_8_embbag_valid_indices = createTensor(1U, syn_type_int32, emb_8_embbag_valid_indices_sizes, true, "emb_8_embbag_valid_indices");
    UNUSED(emb_8_embbag_valid_indices); // For single op tests

    synTensor emb_8_embbag_dedw_SLS_in_vec[4] = {concat_interact0_grad_input9, emb_8_embbag_dedw_grad_indices, emb_8_embbag_dedw_lengths, emb_8_embbag_valid_indices};


    // create emb_8_embbag_dedw_grad_inter tensor
    const unsigned emb_8_embbag_dedw_grad_inter_sizes[] = {128, 32};
    synTensor emb_8_embbag_dedw_grad_inter = createTensor(2U, syn_type_single, emb_8_embbag_dedw_grad_inter_sizes, false, "emb_8_embbag_dedw_grad_inter");
    UNUSED(emb_8_embbag_dedw_grad_inter); // For single op tests

    synTensor emb_8_embbag_dedw_SLS_out_vec[1] = {emb_8_embbag_dedw_grad_inter};


    status = synNodeCreate(graphHandle, emb_8_embbag_dedw_SLS_in_vec, emb_8_embbag_dedw_SLS_out_vec, 4, 1, (void *)&emb_8_embbag_dedw_SLS_kernel_params, sizeof(emb_8_embbag_dedw_SLS_kernel_params), "sparse_lengths_sum_fwd_f32", "emb_8_embbag_dedw_SLS", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_8_embbag_dedw_SLS failed!");

    /*************
     * emb_8_embbag_dedw_EMB node
     * inputs: [emb_8_embbag_dedw_grad_inter(128, 32)(dtype=float32), emb_8_embbag_weight_golden[3, 32](dtype=float32), emb_8_embbag_momentum[3, 32](dtype=float32), emb_8_embbag_dedw_param_table_indices[128](dtype=int32), emb_8_offset_shape[128](dtype=int32), emb_0_embbag_timestamp[1](dtype=int32), emb_0_embbag_rate[1](dtype=float32), emb_8_embbag_valid_indices[1](dtype=int32), emb_8_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_8_embbag_dedw_weight_output_golden(3, 32)(dtype=float32), emb_8_embbag_dedw_momentum_output(3, 32)(dtype=float32), emb_8_embbag_dedw_weight_output(3, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_8_embbag_dedw_EMB_kernel_params;
    emb_8_embbag_dedw_EMB_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_8_embbag_dedw_EMB_kernel_params.sgd.wd = 0;
    emb_8_embbag_dedw_EMB_kernel_params.sgd.mom = 1;
    emb_8_embbag_dedw_EMB_kernel_params.sgd.damp = 0;
    emb_8_embbag_dedw_EMB_kernel_params.sgd.nesterov = false;

    // create emb_8_embbag_weight_golden tensor
    const unsigned emb_8_embbag_weight_golden_sizes[] = {3, 32};
    uint64_t emb_8_embbag_weight_golden_dram;
    unsigned emb_8_embbag_weight_golden_size = 3*32;
    unsigned emb_8_embbag_weight_golden_size_in_bytes = emb_8_embbag_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(emb_8_embbag_weight_golden_size_in_bytes, &emb_8_embbag_weight_golden_dram, "emb_8_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_8_embbag_weight_golden dram malloc failed!");
    synLaunchTensorInfo emb_8_embbag_weight_golden_tr_info = {"emb_8_embbag_weight_golden",
                                                              emb_8_embbag_weight_golden_dram};
    UNUSED(emb_8_embbag_weight_golden_tr_info); // For single op tests
    synTensor emb_8_embbag_weight_golden = createTensor(2U, syn_type_single, emb_8_embbag_weight_golden_sizes, true, "emb_8_embbag_weight_golden");
    UNUSED(emb_8_embbag_weight_golden); // For single op tests

    // create emb_8_embbag_momentum tensor
    const unsigned emb_8_embbag_momentum_sizes[] = {3, 32};
    uint64_t emb_8_embbag_momentum_dram;
    unsigned emb_8_embbag_momentum_size = 3*32;
    unsigned emb_8_embbag_momentum_size_in_bytes = emb_8_embbag_momentum_size * sizeof(float) ;
    status = hbmAlloc(emb_8_embbag_momentum_size_in_bytes, &emb_8_embbag_momentum_dram, "emb_8_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_8_embbag_momentum dram malloc failed!");
    synLaunchTensorInfo emb_8_embbag_momentum_tr_info = {"emb_8_embbag_momentum", emb_8_embbag_momentum_dram};
    UNUSED(emb_8_embbag_momentum_tr_info); // For single op tests
    synTensor emb_8_embbag_momentum = createTensor(2U, syn_type_single, emb_8_embbag_momentum_sizes, true, "emb_8_embbag_momentum");
    UNUSED(emb_8_embbag_momentum); // For single op tests

    // create emb_8_embbag_dedw_param_table_indices tensor
    const unsigned emb_8_embbag_dedw_param_table_indices_sizes[] = {128,};
    uint64_t emb_8_embbag_dedw_param_table_indices_dram;
    unsigned emb_8_embbag_dedw_param_table_indices_size = 128;
    unsigned emb_8_embbag_dedw_param_table_indices_size_in_bytes = emb_8_embbag_dedw_param_table_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_8_embbag_dedw_param_table_indices_size_in_bytes, &emb_8_embbag_dedw_param_table_indices_dram, "emb_8_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_8_embbag_dedw_param_table_indices dram malloc failed!");
    synLaunchTensorInfo emb_8_embbag_dedw_param_table_indices_tr_info = {"emb_8_embbag_dedw_param_table_indices",
                                                                         emb_8_embbag_dedw_param_table_indices_dram};
    UNUSED(emb_8_embbag_dedw_param_table_indices_tr_info); // For single op tests
    synTensor emb_8_embbag_dedw_param_table_indices = createTensor(1U, syn_type_int32, emb_8_embbag_dedw_param_table_indices_sizes, true, "emb_8_embbag_dedw_param_table_indices");
    UNUSED(emb_8_embbag_dedw_param_table_indices); // For single op tests

    // create emb_8_offset_shape tensor
    const unsigned emb_8_offset_shape_sizes[] = {128,};
    uint64_t emb_8_offset_shape_dram;
    unsigned emb_8_offset_shape_size = 128;
    unsigned emb_8_offset_shape_size_in_bytes = emb_8_offset_shape_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_8_offset_shape_size_in_bytes, &emb_8_offset_shape_dram, "emb_8_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_8_offset_shape dram malloc failed!");
    synLaunchTensorInfo emb_8_offset_shape_tr_info = {"emb_8_offset_shape", emb_8_offset_shape_dram};
    UNUSED(emb_8_offset_shape_tr_info); // For single op tests
    synTensor emb_8_offset_shape = createTensor(1U, syn_type_int32, emb_8_offset_shape_sizes, true, "emb_8_offset_shape");
    UNUSED(emb_8_offset_shape); // For single op tests

    synTensor emb_8_embbag_dedw_EMB_in_vec[9] = {emb_8_embbag_dedw_grad_inter, emb_8_embbag_weight_golden, emb_8_embbag_momentum, emb_8_embbag_dedw_param_table_indices, emb_8_offset_shape, emb_0_embbag_timestamp, emb_0_embbag_rate, emb_8_embbag_valid_indices, emb_8_embbag_valid_indices};


    // create emb_8_embbag_dedw_weight_output_golden tensor
    const unsigned emb_8_embbag_dedw_weight_output_golden_sizes[] = {3, 32};
    uint64_t emb_8_embbag_dedw_weight_output_golden_dram = emb_8_embbag_weight_golden_dram;
    synLaunchTensorInfo emb_8_embbag_dedw_weight_output_golden_tr_info = {"emb_8_embbag_dedw_weight_output_golden",
                                                                          emb_8_embbag_dedw_weight_output_golden_dram};
    UNUSED(emb_8_embbag_dedw_weight_output_golden_tr_info); // For single op tests
    synTensor emb_8_embbag_dedw_weight_output_golden = createTensor(2U, syn_type_single, emb_8_embbag_dedw_weight_output_golden_sizes, true, "emb_8_embbag_dedw_weight_output_golden");
    UNUSED(emb_8_embbag_dedw_weight_output_golden); // For single op tests

    // create emb_8_embbag_dedw_momentum_output tensor
    const unsigned emb_8_embbag_dedw_momentum_output_sizes[] = {3, 32};
    uint64_t emb_8_embbag_dedw_momentum_output_dram;
    unsigned emb_8_embbag_dedw_momentum_output_size = 3*32;
    unsigned emb_8_embbag_dedw_momentum_output_size_in_bytes = emb_8_embbag_dedw_momentum_output_size * sizeof(float) ;
    status = hbmAlloc(emb_8_embbag_dedw_momentum_output_size_in_bytes, &emb_8_embbag_dedw_momentum_output_dram, "emb_8_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_8_embbag_dedw_momentum_output dram malloc failed!");
    synLaunchTensorInfo emb_8_embbag_dedw_momentum_output_tr_info = {"emb_8_embbag_dedw_momentum_output",
                                                                     emb_8_embbag_dedw_momentum_output_dram};
    UNUSED(emb_8_embbag_dedw_momentum_output_tr_info); // For single op tests
    synTensor emb_8_embbag_dedw_momentum_output = createTensor(2U, syn_type_single, emb_8_embbag_dedw_momentum_output_sizes, true, "emb_8_embbag_dedw_momentum_output");
    UNUSED(emb_8_embbag_dedw_momentum_output); // For single op tests

    // create emb_8_embbag_dedw_weight_output tensor
    const unsigned emb_8_embbag_dedw_weight_output_sizes[] = {3, 32};
    uint64_t emb_8_embbag_dedw_weight_output_dram = emb_8_embbag_weight_dram;
    synLaunchTensorInfo emb_8_embbag_dedw_weight_output_tr_info = {"emb_8_embbag_dedw_weight_output",
                                                                   emb_8_embbag_dedw_weight_output_dram};
    UNUSED(emb_8_embbag_dedw_weight_output_tr_info); // For single op tests
    synTensor emb_8_embbag_dedw_weight_output = createTensor(2U, syn_type_bf16, emb_8_embbag_dedw_weight_output_sizes, true, "emb_8_embbag_dedw_weight_output");
    UNUSED(emb_8_embbag_dedw_weight_output); // For single op tests

    synTensor emb_8_embbag_dedw_EMB_out_vec[3] = {emb_8_embbag_dedw_weight_output_golden, emb_8_embbag_dedw_momentum_output, emb_8_embbag_dedw_weight_output};


    status = synNodeCreate(graphHandle, emb_8_embbag_dedw_EMB_in_vec, emb_8_embbag_dedw_EMB_out_vec, 9, 3, (void *)&emb_8_embbag_dedw_EMB_kernel_params, sizeof(emb_8_embbag_dedw_EMB_kernel_params), "embedding_bag_sgd_bwd_f32", "emb_8_embbag_dedw_EMB", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_8_embbag_dedw_EMB failed!");

    /*************
     * emb_9_embbag_dedw_SLS node
     * inputs: [concat_interact0_grad_input10(128, 32)(dtype=float32), emb_9_embbag_dedw_grad_indices[128](dtype=int32), emb_9_embbag_dedw_lengths[128](dtype=int32), emb_9_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_9_embbag_dedw_grad_inter(128, 32)(dtype=float32)]
     *************/
    ns_SparseLengthsSum::Params emb_9_embbag_dedw_SLS_kernel_params;
    emb_9_embbag_dedw_SLS_kernel_params.mode = EMBEDDED_SC_ZP;

    // create emb_9_embbag_dedw_grad_indices tensor
    const unsigned emb_9_embbag_dedw_grad_indices_sizes[] = {128,};
    uint64_t emb_9_embbag_dedw_grad_indices_dram;
    unsigned emb_9_embbag_dedw_grad_indices_size = 128;
    unsigned emb_9_embbag_dedw_grad_indices_size_in_bytes = emb_9_embbag_dedw_grad_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_9_embbag_dedw_grad_indices_size_in_bytes, &emb_9_embbag_dedw_grad_indices_dram, "emb_9_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_9_embbag_dedw_grad_indices dram malloc failed!");
    synLaunchTensorInfo emb_9_embbag_dedw_grad_indices_tr_info = {"emb_9_embbag_dedw_grad_indices",
                                                                  emb_9_embbag_dedw_grad_indices_dram};
    UNUSED(emb_9_embbag_dedw_grad_indices_tr_info); // For single op tests
    synTensor emb_9_embbag_dedw_grad_indices = createTensor(1U, syn_type_int32, emb_9_embbag_dedw_grad_indices_sizes, true, "emb_9_embbag_dedw_grad_indices");
    UNUSED(emb_9_embbag_dedw_grad_indices); // For single op tests

    // create emb_9_embbag_dedw_lengths tensor
    const unsigned emb_9_embbag_dedw_lengths_sizes[] = {128,};
    uint64_t emb_9_embbag_dedw_lengths_dram;
    unsigned emb_9_embbag_dedw_lengths_size = 128;
    unsigned emb_9_embbag_dedw_lengths_size_in_bytes = emb_9_embbag_dedw_lengths_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_9_embbag_dedw_lengths_size_in_bytes, &emb_9_embbag_dedw_lengths_dram, "emb_9_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_9_embbag_dedw_lengths dram malloc failed!");
    synLaunchTensorInfo emb_9_embbag_dedw_lengths_tr_info = {"emb_9_embbag_dedw_lengths",
                                                             emb_9_embbag_dedw_lengths_dram};
    UNUSED(emb_9_embbag_dedw_lengths_tr_info); // For single op tests
    synTensor emb_9_embbag_dedw_lengths = createTensor(1U, syn_type_int32, emb_9_embbag_dedw_lengths_sizes, true, "emb_9_embbag_dedw_lengths");
    UNUSED(emb_9_embbag_dedw_lengths); // For single op tests

    // create emb_9_embbag_valid_indices tensor
    const unsigned emb_9_embbag_valid_indices_sizes[] = {1,};
    uint64_t emb_9_embbag_valid_indices_dram;
    unsigned emb_9_embbag_valid_indices_size = 1;
    unsigned emb_9_embbag_valid_indices_size_in_bytes = emb_9_embbag_valid_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_9_embbag_valid_indices_size_in_bytes, &emb_9_embbag_valid_indices_dram, "emb_9_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_9_embbag_valid_indices dram malloc failed!");
    synLaunchTensorInfo emb_9_embbag_valid_indices_tr_info = {"emb_9_embbag_valid_indices",
                                                              emb_9_embbag_valid_indices_dram};
    UNUSED(emb_9_embbag_valid_indices_tr_info); // For single op tests
    synTensor emb_9_embbag_valid_indices = createTensor(1U, syn_type_int32, emb_9_embbag_valid_indices_sizes, true, "emb_9_embbag_valid_indices");
    UNUSED(emb_9_embbag_valid_indices); // For single op tests

    synTensor emb_9_embbag_dedw_SLS_in_vec[4] = {concat_interact0_grad_input10, emb_9_embbag_dedw_grad_indices, emb_9_embbag_dedw_lengths, emb_9_embbag_valid_indices};


    // create emb_9_embbag_dedw_grad_inter tensor
    const unsigned emb_9_embbag_dedw_grad_inter_sizes[] = {128, 32};
    synTensor emb_9_embbag_dedw_grad_inter = createTensor(2U, syn_type_single, emb_9_embbag_dedw_grad_inter_sizes, false, "emb_9_embbag_dedw_grad_inter");
    UNUSED(emb_9_embbag_dedw_grad_inter); // For single op tests

    synTensor emb_9_embbag_dedw_SLS_out_vec[1] = {emb_9_embbag_dedw_grad_inter};


    status = synNodeCreate(graphHandle, emb_9_embbag_dedw_SLS_in_vec, emb_9_embbag_dedw_SLS_out_vec, 4, 1, (void *)&emb_9_embbag_dedw_SLS_kernel_params, sizeof(emb_9_embbag_dedw_SLS_kernel_params), "sparse_lengths_sum_fwd_f32", "emb_9_embbag_dedw_SLS", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_9_embbag_dedw_SLS failed!");

    /*************
     * emb_9_embbag_dedw_EMB node
     * inputs: [emb_9_embbag_dedw_grad_inter(128, 32)(dtype=float32), emb_9_embbag_weight_golden[89982, 32](dtype=float32), emb_9_embbag_momentum[89982, 32](dtype=float32), emb_9_embbag_dedw_param_table_indices[128](dtype=int32), emb_9_offset_shape[128](dtype=int32), emb_0_embbag_timestamp[1](dtype=int32), emb_0_embbag_rate[1](dtype=float32), emb_9_embbag_valid_indices[1](dtype=int32), emb_9_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_9_embbag_dedw_weight_output_golden(89982, 32)(dtype=float32), emb_9_embbag_dedw_momentum_output(89982, 32)(dtype=float32), emb_9_embbag_dedw_weight_output(89982, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_9_embbag_dedw_EMB_kernel_params;
    emb_9_embbag_dedw_EMB_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_9_embbag_dedw_EMB_kernel_params.sgd.wd = 0;
    emb_9_embbag_dedw_EMB_kernel_params.sgd.mom = 1;
    emb_9_embbag_dedw_EMB_kernel_params.sgd.damp = 0;
    emb_9_embbag_dedw_EMB_kernel_params.sgd.nesterov = false;

    // create emb_9_embbag_weight_golden tensor
    const unsigned emb_9_embbag_weight_golden_sizes[] = {89982, 32};
    uint64_t emb_9_embbag_weight_golden_dram;
    unsigned emb_9_embbag_weight_golden_size = 89982*32;
    unsigned emb_9_embbag_weight_golden_size_in_bytes = emb_9_embbag_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(emb_9_embbag_weight_golden_size_in_bytes, &emb_9_embbag_weight_golden_dram, "emb_9_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_9_embbag_weight_golden dram malloc failed!");
    synLaunchTensorInfo emb_9_embbag_weight_golden_tr_info = {"emb_9_embbag_weight_golden",
                                                              emb_9_embbag_weight_golden_dram};
    UNUSED(emb_9_embbag_weight_golden_tr_info); // For single op tests
    synTensor emb_9_embbag_weight_golden = createTensor(2U, syn_type_single, emb_9_embbag_weight_golden_sizes, true, "emb_9_embbag_weight_golden");
    UNUSED(emb_9_embbag_weight_golden); // For single op tests

    // create emb_9_embbag_momentum tensor
    const unsigned emb_9_embbag_momentum_sizes[] = {89982, 32};
    uint64_t emb_9_embbag_momentum_dram;
    unsigned emb_9_embbag_momentum_size = 89982*32;
    unsigned emb_9_embbag_momentum_size_in_bytes = emb_9_embbag_momentum_size * sizeof(float) ;
    status = hbmAlloc(emb_9_embbag_momentum_size_in_bytes, &emb_9_embbag_momentum_dram, "emb_9_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_9_embbag_momentum dram malloc failed!");
    synLaunchTensorInfo emb_9_embbag_momentum_tr_info = {"emb_9_embbag_momentum", emb_9_embbag_momentum_dram};
    UNUSED(emb_9_embbag_momentum_tr_info); // For single op tests
    synTensor emb_9_embbag_momentum = createTensor(2U, syn_type_single, emb_9_embbag_momentum_sizes, true, "emb_9_embbag_momentum");
    UNUSED(emb_9_embbag_momentum); // For single op tests

    // create emb_9_embbag_dedw_param_table_indices tensor
    const unsigned emb_9_embbag_dedw_param_table_indices_sizes[] = {128,};
    uint64_t emb_9_embbag_dedw_param_table_indices_dram;
    unsigned emb_9_embbag_dedw_param_table_indices_size = 128;
    unsigned emb_9_embbag_dedw_param_table_indices_size_in_bytes = emb_9_embbag_dedw_param_table_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_9_embbag_dedw_param_table_indices_size_in_bytes, &emb_9_embbag_dedw_param_table_indices_dram, "emb_9_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_9_embbag_dedw_param_table_indices dram malloc failed!");
    synLaunchTensorInfo emb_9_embbag_dedw_param_table_indices_tr_info = {"emb_9_embbag_dedw_param_table_indices",
                                                                         emb_9_embbag_dedw_param_table_indices_dram};
    UNUSED(emb_9_embbag_dedw_param_table_indices_tr_info); // For single op tests
    synTensor emb_9_embbag_dedw_param_table_indices = createTensor(1U, syn_type_int32, emb_9_embbag_dedw_param_table_indices_sizes, true, "emb_9_embbag_dedw_param_table_indices");
    UNUSED(emb_9_embbag_dedw_param_table_indices); // For single op tests

    // create emb_9_offset_shape tensor
    const unsigned emb_9_offset_shape_sizes[] = {128,};
    uint64_t emb_9_offset_shape_dram;
    unsigned emb_9_offset_shape_size = 128;
    unsigned emb_9_offset_shape_size_in_bytes = emb_9_offset_shape_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_9_offset_shape_size_in_bytes, &emb_9_offset_shape_dram, "emb_9_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_9_offset_shape dram malloc failed!");
    synLaunchTensorInfo emb_9_offset_shape_tr_info = {"emb_9_offset_shape", emb_9_offset_shape_dram};
    UNUSED(emb_9_offset_shape_tr_info); // For single op tests
    synTensor emb_9_offset_shape = createTensor(1U, syn_type_int32, emb_9_offset_shape_sizes, true, "emb_9_offset_shape");
    UNUSED(emb_9_offset_shape); // For single op tests

    synTensor emb_9_embbag_dedw_EMB_in_vec[9] = {emb_9_embbag_dedw_grad_inter, emb_9_embbag_weight_golden, emb_9_embbag_momentum, emb_9_embbag_dedw_param_table_indices, emb_9_offset_shape, emb_0_embbag_timestamp, emb_0_embbag_rate, emb_9_embbag_valid_indices, emb_9_embbag_valid_indices};


    // create emb_9_embbag_dedw_weight_output_golden tensor
    const unsigned emb_9_embbag_dedw_weight_output_golden_sizes[] = {89982, 32};
    uint64_t emb_9_embbag_dedw_weight_output_golden_dram = emb_9_embbag_weight_golden_dram;
    synLaunchTensorInfo emb_9_embbag_dedw_weight_output_golden_tr_info = {"emb_9_embbag_dedw_weight_output_golden",
                                                                          emb_9_embbag_dedw_weight_output_golden_dram};
    UNUSED(emb_9_embbag_dedw_weight_output_golden_tr_info); // For single op tests
    synTensor emb_9_embbag_dedw_weight_output_golden = createTensor(2U, syn_type_single, emb_9_embbag_dedw_weight_output_golden_sizes, true, "emb_9_embbag_dedw_weight_output_golden");
    UNUSED(emb_9_embbag_dedw_weight_output_golden); // For single op tests

    // create emb_9_embbag_dedw_momentum_output tensor
    const unsigned emb_9_embbag_dedw_momentum_output_sizes[] = {89982, 32};
    uint64_t emb_9_embbag_dedw_momentum_output_dram;
    unsigned emb_9_embbag_dedw_momentum_output_size = 89982*32;
    unsigned emb_9_embbag_dedw_momentum_output_size_in_bytes = emb_9_embbag_dedw_momentum_output_size * sizeof(float) ;
    status = hbmAlloc(emb_9_embbag_dedw_momentum_output_size_in_bytes, &emb_9_embbag_dedw_momentum_output_dram, "emb_9_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_9_embbag_dedw_momentum_output dram malloc failed!");
    synLaunchTensorInfo emb_9_embbag_dedw_momentum_output_tr_info = {"emb_9_embbag_dedw_momentum_output",
                                                                     emb_9_embbag_dedw_momentum_output_dram};
    UNUSED(emb_9_embbag_dedw_momentum_output_tr_info); // For single op tests
    synTensor emb_9_embbag_dedw_momentum_output = createTensor(2U, syn_type_single, emb_9_embbag_dedw_momentum_output_sizes, true, "emb_9_embbag_dedw_momentum_output");
    UNUSED(emb_9_embbag_dedw_momentum_output); // For single op tests

    // create emb_9_embbag_dedw_weight_output tensor
    const unsigned emb_9_embbag_dedw_weight_output_sizes[] = {89982, 32};
    uint64_t emb_9_embbag_dedw_weight_output_dram = emb_9_embbag_weight_dram;
    synLaunchTensorInfo emb_9_embbag_dedw_weight_output_tr_info = {"emb_9_embbag_dedw_weight_output",
                                                                   emb_9_embbag_dedw_weight_output_dram};
    UNUSED(emb_9_embbag_dedw_weight_output_tr_info); // For single op tests
    synTensor emb_9_embbag_dedw_weight_output = createTensor(2U, syn_type_bf16, emb_9_embbag_dedw_weight_output_sizes, true, "emb_9_embbag_dedw_weight_output");
    UNUSED(emb_9_embbag_dedw_weight_output); // For single op tests

    synTensor emb_9_embbag_dedw_EMB_out_vec[3] = {emb_9_embbag_dedw_weight_output_golden, emb_9_embbag_dedw_momentum_output, emb_9_embbag_dedw_weight_output};


    status = synNodeCreate(graphHandle, emb_9_embbag_dedw_EMB_in_vec, emb_9_embbag_dedw_EMB_out_vec, 9, 3, (void *)&emb_9_embbag_dedw_EMB_kernel_params, sizeof(emb_9_embbag_dedw_EMB_kernel_params), "embedding_bag_sgd_bwd_f32", "emb_9_embbag_dedw_EMB", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_9_embbag_dedw_EMB failed!");

    /*************
     * emb_10_embbag_dedw_SLS node
     * inputs: [concat_interact0_grad_input11(128, 32)(dtype=float32), emb_10_embbag_dedw_grad_indices[128](dtype=int32), emb_10_embbag_dedw_lengths[128](dtype=int32), emb_10_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_10_embbag_dedw_grad_inter(128, 32)(dtype=float32)]
     *************/
    ns_SparseLengthsSum::Params emb_10_embbag_dedw_SLS_kernel_params;
    emb_10_embbag_dedw_SLS_kernel_params.mode = EMBEDDED_SC_ZP;

    // create emb_10_embbag_dedw_grad_indices tensor
    const unsigned emb_10_embbag_dedw_grad_indices_sizes[] = {128,};
    uint64_t emb_10_embbag_dedw_grad_indices_dram;
    unsigned emb_10_embbag_dedw_grad_indices_size = 128;
    unsigned emb_10_embbag_dedw_grad_indices_size_in_bytes = emb_10_embbag_dedw_grad_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_10_embbag_dedw_grad_indices_size_in_bytes, &emb_10_embbag_dedw_grad_indices_dram, "emb_10_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_10_embbag_dedw_grad_indices dram malloc failed!");
    synLaunchTensorInfo emb_10_embbag_dedw_grad_indices_tr_info = {"emb_10_embbag_dedw_grad_indices",
                                                                   emb_10_embbag_dedw_grad_indices_dram};
    UNUSED(emb_10_embbag_dedw_grad_indices_tr_info); // For single op tests
    synTensor emb_10_embbag_dedw_grad_indices = createTensor(1U, syn_type_int32, emb_10_embbag_dedw_grad_indices_sizes, true, "emb_10_embbag_dedw_grad_indices");
    UNUSED(emb_10_embbag_dedw_grad_indices); // For single op tests

    // create emb_10_embbag_dedw_lengths tensor
    const unsigned emb_10_embbag_dedw_lengths_sizes[] = {128,};
    uint64_t emb_10_embbag_dedw_lengths_dram;
    unsigned emb_10_embbag_dedw_lengths_size = 128;
    unsigned emb_10_embbag_dedw_lengths_size_in_bytes = emb_10_embbag_dedw_lengths_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_10_embbag_dedw_lengths_size_in_bytes, &emb_10_embbag_dedw_lengths_dram, "emb_10_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_10_embbag_dedw_lengths dram malloc failed!");
    synLaunchTensorInfo emb_10_embbag_dedw_lengths_tr_info = {"emb_10_embbag_dedw_lengths",
                                                              emb_10_embbag_dedw_lengths_dram};
    UNUSED(emb_10_embbag_dedw_lengths_tr_info); // For single op tests
    synTensor emb_10_embbag_dedw_lengths = createTensor(1U, syn_type_int32, emb_10_embbag_dedw_lengths_sizes, true, "emb_10_embbag_dedw_lengths");
    UNUSED(emb_10_embbag_dedw_lengths); // For single op tests

    // create emb_10_embbag_valid_indices tensor
    const unsigned emb_10_embbag_valid_indices_sizes[] = {1,};
    uint64_t emb_10_embbag_valid_indices_dram;
    unsigned emb_10_embbag_valid_indices_size = 1;
    unsigned emb_10_embbag_valid_indices_size_in_bytes = emb_10_embbag_valid_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_10_embbag_valid_indices_size_in_bytes, &emb_10_embbag_valid_indices_dram, "emb_10_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_10_embbag_valid_indices dram malloc failed!");
    synLaunchTensorInfo emb_10_embbag_valid_indices_tr_info = {"emb_10_embbag_valid_indices",
                                                               emb_10_embbag_valid_indices_dram};
    UNUSED(emb_10_embbag_valid_indices_tr_info); // For single op tests
    synTensor emb_10_embbag_valid_indices = createTensor(1U, syn_type_int32, emb_10_embbag_valid_indices_sizes, true, "emb_10_embbag_valid_indices");
    UNUSED(emb_10_embbag_valid_indices); // For single op tests

    synTensor emb_10_embbag_dedw_SLS_in_vec[4] = {concat_interact0_grad_input11, emb_10_embbag_dedw_grad_indices, emb_10_embbag_dedw_lengths, emb_10_embbag_valid_indices};


    // create emb_10_embbag_dedw_grad_inter tensor
    const unsigned emb_10_embbag_dedw_grad_inter_sizes[] = {128, 32};
    synTensor emb_10_embbag_dedw_grad_inter = createTensor(2U, syn_type_single, emb_10_embbag_dedw_grad_inter_sizes, false, "emb_10_embbag_dedw_grad_inter");
    UNUSED(emb_10_embbag_dedw_grad_inter); // For single op tests

    synTensor emb_10_embbag_dedw_SLS_out_vec[1] = {emb_10_embbag_dedw_grad_inter};


    status = synNodeCreate(graphHandle, emb_10_embbag_dedw_SLS_in_vec, emb_10_embbag_dedw_SLS_out_vec, 4, 1, (void *)&emb_10_embbag_dedw_SLS_kernel_params, sizeof(emb_10_embbag_dedw_SLS_kernel_params), "sparse_lengths_sum_fwd_f32", "emb_10_embbag_dedw_SLS", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_10_embbag_dedw_SLS failed!");

    /*************
     * emb_10_embbag_dedw_EMB node
     * inputs: [emb_10_embbag_dedw_grad_inter(128, 32)(dtype=float32), emb_10_embbag_weight_golden[5623, 32](dtype=float32), emb_10_embbag_momentum[5623, 32](dtype=float32), emb_10_embbag_dedw_param_table_indices[128](dtype=int32), emb_10_offset_shape[128](dtype=int32), emb_0_embbag_timestamp[1](dtype=int32), emb_0_embbag_rate[1](dtype=float32), emb_10_embbag_valid_indices[1](dtype=int32), emb_10_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_10_embbag_dedw_weight_output_golden(5623, 32)(dtype=float32), emb_10_embbag_dedw_momentum_output(5623, 32)(dtype=float32), emb_10_embbag_dedw_weight_output(5623, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_10_embbag_dedw_EMB_kernel_params;
    emb_10_embbag_dedw_EMB_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_10_embbag_dedw_EMB_kernel_params.sgd.wd = 0;
    emb_10_embbag_dedw_EMB_kernel_params.sgd.mom = 1;
    emb_10_embbag_dedw_EMB_kernel_params.sgd.damp = 0;
    emb_10_embbag_dedw_EMB_kernel_params.sgd.nesterov = false;

    // create emb_10_embbag_weight_golden tensor
    const unsigned emb_10_embbag_weight_golden_sizes[] = {5623, 32};
    uint64_t emb_10_embbag_weight_golden_dram;
    unsigned emb_10_embbag_weight_golden_size = 5623*32;
    unsigned emb_10_embbag_weight_golden_size_in_bytes = emb_10_embbag_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(emb_10_embbag_weight_golden_size_in_bytes, &emb_10_embbag_weight_golden_dram, "emb_10_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_10_embbag_weight_golden dram malloc failed!");
    synLaunchTensorInfo emb_10_embbag_weight_golden_tr_info = {"emb_10_embbag_weight_golden",
                                                               emb_10_embbag_weight_golden_dram};
    UNUSED(emb_10_embbag_weight_golden_tr_info); // For single op tests
    synTensor emb_10_embbag_weight_golden = createTensor(2U, syn_type_single, emb_10_embbag_weight_golden_sizes, true, "emb_10_embbag_weight_golden");
    UNUSED(emb_10_embbag_weight_golden); // For single op tests

    // create emb_10_embbag_momentum tensor
    const unsigned emb_10_embbag_momentum_sizes[] = {5623, 32};
    uint64_t emb_10_embbag_momentum_dram;
    unsigned emb_10_embbag_momentum_size = 5623*32;
    unsigned emb_10_embbag_momentum_size_in_bytes = emb_10_embbag_momentum_size * sizeof(float) ;
    status = hbmAlloc(emb_10_embbag_momentum_size_in_bytes, &emb_10_embbag_momentum_dram, "emb_10_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_10_embbag_momentum dram malloc failed!");
    synLaunchTensorInfo emb_10_embbag_momentum_tr_info = {"emb_10_embbag_momentum", emb_10_embbag_momentum_dram};
    UNUSED(emb_10_embbag_momentum_tr_info); // For single op tests
    synTensor emb_10_embbag_momentum = createTensor(2U, syn_type_single, emb_10_embbag_momentum_sizes, true, "emb_10_embbag_momentum");
    UNUSED(emb_10_embbag_momentum); // For single op tests

    // create emb_10_embbag_dedw_param_table_indices tensor
    const unsigned emb_10_embbag_dedw_param_table_indices_sizes[] = {128,};
    uint64_t emb_10_embbag_dedw_param_table_indices_dram;
    unsigned emb_10_embbag_dedw_param_table_indices_size = 128;
    unsigned emb_10_embbag_dedw_param_table_indices_size_in_bytes = emb_10_embbag_dedw_param_table_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_10_embbag_dedw_param_table_indices_size_in_bytes, &emb_10_embbag_dedw_param_table_indices_dram, "emb_10_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_10_embbag_dedw_param_table_indices dram malloc failed!");
    synLaunchTensorInfo emb_10_embbag_dedw_param_table_indices_tr_info = {"emb_10_embbag_dedw_param_table_indices",
                                                                          emb_10_embbag_dedw_param_table_indices_dram};
    UNUSED(emb_10_embbag_dedw_param_table_indices_tr_info); // For single op tests
    synTensor emb_10_embbag_dedw_param_table_indices = createTensor(1U, syn_type_int32, emb_10_embbag_dedw_param_table_indices_sizes, true, "emb_10_embbag_dedw_param_table_indices");
    UNUSED(emb_10_embbag_dedw_param_table_indices); // For single op tests

    // create emb_10_offset_shape tensor
    const unsigned emb_10_offset_shape_sizes[] = {128,};
    uint64_t emb_10_offset_shape_dram;
    unsigned emb_10_offset_shape_size = 128;
    unsigned emb_10_offset_shape_size_in_bytes = emb_10_offset_shape_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_10_offset_shape_size_in_bytes, &emb_10_offset_shape_dram, "emb_10_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_10_offset_shape dram malloc failed!");
    synLaunchTensorInfo emb_10_offset_shape_tr_info = {"emb_10_offset_shape", emb_10_offset_shape_dram};
    UNUSED(emb_10_offset_shape_tr_info); // For single op tests
    synTensor emb_10_offset_shape = createTensor(1U, syn_type_int32, emb_10_offset_shape_sizes, true, "emb_10_offset_shape");
    UNUSED(emb_10_offset_shape); // For single op tests

    synTensor emb_10_embbag_dedw_EMB_in_vec[9] = {emb_10_embbag_dedw_grad_inter, emb_10_embbag_weight_golden, emb_10_embbag_momentum, emb_10_embbag_dedw_param_table_indices, emb_10_offset_shape, emb_0_embbag_timestamp, emb_0_embbag_rate, emb_10_embbag_valid_indices, emb_10_embbag_valid_indices};


    // create emb_10_embbag_dedw_weight_output_golden tensor
    const unsigned emb_10_embbag_dedw_weight_output_golden_sizes[] = {5623, 32};
    uint64_t emb_10_embbag_dedw_weight_output_golden_dram = emb_10_embbag_weight_golden_dram;
    synLaunchTensorInfo emb_10_embbag_dedw_weight_output_golden_tr_info = {
        "emb_10_embbag_dedw_weight_output_golden",
        emb_10_embbag_dedw_weight_output_golden_dram};
    UNUSED(emb_10_embbag_dedw_weight_output_golden_tr_info); // For single op tests
    synTensor emb_10_embbag_dedw_weight_output_golden = createTensor(2U, syn_type_single, emb_10_embbag_dedw_weight_output_golden_sizes, true, "emb_10_embbag_dedw_weight_output_golden");
    UNUSED(emb_10_embbag_dedw_weight_output_golden); // For single op tests

    // create emb_10_embbag_dedw_momentum_output tensor
    const unsigned emb_10_embbag_dedw_momentum_output_sizes[] = {5623, 32};
    uint64_t emb_10_embbag_dedw_momentum_output_dram;
    unsigned emb_10_embbag_dedw_momentum_output_size = 5623*32;
    unsigned emb_10_embbag_dedw_momentum_output_size_in_bytes = emb_10_embbag_dedw_momentum_output_size * sizeof(float) ;
    status = hbmAlloc(emb_10_embbag_dedw_momentum_output_size_in_bytes, &emb_10_embbag_dedw_momentum_output_dram, "emb_10_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_10_embbag_dedw_momentum_output dram malloc failed!");
    synLaunchTensorInfo emb_10_embbag_dedw_momentum_output_tr_info = {"emb_10_embbag_dedw_momentum_output",
                                                                      emb_10_embbag_dedw_momentum_output_dram};
    UNUSED(emb_10_embbag_dedw_momentum_output_tr_info); // For single op tests
    synTensor emb_10_embbag_dedw_momentum_output = createTensor(2U, syn_type_single, emb_10_embbag_dedw_momentum_output_sizes, true, "emb_10_embbag_dedw_momentum_output");
    UNUSED(emb_10_embbag_dedw_momentum_output); // For single op tests

    // create emb_10_embbag_dedw_weight_output tensor
    const unsigned emb_10_embbag_dedw_weight_output_sizes[] = {5623, 32};
    uint64_t emb_10_embbag_dedw_weight_output_dram = emb_10_embbag_weight_dram;
    synLaunchTensorInfo emb_10_embbag_dedw_weight_output_tr_info = {"emb_10_embbag_dedw_weight_output",
                                                                    emb_10_embbag_dedw_weight_output_dram};
    UNUSED(emb_10_embbag_dedw_weight_output_tr_info); // For single op tests
    synTensor emb_10_embbag_dedw_weight_output = createTensor(2U, syn_type_bf16, emb_10_embbag_dedw_weight_output_sizes, true, "emb_10_embbag_dedw_weight_output");
    UNUSED(emb_10_embbag_dedw_weight_output); // For single op tests

    synTensor emb_10_embbag_dedw_EMB_out_vec[3] = {emb_10_embbag_dedw_weight_output_golden, emb_10_embbag_dedw_momentum_output, emb_10_embbag_dedw_weight_output};


    status = synNodeCreate(graphHandle, emb_10_embbag_dedw_EMB_in_vec, emb_10_embbag_dedw_EMB_out_vec, 9, 3, (void *)&emb_10_embbag_dedw_EMB_kernel_params, sizeof(emb_10_embbag_dedw_EMB_kernel_params), "embedding_bag_sgd_bwd_f32", "emb_10_embbag_dedw_EMB", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_10_embbag_dedw_EMB failed!");

    /*************
     * emb_11_embbag_dedw_SLS node
     * inputs: [concat_interact0_grad_input12(128, 32)(dtype=float32), emb_11_embbag_dedw_grad_indices[128](dtype=int32), emb_11_embbag_dedw_lengths[128](dtype=int32), emb_11_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_11_embbag_dedw_grad_inter(128, 32)(dtype=float32)]
     *************/
    ns_SparseLengthsSum::Params emb_11_embbag_dedw_SLS_kernel_params;
    emb_11_embbag_dedw_SLS_kernel_params.mode = EMBEDDED_SC_ZP;

    // create emb_11_embbag_dedw_grad_indices tensor
    const unsigned emb_11_embbag_dedw_grad_indices_sizes[] = {128,};
    uint64_t emb_11_embbag_dedw_grad_indices_dram;
    unsigned emb_11_embbag_dedw_grad_indices_size = 128;
    unsigned emb_11_embbag_dedw_grad_indices_size_in_bytes = emb_11_embbag_dedw_grad_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_11_embbag_dedw_grad_indices_size_in_bytes, &emb_11_embbag_dedw_grad_indices_dram, "emb_11_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_11_embbag_dedw_grad_indices dram malloc failed!");
    synLaunchTensorInfo emb_11_embbag_dedw_grad_indices_tr_info = {"emb_11_embbag_dedw_grad_indices",
                                                                   emb_11_embbag_dedw_grad_indices_dram};
    UNUSED(emb_11_embbag_dedw_grad_indices_tr_info); // For single op tests
    synTensor emb_11_embbag_dedw_grad_indices = createTensor(1U, syn_type_int32, emb_11_embbag_dedw_grad_indices_sizes, true, "emb_11_embbag_dedw_grad_indices");
    UNUSED(emb_11_embbag_dedw_grad_indices); // For single op tests

    // create emb_11_embbag_dedw_lengths tensor
    const unsigned emb_11_embbag_dedw_lengths_sizes[] = {128,};
    uint64_t emb_11_embbag_dedw_lengths_dram;
    unsigned emb_11_embbag_dedw_lengths_size = 128;
    unsigned emb_11_embbag_dedw_lengths_size_in_bytes = emb_11_embbag_dedw_lengths_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_11_embbag_dedw_lengths_size_in_bytes, &emb_11_embbag_dedw_lengths_dram, "emb_11_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_11_embbag_dedw_lengths dram malloc failed!");
    synLaunchTensorInfo emb_11_embbag_dedw_lengths_tr_info = {"emb_11_embbag_dedw_lengths",
                                                              emb_11_embbag_dedw_lengths_dram};
    UNUSED(emb_11_embbag_dedw_lengths_tr_info); // For single op tests
    synTensor emb_11_embbag_dedw_lengths = createTensor(1U, syn_type_int32, emb_11_embbag_dedw_lengths_sizes, true, "emb_11_embbag_dedw_lengths");
    UNUSED(emb_11_embbag_dedw_lengths); // For single op tests

    // create emb_11_embbag_valid_indices tensor
    const unsigned emb_11_embbag_valid_indices_sizes[] = {1,};
    uint64_t emb_11_embbag_valid_indices_dram;
    unsigned emb_11_embbag_valid_indices_size = 1;
    unsigned emb_11_embbag_valid_indices_size_in_bytes = emb_11_embbag_valid_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_11_embbag_valid_indices_size_in_bytes, &emb_11_embbag_valid_indices_dram, "emb_11_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_11_embbag_valid_indices dram malloc failed!");
    synLaunchTensorInfo emb_11_embbag_valid_indices_tr_info = {"emb_11_embbag_valid_indices",
                                                               emb_11_embbag_valid_indices_dram};
    UNUSED(emb_11_embbag_valid_indices_tr_info); // For single op tests
    synTensor emb_11_embbag_valid_indices = createTensor(1U, syn_type_int32, emb_11_embbag_valid_indices_sizes, true, "emb_11_embbag_valid_indices");
    UNUSED(emb_11_embbag_valid_indices); // For single op tests

    synTensor emb_11_embbag_dedw_SLS_in_vec[4] = {concat_interact0_grad_input12, emb_11_embbag_dedw_grad_indices, emb_11_embbag_dedw_lengths, emb_11_embbag_valid_indices};


    // create emb_11_embbag_dedw_grad_inter tensor
    const unsigned emb_11_embbag_dedw_grad_inter_sizes[] = {128, 32};
    synTensor emb_11_embbag_dedw_grad_inter = createTensor(2U, syn_type_single, emb_11_embbag_dedw_grad_inter_sizes, false, "emb_11_embbag_dedw_grad_inter");
    UNUSED(emb_11_embbag_dedw_grad_inter); // For single op tests

    synTensor emb_11_embbag_dedw_SLS_out_vec[1] = {emb_11_embbag_dedw_grad_inter};


    status = synNodeCreate(graphHandle, emb_11_embbag_dedw_SLS_in_vec, emb_11_embbag_dedw_SLS_out_vec, 4, 1, (void *)&emb_11_embbag_dedw_SLS_kernel_params, sizeof(emb_11_embbag_dedw_SLS_kernel_params), "sparse_lengths_sum_fwd_f32", "emb_11_embbag_dedw_SLS", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_11_embbag_dedw_SLS failed!");

    /*************
     * emb_11_embbag_dedw_EMB node
     * inputs: [emb_11_embbag_dedw_grad_inter(128, 32)(dtype=float32), emb_11_embbag_weight_golden[7305771, 32](dtype=float32), emb_11_embbag_momentum[7305771, 32](dtype=float32), emb_11_embbag_dedw_param_table_indices[128](dtype=int32), emb_11_offset_shape[128](dtype=int32), emb_0_embbag_timestamp[1](dtype=int32), emb_0_embbag_rate[1](dtype=float32), emb_11_embbag_valid_indices[1](dtype=int32), emb_11_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_11_embbag_dedw_weight_output_golden(7305771, 32)(dtype=float32), emb_11_embbag_dedw_momentum_output(7305771, 32)(dtype=float32), emb_11_embbag_dedw_weight_output(7305771, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_11_embbag_dedw_EMB_kernel_params;
    emb_11_embbag_dedw_EMB_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_11_embbag_dedw_EMB_kernel_params.sgd.wd = 0;
    emb_11_embbag_dedw_EMB_kernel_params.sgd.mom = 1;
    emb_11_embbag_dedw_EMB_kernel_params.sgd.damp = 0;
    emb_11_embbag_dedw_EMB_kernel_params.sgd.nesterov = false;

    // create emb_11_embbag_weight_golden tensor
    const unsigned emb_11_embbag_weight_golden_sizes[] = {7305771, 32};
    uint64_t emb_11_embbag_weight_golden_dram;
    unsigned emb_11_embbag_weight_golden_size = 7305771*32;
    unsigned emb_11_embbag_weight_golden_size_in_bytes = emb_11_embbag_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(emb_11_embbag_weight_golden_size_in_bytes, &emb_11_embbag_weight_golden_dram, "emb_11_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_11_embbag_weight_golden dram malloc failed!");
    synLaunchTensorInfo emb_11_embbag_weight_golden_tr_info = {"emb_11_embbag_weight_golden",
                                                               emb_11_embbag_weight_golden_dram};
    UNUSED(emb_11_embbag_weight_golden_tr_info); // For single op tests
    synTensor emb_11_embbag_weight_golden = createTensor(2U, syn_type_single, emb_11_embbag_weight_golden_sizes, true, "emb_11_embbag_weight_golden");
    UNUSED(emb_11_embbag_weight_golden); // For single op tests

    // create emb_11_embbag_momentum tensor
    const unsigned emb_11_embbag_momentum_sizes[] = {7305771, 32};
    uint64_t emb_11_embbag_momentum_dram;
    unsigned emb_11_embbag_momentum_size = 7305771*32;
    unsigned emb_11_embbag_momentum_size_in_bytes = emb_11_embbag_momentum_size * sizeof(float) ;
    status = hbmAlloc(emb_11_embbag_momentum_size_in_bytes, &emb_11_embbag_momentum_dram, "emb_11_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_11_embbag_momentum dram malloc failed!");
    synLaunchTensorInfo emb_11_embbag_momentum_tr_info = {"emb_11_embbag_momentum", emb_11_embbag_momentum_dram};
    UNUSED(emb_11_embbag_momentum_tr_info); // For single op tests
    synTensor emb_11_embbag_momentum = createTensor(2U, syn_type_single, emb_11_embbag_momentum_sizes, true, "emb_11_embbag_momentum");
    UNUSED(emb_11_embbag_momentum); // For single op tests

    // create emb_11_embbag_dedw_param_table_indices tensor
    const unsigned emb_11_embbag_dedw_param_table_indices_sizes[] = {128,};
    uint64_t emb_11_embbag_dedw_param_table_indices_dram;
    unsigned emb_11_embbag_dedw_param_table_indices_size = 128;
    unsigned emb_11_embbag_dedw_param_table_indices_size_in_bytes = emb_11_embbag_dedw_param_table_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_11_embbag_dedw_param_table_indices_size_in_bytes, &emb_11_embbag_dedw_param_table_indices_dram, "emb_11_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_11_embbag_dedw_param_table_indices dram malloc failed!");
    synLaunchTensorInfo emb_11_embbag_dedw_param_table_indices_tr_info = {"emb_11_embbag_dedw_param_table_indices",
                                                                          emb_11_embbag_dedw_param_table_indices_dram};
    UNUSED(emb_11_embbag_dedw_param_table_indices_tr_info); // For single op tests
    synTensor emb_11_embbag_dedw_param_table_indices = createTensor(1U, syn_type_int32, emb_11_embbag_dedw_param_table_indices_sizes, true, "emb_11_embbag_dedw_param_table_indices");
    UNUSED(emb_11_embbag_dedw_param_table_indices); // For single op tests

    // create emb_11_offset_shape tensor
    const unsigned emb_11_offset_shape_sizes[] = {128,};
    uint64_t emb_11_offset_shape_dram;
    unsigned emb_11_offset_shape_size = 128;
    unsigned emb_11_offset_shape_size_in_bytes = emb_11_offset_shape_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_11_offset_shape_size_in_bytes, &emb_11_offset_shape_dram, "emb_11_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_11_offset_shape dram malloc failed!");
    synLaunchTensorInfo emb_11_offset_shape_tr_info = {"emb_11_offset_shape", emb_11_offset_shape_dram};
    UNUSED(emb_11_offset_shape_tr_info); // For single op tests
    synTensor emb_11_offset_shape = createTensor(1U, syn_type_int32, emb_11_offset_shape_sizes, true, "emb_11_offset_shape");
    UNUSED(emb_11_offset_shape); // For single op tests

    synTensor emb_11_embbag_dedw_EMB_in_vec[9] = {emb_11_embbag_dedw_grad_inter, emb_11_embbag_weight_golden, emb_11_embbag_momentum, emb_11_embbag_dedw_param_table_indices, emb_11_offset_shape, emb_0_embbag_timestamp, emb_0_embbag_rate, emb_11_embbag_valid_indices, emb_11_embbag_valid_indices};


    // create emb_11_embbag_dedw_weight_output_golden tensor
    const unsigned emb_11_embbag_dedw_weight_output_golden_sizes[] = {7305771, 32};
    uint64_t emb_11_embbag_dedw_weight_output_golden_dram = emb_11_embbag_weight_golden_dram;
    synLaunchTensorInfo emb_11_embbag_dedw_weight_output_golden_tr_info = {
        "emb_11_embbag_dedw_weight_output_golden",
        emb_11_embbag_dedw_weight_output_golden_dram};
    UNUSED(emb_11_embbag_dedw_weight_output_golden_tr_info); // For single op tests
    synTensor emb_11_embbag_dedw_weight_output_golden = createTensor(2U, syn_type_single, emb_11_embbag_dedw_weight_output_golden_sizes, true, "emb_11_embbag_dedw_weight_output_golden");
    UNUSED(emb_11_embbag_dedw_weight_output_golden); // For single op tests

    // create emb_11_embbag_dedw_momentum_output tensor
    const unsigned emb_11_embbag_dedw_momentum_output_sizes[] = {7305771, 32};
    uint64_t emb_11_embbag_dedw_momentum_output_dram;
    unsigned emb_11_embbag_dedw_momentum_output_size = 7305771*32;
    unsigned emb_11_embbag_dedw_momentum_output_size_in_bytes = emb_11_embbag_dedw_momentum_output_size * sizeof(float) ;
    status = hbmAlloc(emb_11_embbag_dedw_momentum_output_size_in_bytes, &emb_11_embbag_dedw_momentum_output_dram, "emb_11_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_11_embbag_dedw_momentum_output dram malloc failed!");
    synLaunchTensorInfo emb_11_embbag_dedw_momentum_output_tr_info = {"emb_11_embbag_dedw_momentum_output",
                                                                      emb_11_embbag_dedw_momentum_output_dram};
    UNUSED(emb_11_embbag_dedw_momentum_output_tr_info); // For single op tests
    synTensor emb_11_embbag_dedw_momentum_output = createTensor(2U, syn_type_single, emb_11_embbag_dedw_momentum_output_sizes, true, "emb_11_embbag_dedw_momentum_output");
    UNUSED(emb_11_embbag_dedw_momentum_output); // For single op tests

    // create emb_11_embbag_dedw_weight_output tensor
    const unsigned emb_11_embbag_dedw_weight_output_sizes[] = {7305771, 32};
    uint64_t emb_11_embbag_dedw_weight_output_dram = emb_11_embbag_weight_dram;
    synLaunchTensorInfo emb_11_embbag_dedw_weight_output_tr_info = {"emb_11_embbag_dedw_weight_output",
                                                                    emb_11_embbag_dedw_weight_output_dram};
    UNUSED(emb_11_embbag_dedw_weight_output_tr_info); // For single op tests
    synTensor emb_11_embbag_dedw_weight_output = createTensor(2U, syn_type_bf16, emb_11_embbag_dedw_weight_output_sizes, true, "emb_11_embbag_dedw_weight_output");
    UNUSED(emb_11_embbag_dedw_weight_output); // For single op tests

    synTensor emb_11_embbag_dedw_EMB_out_vec[3] = {emb_11_embbag_dedw_weight_output_golden, emb_11_embbag_dedw_momentum_output, emb_11_embbag_dedw_weight_output};


    status = synNodeCreate(graphHandle, emb_11_embbag_dedw_EMB_in_vec, emb_11_embbag_dedw_EMB_out_vec, 9, 3, (void *)&emb_11_embbag_dedw_EMB_kernel_params, sizeof(emb_11_embbag_dedw_EMB_kernel_params), "embedding_bag_sgd_bwd_f32", "emb_11_embbag_dedw_EMB", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_11_embbag_dedw_EMB failed!");

    /*************
     * emb_12_embbag_dedw_SLS node
     * inputs: [concat_interact0_grad_input13(128, 32)(dtype=float32), emb_12_embbag_dedw_grad_indices[128](dtype=int32), emb_12_embbag_dedw_lengths[128](dtype=int32), emb_12_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_12_embbag_dedw_grad_inter(128, 32)(dtype=float32)]
     *************/
    ns_SparseLengthsSum::Params emb_12_embbag_dedw_SLS_kernel_params;
    emb_12_embbag_dedw_SLS_kernel_params.mode = EMBEDDED_SC_ZP;

    // create emb_12_embbag_dedw_grad_indices tensor
    const unsigned emb_12_embbag_dedw_grad_indices_sizes[] = {128,};
    uint64_t emb_12_embbag_dedw_grad_indices_dram;
    unsigned emb_12_embbag_dedw_grad_indices_size = 128;
    unsigned emb_12_embbag_dedw_grad_indices_size_in_bytes = emb_12_embbag_dedw_grad_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_12_embbag_dedw_grad_indices_size_in_bytes, &emb_12_embbag_dedw_grad_indices_dram, "emb_12_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_12_embbag_dedw_grad_indices dram malloc failed!");
    synLaunchTensorInfo emb_12_embbag_dedw_grad_indices_tr_info = {"emb_12_embbag_dedw_grad_indices",
                                                                   emb_12_embbag_dedw_grad_indices_dram};
    UNUSED(emb_12_embbag_dedw_grad_indices_tr_info); // For single op tests
    synTensor emb_12_embbag_dedw_grad_indices = createTensor(1U, syn_type_int32, emb_12_embbag_dedw_grad_indices_sizes, true, "emb_12_embbag_dedw_grad_indices");
    UNUSED(emb_12_embbag_dedw_grad_indices); // For single op tests

    // create emb_12_embbag_dedw_lengths tensor
    const unsigned emb_12_embbag_dedw_lengths_sizes[] = {128,};
    uint64_t emb_12_embbag_dedw_lengths_dram;
    unsigned emb_12_embbag_dedw_lengths_size = 128;
    unsigned emb_12_embbag_dedw_lengths_size_in_bytes = emb_12_embbag_dedw_lengths_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_12_embbag_dedw_lengths_size_in_bytes, &emb_12_embbag_dedw_lengths_dram, "emb_12_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_12_embbag_dedw_lengths dram malloc failed!");
    synLaunchTensorInfo emb_12_embbag_dedw_lengths_tr_info = {"emb_12_embbag_dedw_lengths",
                                                              emb_12_embbag_dedw_lengths_dram};
    UNUSED(emb_12_embbag_dedw_lengths_tr_info); // For single op tests
    synTensor emb_12_embbag_dedw_lengths = createTensor(1U, syn_type_int32, emb_12_embbag_dedw_lengths_sizes, true, "emb_12_embbag_dedw_lengths");
    UNUSED(emb_12_embbag_dedw_lengths); // For single op tests

    // create emb_12_embbag_valid_indices tensor
    const unsigned emb_12_embbag_valid_indices_sizes[] = {1,};
    uint64_t emb_12_embbag_valid_indices_dram;
    unsigned emb_12_embbag_valid_indices_size = 1;
    unsigned emb_12_embbag_valid_indices_size_in_bytes = emb_12_embbag_valid_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_12_embbag_valid_indices_size_in_bytes, &emb_12_embbag_valid_indices_dram, "emb_12_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_12_embbag_valid_indices dram malloc failed!");
    synLaunchTensorInfo emb_12_embbag_valid_indices_tr_info = {"emb_12_embbag_valid_indices",
                                                               emb_12_embbag_valid_indices_dram};
    UNUSED(emb_12_embbag_valid_indices_tr_info); // For single op tests
    synTensor emb_12_embbag_valid_indices = createTensor(1U, syn_type_int32, emb_12_embbag_valid_indices_sizes, true, "emb_12_embbag_valid_indices");
    UNUSED(emb_12_embbag_valid_indices); // For single op tests

    synTensor emb_12_embbag_dedw_SLS_in_vec[4] = {concat_interact0_grad_input13, emb_12_embbag_dedw_grad_indices, emb_12_embbag_dedw_lengths, emb_12_embbag_valid_indices};


    // create emb_12_embbag_dedw_grad_inter tensor
    const unsigned emb_12_embbag_dedw_grad_inter_sizes[] = {128, 32};
    synTensor emb_12_embbag_dedw_grad_inter = createTensor(2U, syn_type_single, emb_12_embbag_dedw_grad_inter_sizes, false, "emb_12_embbag_dedw_grad_inter");
    UNUSED(emb_12_embbag_dedw_grad_inter); // For single op tests

    synTensor emb_12_embbag_dedw_SLS_out_vec[1] = {emb_12_embbag_dedw_grad_inter};


    status = synNodeCreate(graphHandle, emb_12_embbag_dedw_SLS_in_vec, emb_12_embbag_dedw_SLS_out_vec, 4, 1, (void *)&emb_12_embbag_dedw_SLS_kernel_params, sizeof(emb_12_embbag_dedw_SLS_kernel_params), "sparse_lengths_sum_fwd_f32", "emb_12_embbag_dedw_SLS", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_12_embbag_dedw_SLS failed!");

    /*************
     * emb_12_embbag_dedw_EMB node
     * inputs: [emb_12_embbag_dedw_grad_inter(128, 32)(dtype=float32), emb_12_embbag_weight_golden[3181, 32](dtype=float32), emb_12_embbag_momentum[3181, 32](dtype=float32), emb_12_embbag_dedw_param_table_indices[128](dtype=int32), emb_12_offset_shape[128](dtype=int32), emb_0_embbag_timestamp[1](dtype=int32), emb_0_embbag_rate[1](dtype=float32), emb_12_embbag_valid_indices[1](dtype=int32), emb_12_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_12_embbag_dedw_weight_output_golden(3181, 32)(dtype=float32), emb_12_embbag_dedw_momentum_output(3181, 32)(dtype=float32), emb_12_embbag_dedw_weight_output(3181, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_12_embbag_dedw_EMB_kernel_params;
    emb_12_embbag_dedw_EMB_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_12_embbag_dedw_EMB_kernel_params.sgd.wd = 0;
    emb_12_embbag_dedw_EMB_kernel_params.sgd.mom = 1;
    emb_12_embbag_dedw_EMB_kernel_params.sgd.damp = 0;
    emb_12_embbag_dedw_EMB_kernel_params.sgd.nesterov = false;

    // create emb_12_embbag_weight_golden tensor
    const unsigned emb_12_embbag_weight_golden_sizes[] = {3181, 32};
    uint64_t emb_12_embbag_weight_golden_dram;
    unsigned emb_12_embbag_weight_golden_size = 3181*32;
    unsigned emb_12_embbag_weight_golden_size_in_bytes = emb_12_embbag_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(emb_12_embbag_weight_golden_size_in_bytes, &emb_12_embbag_weight_golden_dram, "emb_12_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_12_embbag_weight_golden dram malloc failed!");
    synLaunchTensorInfo emb_12_embbag_weight_golden_tr_info = {"emb_12_embbag_weight_golden",
                                                               emb_12_embbag_weight_golden_dram};
    UNUSED(emb_12_embbag_weight_golden_tr_info); // For single op tests
    synTensor emb_12_embbag_weight_golden = createTensor(2U, syn_type_single, emb_12_embbag_weight_golden_sizes, true, "emb_12_embbag_weight_golden");
    UNUSED(emb_12_embbag_weight_golden); // For single op tests

    // create emb_12_embbag_momentum tensor
    const unsigned emb_12_embbag_momentum_sizes[] = {3181, 32};
    uint64_t emb_12_embbag_momentum_dram;
    unsigned emb_12_embbag_momentum_size = 3181*32;
    unsigned emb_12_embbag_momentum_size_in_bytes = emb_12_embbag_momentum_size * sizeof(float) ;
    status = hbmAlloc(emb_12_embbag_momentum_size_in_bytes, &emb_12_embbag_momentum_dram, "emb_12_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_12_embbag_momentum dram malloc failed!");
    synLaunchTensorInfo emb_12_embbag_momentum_tr_info = {"emb_12_embbag_momentum", emb_12_embbag_momentum_dram};
    UNUSED(emb_12_embbag_momentum_tr_info); // For single op tests
    synTensor emb_12_embbag_momentum = createTensor(2U, syn_type_single, emb_12_embbag_momentum_sizes, true, "emb_12_embbag_momentum");
    UNUSED(emb_12_embbag_momentum); // For single op tests

    // create emb_12_embbag_dedw_param_table_indices tensor
    const unsigned emb_12_embbag_dedw_param_table_indices_sizes[] = {128,};
    uint64_t emb_12_embbag_dedw_param_table_indices_dram;
    unsigned emb_12_embbag_dedw_param_table_indices_size = 128;
    unsigned emb_12_embbag_dedw_param_table_indices_size_in_bytes = emb_12_embbag_dedw_param_table_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_12_embbag_dedw_param_table_indices_size_in_bytes, &emb_12_embbag_dedw_param_table_indices_dram, "emb_12_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_12_embbag_dedw_param_table_indices dram malloc failed!");
    synLaunchTensorInfo emb_12_embbag_dedw_param_table_indices_tr_info = {"emb_12_embbag_dedw_param_table_indices",
                                                                          emb_12_embbag_dedw_param_table_indices_dram};
    UNUSED(emb_12_embbag_dedw_param_table_indices_tr_info); // For single op tests
    synTensor emb_12_embbag_dedw_param_table_indices = createTensor(1U, syn_type_int32, emb_12_embbag_dedw_param_table_indices_sizes, true, "emb_12_embbag_dedw_param_table_indices");
    UNUSED(emb_12_embbag_dedw_param_table_indices); // For single op tests

    // create emb_12_offset_shape tensor
    const unsigned emb_12_offset_shape_sizes[] = {128,};
    uint64_t emb_12_offset_shape_dram;
    unsigned emb_12_offset_shape_size = 128;
    unsigned emb_12_offset_shape_size_in_bytes = emb_12_offset_shape_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_12_offset_shape_size_in_bytes, &emb_12_offset_shape_dram, "emb_12_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_12_offset_shape dram malloc failed!");
    synLaunchTensorInfo emb_12_offset_shape_tr_info = {"emb_12_offset_shape", emb_12_offset_shape_dram};
    UNUSED(emb_12_offset_shape_tr_info); // For single op tests
    synTensor emb_12_offset_shape = createTensor(1U, syn_type_int32, emb_12_offset_shape_sizes, true, "emb_12_offset_shape");
    UNUSED(emb_12_offset_shape); // For single op tests

    synTensor emb_12_embbag_dedw_EMB_in_vec[9] = {emb_12_embbag_dedw_grad_inter, emb_12_embbag_weight_golden, emb_12_embbag_momentum, emb_12_embbag_dedw_param_table_indices, emb_12_offset_shape, emb_0_embbag_timestamp, emb_0_embbag_rate, emb_12_embbag_valid_indices, emb_12_embbag_valid_indices};


    // create emb_12_embbag_dedw_weight_output_golden tensor
    const unsigned emb_12_embbag_dedw_weight_output_golden_sizes[] = {3181, 32};
    uint64_t emb_12_embbag_dedw_weight_output_golden_dram = emb_12_embbag_weight_golden_dram;
    synLaunchTensorInfo emb_12_embbag_dedw_weight_output_golden_tr_info = {
        "emb_12_embbag_dedw_weight_output_golden",
        emb_12_embbag_dedw_weight_output_golden_dram};
    UNUSED(emb_12_embbag_dedw_weight_output_golden_tr_info); // For single op tests
    synTensor emb_12_embbag_dedw_weight_output_golden = createTensor(2U, syn_type_single, emb_12_embbag_dedw_weight_output_golden_sizes, true, "emb_12_embbag_dedw_weight_output_golden");
    UNUSED(emb_12_embbag_dedw_weight_output_golden); // For single op tests

    // create emb_12_embbag_dedw_momentum_output tensor
    const unsigned emb_12_embbag_dedw_momentum_output_sizes[] = {3181, 32};
    uint64_t emb_12_embbag_dedw_momentum_output_dram;
    unsigned emb_12_embbag_dedw_momentum_output_size = 3181*32;
    unsigned emb_12_embbag_dedw_momentum_output_size_in_bytes = emb_12_embbag_dedw_momentum_output_size * sizeof(float) ;
    status = hbmAlloc(emb_12_embbag_dedw_momentum_output_size_in_bytes, &emb_12_embbag_dedw_momentum_output_dram, "emb_12_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_12_embbag_dedw_momentum_output dram malloc failed!");
    synLaunchTensorInfo emb_12_embbag_dedw_momentum_output_tr_info = {"emb_12_embbag_dedw_momentum_output",
                                                                      emb_12_embbag_dedw_momentum_output_dram};
    UNUSED(emb_12_embbag_dedw_momentum_output_tr_info); // For single op tests
    synTensor emb_12_embbag_dedw_momentum_output = createTensor(2U, syn_type_single, emb_12_embbag_dedw_momentum_output_sizes, true, "emb_12_embbag_dedw_momentum_output");
    UNUSED(emb_12_embbag_dedw_momentum_output); // For single op tests

    // create emb_12_embbag_dedw_weight_output tensor
    const unsigned emb_12_embbag_dedw_weight_output_sizes[] = {3181, 32};
    uint64_t emb_12_embbag_dedw_weight_output_dram = emb_12_embbag_weight_dram;
    synLaunchTensorInfo emb_12_embbag_dedw_weight_output_tr_info = {"emb_12_embbag_dedw_weight_output",
                                                                    emb_12_embbag_dedw_weight_output_dram};
    UNUSED(emb_12_embbag_dedw_weight_output_tr_info); // For single op tests
    synTensor emb_12_embbag_dedw_weight_output = createTensor(2U, syn_type_bf16, emb_12_embbag_dedw_weight_output_sizes, true, "emb_12_embbag_dedw_weight_output");
    UNUSED(emb_12_embbag_dedw_weight_output); // For single op tests

    synTensor emb_12_embbag_dedw_EMB_out_vec[3] = {emb_12_embbag_dedw_weight_output_golden, emb_12_embbag_dedw_momentum_output, emb_12_embbag_dedw_weight_output};


    status = synNodeCreate(graphHandle, emb_12_embbag_dedw_EMB_in_vec, emb_12_embbag_dedw_EMB_out_vec, 9, 3, (void *)&emb_12_embbag_dedw_EMB_kernel_params, sizeof(emb_12_embbag_dedw_EMB_kernel_params), "embedding_bag_sgd_bwd_f32", "emb_12_embbag_dedw_EMB", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_12_embbag_dedw_EMB failed!");

    /*************
     * emb_13_embbag_dedw_SLS node
     * inputs: [concat_interact0_grad_input14(128, 32)(dtype=float32), emb_13_embbag_dedw_grad_indices[128](dtype=int32), emb_13_embbag_dedw_lengths[128](dtype=int32), emb_13_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_13_embbag_dedw_grad_inter(128, 32)(dtype=float32)]
     *************/
    ns_SparseLengthsSum::Params emb_13_embbag_dedw_SLS_kernel_params;
    emb_13_embbag_dedw_SLS_kernel_params.mode = EMBEDDED_SC_ZP;

    // create emb_13_embbag_dedw_grad_indices tensor
    const unsigned emb_13_embbag_dedw_grad_indices_sizes[] = {128,};
    uint64_t emb_13_embbag_dedw_grad_indices_dram;
    unsigned emb_13_embbag_dedw_grad_indices_size = 128;
    unsigned emb_13_embbag_dedw_grad_indices_size_in_bytes = emb_13_embbag_dedw_grad_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_13_embbag_dedw_grad_indices_size_in_bytes, &emb_13_embbag_dedw_grad_indices_dram, "emb_13_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_13_embbag_dedw_grad_indices dram malloc failed!");
    synLaunchTensorInfo emb_13_embbag_dedw_grad_indices_tr_info = {"emb_13_embbag_dedw_grad_indices",
                                                                   emb_13_embbag_dedw_grad_indices_dram};
    UNUSED(emb_13_embbag_dedw_grad_indices_tr_info); // For single op tests
    synTensor emb_13_embbag_dedw_grad_indices = createTensor(1U, syn_type_int32, emb_13_embbag_dedw_grad_indices_sizes, true, "emb_13_embbag_dedw_grad_indices");
    UNUSED(emb_13_embbag_dedw_grad_indices); // For single op tests

    // create emb_13_embbag_dedw_lengths tensor
    const unsigned emb_13_embbag_dedw_lengths_sizes[] = {128,};
    uint64_t emb_13_embbag_dedw_lengths_dram;
    unsigned emb_13_embbag_dedw_lengths_size = 128;
    unsigned emb_13_embbag_dedw_lengths_size_in_bytes = emb_13_embbag_dedw_lengths_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_13_embbag_dedw_lengths_size_in_bytes, &emb_13_embbag_dedw_lengths_dram, "emb_13_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_13_embbag_dedw_lengths dram malloc failed!");
    synLaunchTensorInfo emb_13_embbag_dedw_lengths_tr_info = {"emb_13_embbag_dedw_lengths",
                                                              emb_13_embbag_dedw_lengths_dram};
    UNUSED(emb_13_embbag_dedw_lengths_tr_info); // For single op tests
    synTensor emb_13_embbag_dedw_lengths = createTensor(1U, syn_type_int32, emb_13_embbag_dedw_lengths_sizes, true, "emb_13_embbag_dedw_lengths");
    UNUSED(emb_13_embbag_dedw_lengths); // For single op tests

    // create emb_13_embbag_valid_indices tensor
    const unsigned emb_13_embbag_valid_indices_sizes[] = {1,};
    uint64_t emb_13_embbag_valid_indices_dram;
    unsigned emb_13_embbag_valid_indices_size = 1;
    unsigned emb_13_embbag_valid_indices_size_in_bytes = emb_13_embbag_valid_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_13_embbag_valid_indices_size_in_bytes, &emb_13_embbag_valid_indices_dram, "emb_13_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_13_embbag_valid_indices dram malloc failed!");
    synLaunchTensorInfo emb_13_embbag_valid_indices_tr_info = {"emb_13_embbag_valid_indices",
                                                               emb_13_embbag_valid_indices_dram};
    UNUSED(emb_13_embbag_valid_indices_tr_info); // For single op tests
    synTensor emb_13_embbag_valid_indices = createTensor(1U, syn_type_int32, emb_13_embbag_valid_indices_sizes, true, "emb_13_embbag_valid_indices");
    UNUSED(emb_13_embbag_valid_indices); // For single op tests

    synTensor emb_13_embbag_dedw_SLS_in_vec[4] = {concat_interact0_grad_input14, emb_13_embbag_dedw_grad_indices, emb_13_embbag_dedw_lengths, emb_13_embbag_valid_indices};


    // create emb_13_embbag_dedw_grad_inter tensor
    const unsigned emb_13_embbag_dedw_grad_inter_sizes[] = {128, 32};
    synTensor emb_13_embbag_dedw_grad_inter = createTensor(2U, syn_type_single, emb_13_embbag_dedw_grad_inter_sizes, false, "emb_13_embbag_dedw_grad_inter");
    UNUSED(emb_13_embbag_dedw_grad_inter); // For single op tests

    synTensor emb_13_embbag_dedw_SLS_out_vec[1] = {emb_13_embbag_dedw_grad_inter};


    status = synNodeCreate(graphHandle, emb_13_embbag_dedw_SLS_in_vec, emb_13_embbag_dedw_SLS_out_vec, 4, 1, (void *)&emb_13_embbag_dedw_SLS_kernel_params, sizeof(emb_13_embbag_dedw_SLS_kernel_params), "sparse_lengths_sum_fwd_f32", "emb_13_embbag_dedw_SLS", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_13_embbag_dedw_SLS failed!");

    /*************
     * emb_13_embbag_dedw_EMB node
     * inputs: [emb_13_embbag_dedw_grad_inter(128, 32)(dtype=float32), emb_13_embbag_weight_golden[27, 32](dtype=float32), emb_13_embbag_momentum[27, 32](dtype=float32), emb_13_embbag_dedw_param_table_indices[128](dtype=int32), emb_13_offset_shape[128](dtype=int32), emb_0_embbag_timestamp[1](dtype=int32), emb_0_embbag_rate[1](dtype=float32), emb_13_embbag_valid_indices[1](dtype=int32), emb_13_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_13_embbag_dedw_weight_output_golden(27, 32)(dtype=float32), emb_13_embbag_dedw_momentum_output(27, 32)(dtype=float32), emb_13_embbag_dedw_weight_output(27, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_13_embbag_dedw_EMB_kernel_params;
    emb_13_embbag_dedw_EMB_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_13_embbag_dedw_EMB_kernel_params.sgd.wd = 0;
    emb_13_embbag_dedw_EMB_kernel_params.sgd.mom = 1;
    emb_13_embbag_dedw_EMB_kernel_params.sgd.damp = 0;
    emb_13_embbag_dedw_EMB_kernel_params.sgd.nesterov = false;

    // create emb_13_embbag_weight_golden tensor
    const unsigned emb_13_embbag_weight_golden_sizes[] = {27, 32};
    uint64_t emb_13_embbag_weight_golden_dram;
    unsigned emb_13_embbag_weight_golden_size = 27*32;
    unsigned emb_13_embbag_weight_golden_size_in_bytes = emb_13_embbag_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(emb_13_embbag_weight_golden_size_in_bytes, &emb_13_embbag_weight_golden_dram, "emb_13_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_13_embbag_weight_golden dram malloc failed!");
    synLaunchTensorInfo emb_13_embbag_weight_golden_tr_info = {"emb_13_embbag_weight_golden",
                                                               emb_13_embbag_weight_golden_dram};
    UNUSED(emb_13_embbag_weight_golden_tr_info); // For single op tests
    synTensor emb_13_embbag_weight_golden = createTensor(2U, syn_type_single, emb_13_embbag_weight_golden_sizes, true, "emb_13_embbag_weight_golden");
    UNUSED(emb_13_embbag_weight_golden); // For single op tests

    // create emb_13_embbag_momentum tensor
    const unsigned emb_13_embbag_momentum_sizes[] = {27, 32};
    uint64_t emb_13_embbag_momentum_dram;
    unsigned emb_13_embbag_momentum_size = 27*32;
    unsigned emb_13_embbag_momentum_size_in_bytes = emb_13_embbag_momentum_size * sizeof(float) ;
    status = hbmAlloc(emb_13_embbag_momentum_size_in_bytes, &emb_13_embbag_momentum_dram, "emb_13_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_13_embbag_momentum dram malloc failed!");
    synLaunchTensorInfo emb_13_embbag_momentum_tr_info = {"emb_13_embbag_momentum", emb_13_embbag_momentum_dram};
    UNUSED(emb_13_embbag_momentum_tr_info); // For single op tests
    synTensor emb_13_embbag_momentum = createTensor(2U, syn_type_single, emb_13_embbag_momentum_sizes, true, "emb_13_embbag_momentum");
    UNUSED(emb_13_embbag_momentum); // For single op tests

    // create emb_13_embbag_dedw_param_table_indices tensor
    const unsigned emb_13_embbag_dedw_param_table_indices_sizes[] = {128,};
    uint64_t emb_13_embbag_dedw_param_table_indices_dram;
    unsigned emb_13_embbag_dedw_param_table_indices_size = 128;
    unsigned emb_13_embbag_dedw_param_table_indices_size_in_bytes = emb_13_embbag_dedw_param_table_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_13_embbag_dedw_param_table_indices_size_in_bytes, &emb_13_embbag_dedw_param_table_indices_dram, "emb_13_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_13_embbag_dedw_param_table_indices dram malloc failed!");
    synLaunchTensorInfo emb_13_embbag_dedw_param_table_indices_tr_info = {"emb_13_embbag_dedw_param_table_indices",
                                                                          emb_13_embbag_dedw_param_table_indices_dram};
    UNUSED(emb_13_embbag_dedw_param_table_indices_tr_info); // For single op tests
    synTensor emb_13_embbag_dedw_param_table_indices = createTensor(1U, syn_type_int32, emb_13_embbag_dedw_param_table_indices_sizes, true, "emb_13_embbag_dedw_param_table_indices");
    UNUSED(emb_13_embbag_dedw_param_table_indices); // For single op tests

    // create emb_13_offset_shape tensor
    const unsigned emb_13_offset_shape_sizes[] = {128,};
    uint64_t emb_13_offset_shape_dram;
    unsigned emb_13_offset_shape_size = 128;
    unsigned emb_13_offset_shape_size_in_bytes = emb_13_offset_shape_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_13_offset_shape_size_in_bytes, &emb_13_offset_shape_dram, "emb_13_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_13_offset_shape dram malloc failed!");
    synLaunchTensorInfo emb_13_offset_shape_tr_info = {"emb_13_offset_shape", emb_13_offset_shape_dram};
    UNUSED(emb_13_offset_shape_tr_info); // For single op tests
    synTensor emb_13_offset_shape = createTensor(1U, syn_type_int32, emb_13_offset_shape_sizes, true, "emb_13_offset_shape");
    UNUSED(emb_13_offset_shape); // For single op tests

    synTensor emb_13_embbag_dedw_EMB_in_vec[9] = {emb_13_embbag_dedw_grad_inter, emb_13_embbag_weight_golden, emb_13_embbag_momentum, emb_13_embbag_dedw_param_table_indices, emb_13_offset_shape, emb_0_embbag_timestamp, emb_0_embbag_rate, emb_13_embbag_valid_indices, emb_13_embbag_valid_indices};


    // create emb_13_embbag_dedw_weight_output_golden tensor
    const unsigned emb_13_embbag_dedw_weight_output_golden_sizes[] = {27, 32};
    uint64_t emb_13_embbag_dedw_weight_output_golden_dram = emb_13_embbag_weight_golden_dram;
    synLaunchTensorInfo emb_13_embbag_dedw_weight_output_golden_tr_info = {
        "emb_13_embbag_dedw_weight_output_golden",
        emb_13_embbag_dedw_weight_output_golden_dram};
    UNUSED(emb_13_embbag_dedw_weight_output_golden_tr_info); // For single op tests
    synTensor emb_13_embbag_dedw_weight_output_golden = createTensor(2U, syn_type_single, emb_13_embbag_dedw_weight_output_golden_sizes, true, "emb_13_embbag_dedw_weight_output_golden");
    UNUSED(emb_13_embbag_dedw_weight_output_golden); // For single op tests

    // create emb_13_embbag_dedw_momentum_output tensor
    const unsigned emb_13_embbag_dedw_momentum_output_sizes[] = {27, 32};
    uint64_t emb_13_embbag_dedw_momentum_output_dram;
    unsigned emb_13_embbag_dedw_momentum_output_size = 27*32;
    unsigned emb_13_embbag_dedw_momentum_output_size_in_bytes = emb_13_embbag_dedw_momentum_output_size * sizeof(float) ;
    status = hbmAlloc(emb_13_embbag_dedw_momentum_output_size_in_bytes, &emb_13_embbag_dedw_momentum_output_dram, "emb_13_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_13_embbag_dedw_momentum_output dram malloc failed!");
    synLaunchTensorInfo emb_13_embbag_dedw_momentum_output_tr_info = {"emb_13_embbag_dedw_momentum_output",
                                                                      emb_13_embbag_dedw_momentum_output_dram};
    UNUSED(emb_13_embbag_dedw_momentum_output_tr_info); // For single op tests
    synTensor emb_13_embbag_dedw_momentum_output = createTensor(2U, syn_type_single, emb_13_embbag_dedw_momentum_output_sizes, true, "emb_13_embbag_dedw_momentum_output");
    UNUSED(emb_13_embbag_dedw_momentum_output); // For single op tests

    // create emb_13_embbag_dedw_weight_output tensor
    const unsigned emb_13_embbag_dedw_weight_output_sizes[] = {27, 32};
    uint64_t emb_13_embbag_dedw_weight_output_dram = emb_13_embbag_weight_dram;
    synLaunchTensorInfo emb_13_embbag_dedw_weight_output_tr_info = {"emb_13_embbag_dedw_weight_output",
                                                                    emb_13_embbag_dedw_weight_output_dram};
    UNUSED(emb_13_embbag_dedw_weight_output_tr_info); // For single op tests
    synTensor emb_13_embbag_dedw_weight_output = createTensor(2U, syn_type_bf16, emb_13_embbag_dedw_weight_output_sizes, true, "emb_13_embbag_dedw_weight_output");
    UNUSED(emb_13_embbag_dedw_weight_output); // For single op tests

    synTensor emb_13_embbag_dedw_EMB_out_vec[3] = {emb_13_embbag_dedw_weight_output_golden, emb_13_embbag_dedw_momentum_output, emb_13_embbag_dedw_weight_output};


    status = synNodeCreate(graphHandle, emb_13_embbag_dedw_EMB_in_vec, emb_13_embbag_dedw_EMB_out_vec, 9, 3, (void *)&emb_13_embbag_dedw_EMB_kernel_params, sizeof(emb_13_embbag_dedw_EMB_kernel_params), "embedding_bag_sgd_bwd_f32", "emb_13_embbag_dedw_EMB", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_13_embbag_dedw_EMB failed!");

    /*************
     * emb_14_embbag_dedw_SLS node
     * inputs: [concat_interact0_grad_input15(128, 32)(dtype=float32), emb_14_embbag_dedw_grad_indices[128](dtype=int32), emb_14_embbag_dedw_lengths[128](dtype=int32), emb_14_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_14_embbag_dedw_grad_inter(128, 32)(dtype=float32)]
     *************/
    ns_SparseLengthsSum::Params emb_14_embbag_dedw_SLS_kernel_params;
    emb_14_embbag_dedw_SLS_kernel_params.mode = EMBEDDED_SC_ZP;

    // create emb_14_embbag_dedw_grad_indices tensor
    const unsigned emb_14_embbag_dedw_grad_indices_sizes[] = {128,};
    uint64_t emb_14_embbag_dedw_grad_indices_dram;
    unsigned emb_14_embbag_dedw_grad_indices_size = 128;
    unsigned emb_14_embbag_dedw_grad_indices_size_in_bytes = emb_14_embbag_dedw_grad_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_14_embbag_dedw_grad_indices_size_in_bytes, &emb_14_embbag_dedw_grad_indices_dram, "emb_14_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_14_embbag_dedw_grad_indices dram malloc failed!");
    synLaunchTensorInfo emb_14_embbag_dedw_grad_indices_tr_info = {"emb_14_embbag_dedw_grad_indices",
                                                                   emb_14_embbag_dedw_grad_indices_dram};
    UNUSED(emb_14_embbag_dedw_grad_indices_tr_info); // For single op tests
    synTensor emb_14_embbag_dedw_grad_indices = createTensor(1U, syn_type_int32, emb_14_embbag_dedw_grad_indices_sizes, true, "emb_14_embbag_dedw_grad_indices");
    UNUSED(emb_14_embbag_dedw_grad_indices); // For single op tests

    // create emb_14_embbag_dedw_lengths tensor
    const unsigned emb_14_embbag_dedw_lengths_sizes[] = {128,};
    uint64_t emb_14_embbag_dedw_lengths_dram;
    unsigned emb_14_embbag_dedw_lengths_size = 128;
    unsigned emb_14_embbag_dedw_lengths_size_in_bytes = emb_14_embbag_dedw_lengths_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_14_embbag_dedw_lengths_size_in_bytes, &emb_14_embbag_dedw_lengths_dram, "emb_14_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_14_embbag_dedw_lengths dram malloc failed!");
    synLaunchTensorInfo emb_14_embbag_dedw_lengths_tr_info = {"emb_14_embbag_dedw_lengths",
                                                              emb_14_embbag_dedw_lengths_dram};
    UNUSED(emb_14_embbag_dedw_lengths_tr_info); // For single op tests
    synTensor emb_14_embbag_dedw_lengths = createTensor(1U, syn_type_int32, emb_14_embbag_dedw_lengths_sizes, true, "emb_14_embbag_dedw_lengths");
    UNUSED(emb_14_embbag_dedw_lengths); // For single op tests

    // create emb_14_embbag_valid_indices tensor
    const unsigned emb_14_embbag_valid_indices_sizes[] = {1,};
    uint64_t emb_14_embbag_valid_indices_dram;
    unsigned emb_14_embbag_valid_indices_size = 1;
    unsigned emb_14_embbag_valid_indices_size_in_bytes = emb_14_embbag_valid_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_14_embbag_valid_indices_size_in_bytes, &emb_14_embbag_valid_indices_dram, "emb_14_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_14_embbag_valid_indices dram malloc failed!");
    synLaunchTensorInfo emb_14_embbag_valid_indices_tr_info = {"emb_14_embbag_valid_indices",
                                                               emb_14_embbag_valid_indices_dram};
    UNUSED(emb_14_embbag_valid_indices_tr_info); // For single op tests
    synTensor emb_14_embbag_valid_indices = createTensor(1U, syn_type_int32, emb_14_embbag_valid_indices_sizes, true, "emb_14_embbag_valid_indices");
    UNUSED(emb_14_embbag_valid_indices); // For single op tests

    synTensor emb_14_embbag_dedw_SLS_in_vec[4] = {concat_interact0_grad_input15, emb_14_embbag_dedw_grad_indices, emb_14_embbag_dedw_lengths, emb_14_embbag_valid_indices};


    // create emb_14_embbag_dedw_grad_inter tensor
    const unsigned emb_14_embbag_dedw_grad_inter_sizes[] = {128, 32};
    synTensor emb_14_embbag_dedw_grad_inter = createTensor(2U, syn_type_single, emb_14_embbag_dedw_grad_inter_sizes, false, "emb_14_embbag_dedw_grad_inter");
    UNUSED(emb_14_embbag_dedw_grad_inter); // For single op tests

    synTensor emb_14_embbag_dedw_SLS_out_vec[1] = {emb_14_embbag_dedw_grad_inter};


    status = synNodeCreate(graphHandle, emb_14_embbag_dedw_SLS_in_vec, emb_14_embbag_dedw_SLS_out_vec, 4, 1, (void *)&emb_14_embbag_dedw_SLS_kernel_params, sizeof(emb_14_embbag_dedw_SLS_kernel_params), "sparse_lengths_sum_fwd_f32", "emb_14_embbag_dedw_SLS", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_14_embbag_dedw_SLS failed!");

    /*************
     * emb_14_embbag_dedw_EMB node
     * inputs: [emb_14_embbag_dedw_grad_inter(128, 32)(dtype=float32), emb_14_embbag_weight_golden[14746, 32](dtype=float32), emb_14_embbag_momentum[14746, 32](dtype=float32), emb_14_embbag_dedw_param_table_indices[128](dtype=int32), emb_14_offset_shape[128](dtype=int32), emb_0_embbag_timestamp[1](dtype=int32), emb_0_embbag_rate[1](dtype=float32), emb_14_embbag_valid_indices[1](dtype=int32), emb_14_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_14_embbag_dedw_weight_output_golden(14746, 32)(dtype=float32), emb_14_embbag_dedw_momentum_output(14746, 32)(dtype=float32), emb_14_embbag_dedw_weight_output(14746, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_14_embbag_dedw_EMB_kernel_params;
    emb_14_embbag_dedw_EMB_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_14_embbag_dedw_EMB_kernel_params.sgd.wd = 0;
    emb_14_embbag_dedw_EMB_kernel_params.sgd.mom = 1;
    emb_14_embbag_dedw_EMB_kernel_params.sgd.damp = 0;
    emb_14_embbag_dedw_EMB_kernel_params.sgd.nesterov = false;

    // create emb_14_embbag_weight_golden tensor
    const unsigned emb_14_embbag_weight_golden_sizes[] = {14746, 32};
    uint64_t emb_14_embbag_weight_golden_dram;
    unsigned emb_14_embbag_weight_golden_size = 14746*32;
    unsigned emb_14_embbag_weight_golden_size_in_bytes = emb_14_embbag_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(emb_14_embbag_weight_golden_size_in_bytes, &emb_14_embbag_weight_golden_dram, "emb_14_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_14_embbag_weight_golden dram malloc failed!");
    synLaunchTensorInfo emb_14_embbag_weight_golden_tr_info = {"emb_14_embbag_weight_golden",
                                                               emb_14_embbag_weight_golden_dram};
    UNUSED(emb_14_embbag_weight_golden_tr_info); // For single op tests
    synTensor emb_14_embbag_weight_golden = createTensor(2U, syn_type_single, emb_14_embbag_weight_golden_sizes, true, "emb_14_embbag_weight_golden");
    UNUSED(emb_14_embbag_weight_golden); // For single op tests

    // create emb_14_embbag_momentum tensor
    const unsigned emb_14_embbag_momentum_sizes[] = {14746, 32};
    uint64_t emb_14_embbag_momentum_dram;
    unsigned emb_14_embbag_momentum_size = 14746*32;
    unsigned emb_14_embbag_momentum_size_in_bytes = emb_14_embbag_momentum_size * sizeof(float) ;
    status = hbmAlloc(emb_14_embbag_momentum_size_in_bytes, &emb_14_embbag_momentum_dram, "emb_14_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_14_embbag_momentum dram malloc failed!");
    synLaunchTensorInfo emb_14_embbag_momentum_tr_info = {"emb_14_embbag_momentum", emb_14_embbag_momentum_dram};
    UNUSED(emb_14_embbag_momentum_tr_info); // For single op tests
    synTensor emb_14_embbag_momentum = createTensor(2U, syn_type_single, emb_14_embbag_momentum_sizes, true, "emb_14_embbag_momentum");
    UNUSED(emb_14_embbag_momentum); // For single op tests

    // create emb_14_embbag_dedw_param_table_indices tensor
    const unsigned emb_14_embbag_dedw_param_table_indices_sizes[] = {128,};
    uint64_t emb_14_embbag_dedw_param_table_indices_dram;
    unsigned emb_14_embbag_dedw_param_table_indices_size = 128;
    unsigned emb_14_embbag_dedw_param_table_indices_size_in_bytes = emb_14_embbag_dedw_param_table_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_14_embbag_dedw_param_table_indices_size_in_bytes, &emb_14_embbag_dedw_param_table_indices_dram, "emb_14_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_14_embbag_dedw_param_table_indices dram malloc failed!");
    synLaunchTensorInfo emb_14_embbag_dedw_param_table_indices_tr_info = {"emb_14_embbag_dedw_param_table_indices",
                                                                          emb_14_embbag_dedw_param_table_indices_dram};
    UNUSED(emb_14_embbag_dedw_param_table_indices_tr_info); // For single op tests
    synTensor emb_14_embbag_dedw_param_table_indices = createTensor(1U, syn_type_int32, emb_14_embbag_dedw_param_table_indices_sizes, true, "emb_14_embbag_dedw_param_table_indices");
    UNUSED(emb_14_embbag_dedw_param_table_indices); // For single op tests

    // create emb_14_offset_shape tensor
    const unsigned emb_14_offset_shape_sizes[] = {128,};
    uint64_t emb_14_offset_shape_dram;
    unsigned emb_14_offset_shape_size = 128;
    unsigned emb_14_offset_shape_size_in_bytes = emb_14_offset_shape_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_14_offset_shape_size_in_bytes, &emb_14_offset_shape_dram, "emb_14_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_14_offset_shape dram malloc failed!");
    synLaunchTensorInfo emb_14_offset_shape_tr_info = {"emb_14_offset_shape", emb_14_offset_shape_dram};
    UNUSED(emb_14_offset_shape_tr_info); // For single op tests
    synTensor emb_14_offset_shape = createTensor(1U, syn_type_int32, emb_14_offset_shape_sizes, true, "emb_14_offset_shape");
    UNUSED(emb_14_offset_shape); // For single op tests

    synTensor emb_14_embbag_dedw_EMB_in_vec[9] = {emb_14_embbag_dedw_grad_inter, emb_14_embbag_weight_golden, emb_14_embbag_momentum, emb_14_embbag_dedw_param_table_indices, emb_14_offset_shape, emb_0_embbag_timestamp, emb_0_embbag_rate, emb_14_embbag_valid_indices, emb_14_embbag_valid_indices};


    // create emb_14_embbag_dedw_weight_output_golden tensor
    const unsigned emb_14_embbag_dedw_weight_output_golden_sizes[] = {14746, 32};
    uint64_t emb_14_embbag_dedw_weight_output_golden_dram = emb_14_embbag_weight_golden_dram;
    synLaunchTensorInfo emb_14_embbag_dedw_weight_output_golden_tr_info = {
        "emb_14_embbag_dedw_weight_output_golden",
        emb_14_embbag_dedw_weight_output_golden_dram};
    UNUSED(emb_14_embbag_dedw_weight_output_golden_tr_info); // For single op tests
    synTensor emb_14_embbag_dedw_weight_output_golden = createTensor(2U, syn_type_single, emb_14_embbag_dedw_weight_output_golden_sizes, true, "emb_14_embbag_dedw_weight_output_golden");
    UNUSED(emb_14_embbag_dedw_weight_output_golden); // For single op tests

    // create emb_14_embbag_dedw_momentum_output tensor
    const unsigned emb_14_embbag_dedw_momentum_output_sizes[] = {14746, 32};
    uint64_t emb_14_embbag_dedw_momentum_output_dram;
    unsigned emb_14_embbag_dedw_momentum_output_size = 14746*32;
    unsigned emb_14_embbag_dedw_momentum_output_size_in_bytes = emb_14_embbag_dedw_momentum_output_size * sizeof(float) ;
    status = hbmAlloc(emb_14_embbag_dedw_momentum_output_size_in_bytes, &emb_14_embbag_dedw_momentum_output_dram, "emb_14_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_14_embbag_dedw_momentum_output dram malloc failed!");
    synLaunchTensorInfo emb_14_embbag_dedw_momentum_output_tr_info = {"emb_14_embbag_dedw_momentum_output",
                                                                      emb_14_embbag_dedw_momentum_output_dram};
    UNUSED(emb_14_embbag_dedw_momentum_output_tr_info); // For single op tests
    synTensor emb_14_embbag_dedw_momentum_output = createTensor(2U, syn_type_single, emb_14_embbag_dedw_momentum_output_sizes, true, "emb_14_embbag_dedw_momentum_output");
    UNUSED(emb_14_embbag_dedw_momentum_output); // For single op tests

    // create emb_14_embbag_dedw_weight_output tensor
    const unsigned emb_14_embbag_dedw_weight_output_sizes[] = {14746, 32};
    uint64_t emb_14_embbag_dedw_weight_output_dram = emb_14_embbag_weight_dram;
    synLaunchTensorInfo emb_14_embbag_dedw_weight_output_tr_info = {"emb_14_embbag_dedw_weight_output",
                                                                    emb_14_embbag_dedw_weight_output_dram};
    UNUSED(emb_14_embbag_dedw_weight_output_tr_info); // For single op tests
    synTensor emb_14_embbag_dedw_weight_output = createTensor(2U, syn_type_bf16, emb_14_embbag_dedw_weight_output_sizes, true, "emb_14_embbag_dedw_weight_output");
    UNUSED(emb_14_embbag_dedw_weight_output); // For single op tests

    synTensor emb_14_embbag_dedw_EMB_out_vec[3] = {emb_14_embbag_dedw_weight_output_golden, emb_14_embbag_dedw_momentum_output, emb_14_embbag_dedw_weight_output};


    status = synNodeCreate(graphHandle, emb_14_embbag_dedw_EMB_in_vec, emb_14_embbag_dedw_EMB_out_vec, 9, 3, (void *)&emb_14_embbag_dedw_EMB_kernel_params, sizeof(emb_14_embbag_dedw_EMB_kernel_params), "embedding_bag_sgd_bwd_f32", "emb_14_embbag_dedw_EMB", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_14_embbag_dedw_EMB failed!");

    /*************
     * emb_15_embbag_dedw_SLS node
     * inputs: [concat_interact0_grad_input16(128, 32)(dtype=float32), emb_15_embbag_dedw_grad_indices[128](dtype=int32), emb_15_embbag_dedw_lengths[128](dtype=int32), emb_15_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_15_embbag_dedw_grad_inter(128, 32)(dtype=float32)]
     *************/
    ns_SparseLengthsSum::Params emb_15_embbag_dedw_SLS_kernel_params;
    emb_15_embbag_dedw_SLS_kernel_params.mode = EMBEDDED_SC_ZP;

    // create emb_15_embbag_dedw_grad_indices tensor
    const unsigned emb_15_embbag_dedw_grad_indices_sizes[] = {128,};
    uint64_t emb_15_embbag_dedw_grad_indices_dram;
    unsigned emb_15_embbag_dedw_grad_indices_size = 128;
    unsigned emb_15_embbag_dedw_grad_indices_size_in_bytes = emb_15_embbag_dedw_grad_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_15_embbag_dedw_grad_indices_size_in_bytes, &emb_15_embbag_dedw_grad_indices_dram, "emb_15_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_15_embbag_dedw_grad_indices dram malloc failed!");
    synLaunchTensorInfo emb_15_embbag_dedw_grad_indices_tr_info = {"emb_15_embbag_dedw_grad_indices",
                                                                   emb_15_embbag_dedw_grad_indices_dram};
    UNUSED(emb_15_embbag_dedw_grad_indices_tr_info); // For single op tests
    synTensor emb_15_embbag_dedw_grad_indices = createTensor(1U, syn_type_int32, emb_15_embbag_dedw_grad_indices_sizes, true, "emb_15_embbag_dedw_grad_indices");
    UNUSED(emb_15_embbag_dedw_grad_indices); // For single op tests

    // create emb_15_embbag_dedw_lengths tensor
    const unsigned emb_15_embbag_dedw_lengths_sizes[] = {128,};
    uint64_t emb_15_embbag_dedw_lengths_dram;
    unsigned emb_15_embbag_dedw_lengths_size = 128;
    unsigned emb_15_embbag_dedw_lengths_size_in_bytes = emb_15_embbag_dedw_lengths_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_15_embbag_dedw_lengths_size_in_bytes, &emb_15_embbag_dedw_lengths_dram, "emb_15_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_15_embbag_dedw_lengths dram malloc failed!");
    synLaunchTensorInfo emb_15_embbag_dedw_lengths_tr_info = {"emb_15_embbag_dedw_lengths",
                                                              emb_15_embbag_dedw_lengths_dram};
    UNUSED(emb_15_embbag_dedw_lengths_tr_info); // For single op tests
    synTensor emb_15_embbag_dedw_lengths = createTensor(1U, syn_type_int32, emb_15_embbag_dedw_lengths_sizes, true, "emb_15_embbag_dedw_lengths");
    UNUSED(emb_15_embbag_dedw_lengths); // For single op tests

    // create emb_15_embbag_valid_indices tensor
    const unsigned emb_15_embbag_valid_indices_sizes[] = {1,};
    uint64_t emb_15_embbag_valid_indices_dram;
    unsigned emb_15_embbag_valid_indices_size = 1;
    unsigned emb_15_embbag_valid_indices_size_in_bytes = emb_15_embbag_valid_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_15_embbag_valid_indices_size_in_bytes, &emb_15_embbag_valid_indices_dram, "emb_15_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_15_embbag_valid_indices dram malloc failed!");
    synLaunchTensorInfo emb_15_embbag_valid_indices_tr_info = {"emb_15_embbag_valid_indices",
                                                               emb_15_embbag_valid_indices_dram};
    UNUSED(emb_15_embbag_valid_indices_tr_info); // For single op tests
    synTensor emb_15_embbag_valid_indices = createTensor(1U, syn_type_int32, emb_15_embbag_valid_indices_sizes, true, "emb_15_embbag_valid_indices");
    UNUSED(emb_15_embbag_valid_indices); // For single op tests

    synTensor emb_15_embbag_dedw_SLS_in_vec[4] = {concat_interact0_grad_input16, emb_15_embbag_dedw_grad_indices, emb_15_embbag_dedw_lengths, emb_15_embbag_valid_indices};


    // create emb_15_embbag_dedw_grad_inter tensor
    const unsigned emb_15_embbag_dedw_grad_inter_sizes[] = {128, 32};
    synTensor emb_15_embbag_dedw_grad_inter = createTensor(2U, syn_type_single, emb_15_embbag_dedw_grad_inter_sizes, false, "emb_15_embbag_dedw_grad_inter");
    UNUSED(emb_15_embbag_dedw_grad_inter); // For single op tests

    synTensor emb_15_embbag_dedw_SLS_out_vec[1] = {emb_15_embbag_dedw_grad_inter};


    status = synNodeCreate(graphHandle, emb_15_embbag_dedw_SLS_in_vec, emb_15_embbag_dedw_SLS_out_vec, 4, 1, (void *)&emb_15_embbag_dedw_SLS_kernel_params, sizeof(emb_15_embbag_dedw_SLS_kernel_params), "sparse_lengths_sum_fwd_f32", "emb_15_embbag_dedw_SLS", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_15_embbag_dedw_SLS failed!");

    /*************
     * emb_15_embbag_dedw_EMB node
     * inputs: [emb_15_embbag_dedw_grad_inter(128, 32)(dtype=float32), emb_15_embbag_weight_golden[4811892, 32](dtype=float32), emb_15_embbag_momentum[4811892, 32](dtype=float32), emb_15_embbag_dedw_param_table_indices[128](dtype=int32), emb_15_offset_shape[128](dtype=int32), emb_0_embbag_timestamp[1](dtype=int32), emb_0_embbag_rate[1](dtype=float32), emb_15_embbag_valid_indices[1](dtype=int32), emb_15_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_15_embbag_dedw_weight_output_golden(4811892, 32)(dtype=float32), emb_15_embbag_dedw_momentum_output(4811892, 32)(dtype=float32), emb_15_embbag_dedw_weight_output(4811892, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_15_embbag_dedw_EMB_kernel_params;
    emb_15_embbag_dedw_EMB_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_15_embbag_dedw_EMB_kernel_params.sgd.wd = 0;
    emb_15_embbag_dedw_EMB_kernel_params.sgd.mom = 1;
    emb_15_embbag_dedw_EMB_kernel_params.sgd.damp = 0;
    emb_15_embbag_dedw_EMB_kernel_params.sgd.nesterov = false;

    // create emb_15_embbag_weight_golden tensor
    const unsigned emb_15_embbag_weight_golden_sizes[] = {4811892, 32};
    uint64_t emb_15_embbag_weight_golden_dram;
    unsigned emb_15_embbag_weight_golden_size = 4811892*32;
    unsigned emb_15_embbag_weight_golden_size_in_bytes = emb_15_embbag_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(emb_15_embbag_weight_golden_size_in_bytes, &emb_15_embbag_weight_golden_dram, "emb_15_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_15_embbag_weight_golden dram malloc failed!");
    synLaunchTensorInfo emb_15_embbag_weight_golden_tr_info = {"emb_15_embbag_weight_golden",
                                                               emb_15_embbag_weight_golden_dram};
    UNUSED(emb_15_embbag_weight_golden_tr_info); // For single op tests
    synTensor emb_15_embbag_weight_golden = createTensor(2U, syn_type_single, emb_15_embbag_weight_golden_sizes, true, "emb_15_embbag_weight_golden");
    UNUSED(emb_15_embbag_weight_golden); // For single op tests

    // create emb_15_embbag_momentum tensor
    const unsigned emb_15_embbag_momentum_sizes[] = {4811892, 32};
    uint64_t emb_15_embbag_momentum_dram;
    unsigned emb_15_embbag_momentum_size = 4811892*32;
    unsigned emb_15_embbag_momentum_size_in_bytes = emb_15_embbag_momentum_size * sizeof(float) ;
    status = hbmAlloc(emb_15_embbag_momentum_size_in_bytes, &emb_15_embbag_momentum_dram, "emb_15_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_15_embbag_momentum dram malloc failed!");
    synLaunchTensorInfo emb_15_embbag_momentum_tr_info = {"emb_15_embbag_momentum", emb_15_embbag_momentum_dram};
    UNUSED(emb_15_embbag_momentum_tr_info); // For single op tests
    synTensor emb_15_embbag_momentum = createTensor(2U, syn_type_single, emb_15_embbag_momentum_sizes, true, "emb_15_embbag_momentum");
    UNUSED(emb_15_embbag_momentum); // For single op tests

    // create emb_15_embbag_dedw_param_table_indices tensor
    const unsigned emb_15_embbag_dedw_param_table_indices_sizes[] = {128,};
    uint64_t emb_15_embbag_dedw_param_table_indices_dram;
    unsigned emb_15_embbag_dedw_param_table_indices_size = 128;
    unsigned emb_15_embbag_dedw_param_table_indices_size_in_bytes = emb_15_embbag_dedw_param_table_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_15_embbag_dedw_param_table_indices_size_in_bytes, &emb_15_embbag_dedw_param_table_indices_dram, "emb_15_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_15_embbag_dedw_param_table_indices dram malloc failed!");
    synLaunchTensorInfo emb_15_embbag_dedw_param_table_indices_tr_info = {"emb_15_embbag_dedw_param_table_indices",
                                                                          emb_15_embbag_dedw_param_table_indices_dram};
    UNUSED(emb_15_embbag_dedw_param_table_indices_tr_info); // For single op tests
    synTensor emb_15_embbag_dedw_param_table_indices = createTensor(1U, syn_type_int32, emb_15_embbag_dedw_param_table_indices_sizes, true, "emb_15_embbag_dedw_param_table_indices");
    UNUSED(emb_15_embbag_dedw_param_table_indices); // For single op tests

    // create emb_15_offset_shape tensor
    const unsigned emb_15_offset_shape_sizes[] = {128,};
    uint64_t emb_15_offset_shape_dram;
    unsigned emb_15_offset_shape_size = 128;
    unsigned emb_15_offset_shape_size_in_bytes = emb_15_offset_shape_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_15_offset_shape_size_in_bytes, &emb_15_offset_shape_dram, "emb_15_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_15_offset_shape dram malloc failed!");
    synLaunchTensorInfo emb_15_offset_shape_tr_info = {"emb_15_offset_shape", emb_15_offset_shape_dram};
    UNUSED(emb_15_offset_shape_tr_info); // For single op tests
    synTensor emb_15_offset_shape = createTensor(1U, syn_type_int32, emb_15_offset_shape_sizes, true, "emb_15_offset_shape");
    UNUSED(emb_15_offset_shape); // For single op tests

    synTensor emb_15_embbag_dedw_EMB_in_vec[9] = {emb_15_embbag_dedw_grad_inter, emb_15_embbag_weight_golden, emb_15_embbag_momentum, emb_15_embbag_dedw_param_table_indices, emb_15_offset_shape, emb_0_embbag_timestamp, emb_0_embbag_rate, emb_15_embbag_valid_indices, emb_15_embbag_valid_indices};


    // create emb_15_embbag_dedw_weight_output_golden tensor
    const unsigned emb_15_embbag_dedw_weight_output_golden_sizes[] = {4811892, 32};
    uint64_t emb_15_embbag_dedw_weight_output_golden_dram = emb_15_embbag_weight_golden_dram;
    synLaunchTensorInfo emb_15_embbag_dedw_weight_output_golden_tr_info = {
        "emb_15_embbag_dedw_weight_output_golden",
        emb_15_embbag_dedw_weight_output_golden_dram};
    UNUSED(emb_15_embbag_dedw_weight_output_golden_tr_info); // For single op tests
    synTensor emb_15_embbag_dedw_weight_output_golden = createTensor(2U, syn_type_single, emb_15_embbag_dedw_weight_output_golden_sizes, true, "emb_15_embbag_dedw_weight_output_golden");
    UNUSED(emb_15_embbag_dedw_weight_output_golden); // For single op tests

    // create emb_15_embbag_dedw_momentum_output tensor
    const unsigned emb_15_embbag_dedw_momentum_output_sizes[] = {4811892, 32};
    uint64_t emb_15_embbag_dedw_momentum_output_dram;
    unsigned emb_15_embbag_dedw_momentum_output_size = 4811892*32;
    unsigned emb_15_embbag_dedw_momentum_output_size_in_bytes = emb_15_embbag_dedw_momentum_output_size * sizeof(float) ;
    status = hbmAlloc(emb_15_embbag_dedw_momentum_output_size_in_bytes, &emb_15_embbag_dedw_momentum_output_dram, "emb_15_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_15_embbag_dedw_momentum_output dram malloc failed!");
    synLaunchTensorInfo emb_15_embbag_dedw_momentum_output_tr_info = {"emb_15_embbag_dedw_momentum_output",
                                                                      emb_15_embbag_dedw_momentum_output_dram};
    UNUSED(emb_15_embbag_dedw_momentum_output_tr_info); // For single op tests
    synTensor emb_15_embbag_dedw_momentum_output = createTensor(2U, syn_type_single, emb_15_embbag_dedw_momentum_output_sizes, true, "emb_15_embbag_dedw_momentum_output");
    UNUSED(emb_15_embbag_dedw_momentum_output); // For single op tests

    // create emb_15_embbag_dedw_weight_output tensor
    const unsigned emb_15_embbag_dedw_weight_output_sizes[] = {4811892, 32};
    uint64_t emb_15_embbag_dedw_weight_output_dram = emb_15_embbag_weight_dram;
    synLaunchTensorInfo emb_15_embbag_dedw_weight_output_tr_info = {"emb_15_embbag_dedw_weight_output",
                                                                    emb_15_embbag_dedw_weight_output_dram};
    UNUSED(emb_15_embbag_dedw_weight_output_tr_info); // For single op tests
    synTensor emb_15_embbag_dedw_weight_output = createTensor(2U, syn_type_bf16, emb_15_embbag_dedw_weight_output_sizes, true, "emb_15_embbag_dedw_weight_output");
    UNUSED(emb_15_embbag_dedw_weight_output); // For single op tests

    synTensor emb_15_embbag_dedw_EMB_out_vec[3] = {emb_15_embbag_dedw_weight_output_golden, emb_15_embbag_dedw_momentum_output, emb_15_embbag_dedw_weight_output};


    status = synNodeCreate(graphHandle, emb_15_embbag_dedw_EMB_in_vec, emb_15_embbag_dedw_EMB_out_vec, 9, 3, (void *)&emb_15_embbag_dedw_EMB_kernel_params, sizeof(emb_15_embbag_dedw_EMB_kernel_params), "embedding_bag_sgd_bwd_f32", "emb_15_embbag_dedw_EMB", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_15_embbag_dedw_EMB failed!");

    /*************
     * emb_16_embbag_dedw_SLS node
     * inputs: [concat_interact0_grad_input17(128, 32)(dtype=float32), emb_16_embbag_dedw_grad_indices[128](dtype=int32), emb_16_embbag_dedw_lengths[128](dtype=int32), emb_16_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_16_embbag_dedw_grad_inter(128, 32)(dtype=float32)]
     *************/
    ns_SparseLengthsSum::Params emb_16_embbag_dedw_SLS_kernel_params;
    emb_16_embbag_dedw_SLS_kernel_params.mode = EMBEDDED_SC_ZP;

    // create emb_16_embbag_dedw_grad_indices tensor
    const unsigned emb_16_embbag_dedw_grad_indices_sizes[] = {128,};
    uint64_t emb_16_embbag_dedw_grad_indices_dram;
    unsigned emb_16_embbag_dedw_grad_indices_size = 128;
    unsigned emb_16_embbag_dedw_grad_indices_size_in_bytes = emb_16_embbag_dedw_grad_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_16_embbag_dedw_grad_indices_size_in_bytes, &emb_16_embbag_dedw_grad_indices_dram, "emb_16_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_16_embbag_dedw_grad_indices dram malloc failed!");
    synLaunchTensorInfo emb_16_embbag_dedw_grad_indices_tr_info = {"emb_16_embbag_dedw_grad_indices",
                                                                   emb_16_embbag_dedw_grad_indices_dram};
    UNUSED(emb_16_embbag_dedw_grad_indices_tr_info); // For single op tests
    synTensor emb_16_embbag_dedw_grad_indices = createTensor(1U, syn_type_int32, emb_16_embbag_dedw_grad_indices_sizes, true, "emb_16_embbag_dedw_grad_indices");
    UNUSED(emb_16_embbag_dedw_grad_indices); // For single op tests

    // create emb_16_embbag_dedw_lengths tensor
    const unsigned emb_16_embbag_dedw_lengths_sizes[] = {128,};
    uint64_t emb_16_embbag_dedw_lengths_dram;
    unsigned emb_16_embbag_dedw_lengths_size = 128;
    unsigned emb_16_embbag_dedw_lengths_size_in_bytes = emb_16_embbag_dedw_lengths_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_16_embbag_dedw_lengths_size_in_bytes, &emb_16_embbag_dedw_lengths_dram, "emb_16_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_16_embbag_dedw_lengths dram malloc failed!");
    synLaunchTensorInfo emb_16_embbag_dedw_lengths_tr_info = {"emb_16_embbag_dedw_lengths",
                                                              emb_16_embbag_dedw_lengths_dram};
    UNUSED(emb_16_embbag_dedw_lengths_tr_info); // For single op tests
    synTensor emb_16_embbag_dedw_lengths = createTensor(1U, syn_type_int32, emb_16_embbag_dedw_lengths_sizes, true, "emb_16_embbag_dedw_lengths");
    UNUSED(emb_16_embbag_dedw_lengths); // For single op tests

    // create emb_16_embbag_valid_indices tensor
    const unsigned emb_16_embbag_valid_indices_sizes[] = {1,};
    uint64_t emb_16_embbag_valid_indices_dram;
    unsigned emb_16_embbag_valid_indices_size = 1;
    unsigned emb_16_embbag_valid_indices_size_in_bytes = emb_16_embbag_valid_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_16_embbag_valid_indices_size_in_bytes, &emb_16_embbag_valid_indices_dram, "emb_16_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_16_embbag_valid_indices dram malloc failed!");
    synLaunchTensorInfo emb_16_embbag_valid_indices_tr_info = {"emb_16_embbag_valid_indices",
                                                               emb_16_embbag_valid_indices_dram};
    UNUSED(emb_16_embbag_valid_indices_tr_info); // For single op tests
    synTensor emb_16_embbag_valid_indices = createTensor(1U, syn_type_int32, emb_16_embbag_valid_indices_sizes, true, "emb_16_embbag_valid_indices");
    UNUSED(emb_16_embbag_valid_indices); // For single op tests

    synTensor emb_16_embbag_dedw_SLS_in_vec[4] = {concat_interact0_grad_input17, emb_16_embbag_dedw_grad_indices, emb_16_embbag_dedw_lengths, emb_16_embbag_valid_indices};


    // create emb_16_embbag_dedw_grad_inter tensor
    const unsigned emb_16_embbag_dedw_grad_inter_sizes[] = {128, 32};
    synTensor emb_16_embbag_dedw_grad_inter = createTensor(2U, syn_type_single, emb_16_embbag_dedw_grad_inter_sizes, false, "emb_16_embbag_dedw_grad_inter");
    UNUSED(emb_16_embbag_dedw_grad_inter); // For single op tests

    synTensor emb_16_embbag_dedw_SLS_out_vec[1] = {emb_16_embbag_dedw_grad_inter};


    status = synNodeCreate(graphHandle, emb_16_embbag_dedw_SLS_in_vec, emb_16_embbag_dedw_SLS_out_vec, 4, 1, (void *)&emb_16_embbag_dedw_SLS_kernel_params, sizeof(emb_16_embbag_dedw_SLS_kernel_params), "sparse_lengths_sum_fwd_f32", "emb_16_embbag_dedw_SLS", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_16_embbag_dedw_SLS failed!");

    /*************
     * emb_16_embbag_dedw_EMB node
     * inputs: [emb_16_embbag_dedw_grad_inter(128, 32)(dtype=float32), emb_16_embbag_weight_golden[10, 32](dtype=float32), emb_16_embbag_momentum[10, 32](dtype=float32), emb_16_embbag_dedw_param_table_indices[128](dtype=int32), emb_16_offset_shape[128](dtype=int32), emb_0_embbag_timestamp[1](dtype=int32), emb_0_embbag_rate[1](dtype=float32), emb_16_embbag_valid_indices[1](dtype=int32), emb_16_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_16_embbag_dedw_weight_output_golden(10, 32)(dtype=float32), emb_16_embbag_dedw_momentum_output(10, 32)(dtype=float32), emb_16_embbag_dedw_weight_output(10, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_16_embbag_dedw_EMB_kernel_params;
    emb_16_embbag_dedw_EMB_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_16_embbag_dedw_EMB_kernel_params.sgd.wd = 0;
    emb_16_embbag_dedw_EMB_kernel_params.sgd.mom = 1;
    emb_16_embbag_dedw_EMB_kernel_params.sgd.damp = 0;
    emb_16_embbag_dedw_EMB_kernel_params.sgd.nesterov = false;

    // create emb_16_embbag_weight_golden tensor
    const unsigned emb_16_embbag_weight_golden_sizes[] = {10, 32};
    uint64_t emb_16_embbag_weight_golden_dram;
    unsigned emb_16_embbag_weight_golden_size = 10*32;
    unsigned emb_16_embbag_weight_golden_size_in_bytes = emb_16_embbag_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(emb_16_embbag_weight_golden_size_in_bytes, &emb_16_embbag_weight_golden_dram, "emb_16_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_16_embbag_weight_golden dram malloc failed!");
    synLaunchTensorInfo emb_16_embbag_weight_golden_tr_info = {"emb_16_embbag_weight_golden",
                                                               emb_16_embbag_weight_golden_dram};
    UNUSED(emb_16_embbag_weight_golden_tr_info); // For single op tests
    synTensor emb_16_embbag_weight_golden = createTensor(2U, syn_type_single, emb_16_embbag_weight_golden_sizes, true, "emb_16_embbag_weight_golden");
    UNUSED(emb_16_embbag_weight_golden); // For single op tests

    // create emb_16_embbag_momentum tensor
    const unsigned emb_16_embbag_momentum_sizes[] = {10, 32};
    uint64_t emb_16_embbag_momentum_dram;
    unsigned emb_16_embbag_momentum_size = 10*32;
    unsigned emb_16_embbag_momentum_size_in_bytes = emb_16_embbag_momentum_size * sizeof(float) ;
    status = hbmAlloc(emb_16_embbag_momentum_size_in_bytes, &emb_16_embbag_momentum_dram, "emb_16_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_16_embbag_momentum dram malloc failed!");
    synLaunchTensorInfo emb_16_embbag_momentum_tr_info = {"emb_16_embbag_momentum", emb_16_embbag_momentum_dram};
    UNUSED(emb_16_embbag_momentum_tr_info); // For single op tests
    synTensor emb_16_embbag_momentum = createTensor(2U, syn_type_single, emb_16_embbag_momentum_sizes, true, "emb_16_embbag_momentum");
    UNUSED(emb_16_embbag_momentum); // For single op tests

    // create emb_16_embbag_dedw_param_table_indices tensor
    const unsigned emb_16_embbag_dedw_param_table_indices_sizes[] = {128,};
    uint64_t emb_16_embbag_dedw_param_table_indices_dram;
    unsigned emb_16_embbag_dedw_param_table_indices_size = 128;
    unsigned emb_16_embbag_dedw_param_table_indices_size_in_bytes = emb_16_embbag_dedw_param_table_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_16_embbag_dedw_param_table_indices_size_in_bytes, &emb_16_embbag_dedw_param_table_indices_dram, "emb_16_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_16_embbag_dedw_param_table_indices dram malloc failed!");
    synLaunchTensorInfo emb_16_embbag_dedw_param_table_indices_tr_info = {"emb_16_embbag_dedw_param_table_indices",
                                                                          emb_16_embbag_dedw_param_table_indices_dram};
    UNUSED(emb_16_embbag_dedw_param_table_indices_tr_info); // For single op tests
    synTensor emb_16_embbag_dedw_param_table_indices = createTensor(1U, syn_type_int32, emb_16_embbag_dedw_param_table_indices_sizes, true, "emb_16_embbag_dedw_param_table_indices");
    UNUSED(emb_16_embbag_dedw_param_table_indices); // For single op tests

    // create emb_16_offset_shape tensor
    const unsigned emb_16_offset_shape_sizes[] = {128,};
    uint64_t emb_16_offset_shape_dram;
    unsigned emb_16_offset_shape_size = 128;
    unsigned emb_16_offset_shape_size_in_bytes = emb_16_offset_shape_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_16_offset_shape_size_in_bytes, &emb_16_offset_shape_dram, "emb_16_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_16_offset_shape dram malloc failed!");
    synLaunchTensorInfo emb_16_offset_shape_tr_info = {"emb_16_offset_shape", emb_16_offset_shape_dram};
    UNUSED(emb_16_offset_shape_tr_info); // For single op tests
    synTensor emb_16_offset_shape = createTensor(1U, syn_type_int32, emb_16_offset_shape_sizes, true, "emb_16_offset_shape");
    UNUSED(emb_16_offset_shape); // For single op tests

    synTensor emb_16_embbag_dedw_EMB_in_vec[9] = {emb_16_embbag_dedw_grad_inter, emb_16_embbag_weight_golden, emb_16_embbag_momentum, emb_16_embbag_dedw_param_table_indices, emb_16_offset_shape, emb_0_embbag_timestamp, emb_0_embbag_rate, emb_16_embbag_valid_indices, emb_16_embbag_valid_indices};


    // create emb_16_embbag_dedw_weight_output_golden tensor
    const unsigned emb_16_embbag_dedw_weight_output_golden_sizes[] = {10, 32};
    uint64_t emb_16_embbag_dedw_weight_output_golden_dram = emb_16_embbag_weight_golden_dram;
    synLaunchTensorInfo emb_16_embbag_dedw_weight_output_golden_tr_info = {
        "emb_16_embbag_dedw_weight_output_golden",
        emb_16_embbag_dedw_weight_output_golden_dram};
    UNUSED(emb_16_embbag_dedw_weight_output_golden_tr_info); // For single op tests
    synTensor emb_16_embbag_dedw_weight_output_golden = createTensor(2U, syn_type_single, emb_16_embbag_dedw_weight_output_golden_sizes, true, "emb_16_embbag_dedw_weight_output_golden");
    UNUSED(emb_16_embbag_dedw_weight_output_golden); // For single op tests

    // create emb_16_embbag_dedw_momentum_output tensor
    const unsigned emb_16_embbag_dedw_momentum_output_sizes[] = {10, 32};
    uint64_t emb_16_embbag_dedw_momentum_output_dram;
    unsigned emb_16_embbag_dedw_momentum_output_size = 10*32;
    unsigned emb_16_embbag_dedw_momentum_output_size_in_bytes = emb_16_embbag_dedw_momentum_output_size * sizeof(float) ;
    status = hbmAlloc(emb_16_embbag_dedw_momentum_output_size_in_bytes, &emb_16_embbag_dedw_momentum_output_dram, "emb_16_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_16_embbag_dedw_momentum_output dram malloc failed!");
    synLaunchTensorInfo emb_16_embbag_dedw_momentum_output_tr_info = {"emb_16_embbag_dedw_momentum_output",
                                                                      emb_16_embbag_dedw_momentum_output_dram};
    UNUSED(emb_16_embbag_dedw_momentum_output_tr_info); // For single op tests
    synTensor emb_16_embbag_dedw_momentum_output = createTensor(2U, syn_type_single, emb_16_embbag_dedw_momentum_output_sizes, true, "emb_16_embbag_dedw_momentum_output");
    UNUSED(emb_16_embbag_dedw_momentum_output); // For single op tests

    // create emb_16_embbag_dedw_weight_output tensor
    const unsigned emb_16_embbag_dedw_weight_output_sizes[] = {10, 32};
    uint64_t emb_16_embbag_dedw_weight_output_dram = emb_16_embbag_weight_dram;
    synLaunchTensorInfo emb_16_embbag_dedw_weight_output_tr_info = {"emb_16_embbag_dedw_weight_output",
                                                                    emb_16_embbag_dedw_weight_output_dram};
    UNUSED(emb_16_embbag_dedw_weight_output_tr_info); // For single op tests
    synTensor emb_16_embbag_dedw_weight_output = createTensor(2U, syn_type_bf16, emb_16_embbag_dedw_weight_output_sizes, true, "emb_16_embbag_dedw_weight_output");
    UNUSED(emb_16_embbag_dedw_weight_output); // For single op tests

    synTensor emb_16_embbag_dedw_EMB_out_vec[3] = {emb_16_embbag_dedw_weight_output_golden, emb_16_embbag_dedw_momentum_output, emb_16_embbag_dedw_weight_output};


    status = synNodeCreate(graphHandle, emb_16_embbag_dedw_EMB_in_vec, emb_16_embbag_dedw_EMB_out_vec, 9, 3, (void *)&emb_16_embbag_dedw_EMB_kernel_params, sizeof(emb_16_embbag_dedw_EMB_kernel_params), "embedding_bag_sgd_bwd_f32", "emb_16_embbag_dedw_EMB", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_16_embbag_dedw_EMB failed!");

    /*************
     * emb_17_embbag_dedw_SLS node
     * inputs: [concat_interact0_grad_input18(128, 32)(dtype=float32), emb_17_embbag_dedw_grad_indices[128](dtype=int32), emb_17_embbag_dedw_lengths[128](dtype=int32), emb_17_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_17_embbag_dedw_grad_inter(128, 32)(dtype=float32)]
     *************/
    ns_SparseLengthsSum::Params emb_17_embbag_dedw_SLS_kernel_params;
    emb_17_embbag_dedw_SLS_kernel_params.mode = EMBEDDED_SC_ZP;

    // create emb_17_embbag_dedw_grad_indices tensor
    const unsigned emb_17_embbag_dedw_grad_indices_sizes[] = {128,};
    uint64_t emb_17_embbag_dedw_grad_indices_dram;
    unsigned emb_17_embbag_dedw_grad_indices_size = 128;
    unsigned emb_17_embbag_dedw_grad_indices_size_in_bytes = emb_17_embbag_dedw_grad_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_17_embbag_dedw_grad_indices_size_in_bytes, &emb_17_embbag_dedw_grad_indices_dram, "emb_17_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_17_embbag_dedw_grad_indices dram malloc failed!");
    synLaunchTensorInfo emb_17_embbag_dedw_grad_indices_tr_info = {"emb_17_embbag_dedw_grad_indices",
                                                                   emb_17_embbag_dedw_grad_indices_dram};
    UNUSED(emb_17_embbag_dedw_grad_indices_tr_info); // For single op tests
    synTensor emb_17_embbag_dedw_grad_indices = createTensor(1U, syn_type_int32, emb_17_embbag_dedw_grad_indices_sizes, true, "emb_17_embbag_dedw_grad_indices");
    UNUSED(emb_17_embbag_dedw_grad_indices); // For single op tests

    // create emb_17_embbag_dedw_lengths tensor
    const unsigned emb_17_embbag_dedw_lengths_sizes[] = {128,};
    uint64_t emb_17_embbag_dedw_lengths_dram;
    unsigned emb_17_embbag_dedw_lengths_size = 128;
    unsigned emb_17_embbag_dedw_lengths_size_in_bytes = emb_17_embbag_dedw_lengths_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_17_embbag_dedw_lengths_size_in_bytes, &emb_17_embbag_dedw_lengths_dram, "emb_17_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_17_embbag_dedw_lengths dram malloc failed!");
    synLaunchTensorInfo emb_17_embbag_dedw_lengths_tr_info = {"emb_17_embbag_dedw_lengths",
                                                              emb_17_embbag_dedw_lengths_dram};
    UNUSED(emb_17_embbag_dedw_lengths_tr_info); // For single op tests
    synTensor emb_17_embbag_dedw_lengths = createTensor(1U, syn_type_int32, emb_17_embbag_dedw_lengths_sizes, true, "emb_17_embbag_dedw_lengths");
    UNUSED(emb_17_embbag_dedw_lengths); // For single op tests

    // create emb_17_embbag_valid_indices tensor
    const unsigned emb_17_embbag_valid_indices_sizes[] = {1,};
    uint64_t emb_17_embbag_valid_indices_dram;
    unsigned emb_17_embbag_valid_indices_size = 1;
    unsigned emb_17_embbag_valid_indices_size_in_bytes = emb_17_embbag_valid_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_17_embbag_valid_indices_size_in_bytes, &emb_17_embbag_valid_indices_dram, "emb_17_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_17_embbag_valid_indices dram malloc failed!");
    synLaunchTensorInfo emb_17_embbag_valid_indices_tr_info = {"emb_17_embbag_valid_indices",
                                                               emb_17_embbag_valid_indices_dram};
    UNUSED(emb_17_embbag_valid_indices_tr_info); // For single op tests
    synTensor emb_17_embbag_valid_indices = createTensor(1U, syn_type_int32, emb_17_embbag_valid_indices_sizes, true, "emb_17_embbag_valid_indices");
    UNUSED(emb_17_embbag_valid_indices); // For single op tests

    synTensor emb_17_embbag_dedw_SLS_in_vec[4] = {concat_interact0_grad_input18, emb_17_embbag_dedw_grad_indices, emb_17_embbag_dedw_lengths, emb_17_embbag_valid_indices};


    // create emb_17_embbag_dedw_grad_inter tensor
    const unsigned emb_17_embbag_dedw_grad_inter_sizes[] = {128, 32};
    synTensor emb_17_embbag_dedw_grad_inter = createTensor(2U, syn_type_single, emb_17_embbag_dedw_grad_inter_sizes, false, "emb_17_embbag_dedw_grad_inter");
    UNUSED(emb_17_embbag_dedw_grad_inter); // For single op tests

    synTensor emb_17_embbag_dedw_SLS_out_vec[1] = {emb_17_embbag_dedw_grad_inter};


    status = synNodeCreate(graphHandle, emb_17_embbag_dedw_SLS_in_vec, emb_17_embbag_dedw_SLS_out_vec, 4, 1, (void *)&emb_17_embbag_dedw_SLS_kernel_params, sizeof(emb_17_embbag_dedw_SLS_kernel_params), "sparse_lengths_sum_fwd_f32", "emb_17_embbag_dedw_SLS", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_17_embbag_dedw_SLS failed!");

    /*************
     * emb_17_embbag_dedw_EMB node
     * inputs: [emb_17_embbag_dedw_grad_inter(128, 32)(dtype=float32), emb_17_embbag_weight_golden[5580, 32](dtype=float32), emb_17_embbag_momentum[5580, 32](dtype=float32), emb_17_embbag_dedw_param_table_indices[128](dtype=int32), emb_17_offset_shape[128](dtype=int32), emb_0_embbag_timestamp[1](dtype=int32), emb_0_embbag_rate[1](dtype=float32), emb_17_embbag_valid_indices[1](dtype=int32), emb_17_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_17_embbag_dedw_weight_output_golden(5580, 32)(dtype=float32), emb_17_embbag_dedw_momentum_output(5580, 32)(dtype=float32), emb_17_embbag_dedw_weight_output(5580, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_17_embbag_dedw_EMB_kernel_params;
    emb_17_embbag_dedw_EMB_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_17_embbag_dedw_EMB_kernel_params.sgd.wd = 0;
    emb_17_embbag_dedw_EMB_kernel_params.sgd.mom = 1;
    emb_17_embbag_dedw_EMB_kernel_params.sgd.damp = 0;
    emb_17_embbag_dedw_EMB_kernel_params.sgd.nesterov = false;

    // create emb_17_embbag_weight_golden tensor
    const unsigned emb_17_embbag_weight_golden_sizes[] = {5580, 32};
    uint64_t emb_17_embbag_weight_golden_dram;
    unsigned emb_17_embbag_weight_golden_size = 5580*32;
    unsigned emb_17_embbag_weight_golden_size_in_bytes = emb_17_embbag_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(emb_17_embbag_weight_golden_size_in_bytes, &emb_17_embbag_weight_golden_dram, "emb_17_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_17_embbag_weight_golden dram malloc failed!");
    synLaunchTensorInfo emb_17_embbag_weight_golden_tr_info = {"emb_17_embbag_weight_golden",
                                                               emb_17_embbag_weight_golden_dram};
    UNUSED(emb_17_embbag_weight_golden_tr_info); // For single op tests
    synTensor emb_17_embbag_weight_golden = createTensor(2U, syn_type_single, emb_17_embbag_weight_golden_sizes, true, "emb_17_embbag_weight_golden");
    UNUSED(emb_17_embbag_weight_golden); // For single op tests

    // create emb_17_embbag_momentum tensor
    const unsigned emb_17_embbag_momentum_sizes[] = {5580, 32};
    uint64_t emb_17_embbag_momentum_dram;
    unsigned emb_17_embbag_momentum_size = 5580*32;
    unsigned emb_17_embbag_momentum_size_in_bytes = emb_17_embbag_momentum_size * sizeof(float) ;
    status = hbmAlloc(emb_17_embbag_momentum_size_in_bytes, &emb_17_embbag_momentum_dram, "emb_17_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_17_embbag_momentum dram malloc failed!");
    synLaunchTensorInfo emb_17_embbag_momentum_tr_info = {"emb_17_embbag_momentum", emb_17_embbag_momentum_dram};
    UNUSED(emb_17_embbag_momentum_tr_info); // For single op tests
    synTensor emb_17_embbag_momentum = createTensor(2U, syn_type_single, emb_17_embbag_momentum_sizes, true, "emb_17_embbag_momentum");
    UNUSED(emb_17_embbag_momentum); // For single op tests

    // create emb_17_embbag_dedw_param_table_indices tensor
    const unsigned emb_17_embbag_dedw_param_table_indices_sizes[] = {128,};
    uint64_t emb_17_embbag_dedw_param_table_indices_dram;
    unsigned emb_17_embbag_dedw_param_table_indices_size = 128;
    unsigned emb_17_embbag_dedw_param_table_indices_size_in_bytes = emb_17_embbag_dedw_param_table_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_17_embbag_dedw_param_table_indices_size_in_bytes, &emb_17_embbag_dedw_param_table_indices_dram, "emb_17_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_17_embbag_dedw_param_table_indices dram malloc failed!");
    synLaunchTensorInfo emb_17_embbag_dedw_param_table_indices_tr_info = {"emb_17_embbag_dedw_param_table_indices",
                                                                          emb_17_embbag_dedw_param_table_indices_dram};
    UNUSED(emb_17_embbag_dedw_param_table_indices_tr_info); // For single op tests
    synTensor emb_17_embbag_dedw_param_table_indices = createTensor(1U, syn_type_int32, emb_17_embbag_dedw_param_table_indices_sizes, true, "emb_17_embbag_dedw_param_table_indices");
    UNUSED(emb_17_embbag_dedw_param_table_indices); // For single op tests

    // create emb_17_offset_shape tensor
    const unsigned emb_17_offset_shape_sizes[] = {128,};
    uint64_t emb_17_offset_shape_dram;
    unsigned emb_17_offset_shape_size = 128;
    unsigned emb_17_offset_shape_size_in_bytes = emb_17_offset_shape_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_17_offset_shape_size_in_bytes, &emb_17_offset_shape_dram, "emb_17_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_17_offset_shape dram malloc failed!");
    synLaunchTensorInfo emb_17_offset_shape_tr_info = {"emb_17_offset_shape", emb_17_offset_shape_dram};
    UNUSED(emb_17_offset_shape_tr_info); // For single op tests
    synTensor emb_17_offset_shape = createTensor(1U, syn_type_int32, emb_17_offset_shape_sizes, true, "emb_17_offset_shape");
    UNUSED(emb_17_offset_shape); // For single op tests

    synTensor emb_17_embbag_dedw_EMB_in_vec[9] = {emb_17_embbag_dedw_grad_inter, emb_17_embbag_weight_golden, emb_17_embbag_momentum, emb_17_embbag_dedw_param_table_indices, emb_17_offset_shape, emb_0_embbag_timestamp, emb_0_embbag_rate, emb_17_embbag_valid_indices, emb_17_embbag_valid_indices};


    // create emb_17_embbag_dedw_weight_output_golden tensor
    const unsigned emb_17_embbag_dedw_weight_output_golden_sizes[] = {5580, 32};
    uint64_t emb_17_embbag_dedw_weight_output_golden_dram = emb_17_embbag_weight_golden_dram;
    synLaunchTensorInfo emb_17_embbag_dedw_weight_output_golden_tr_info = {
        "emb_17_embbag_dedw_weight_output_golden",
        emb_17_embbag_dedw_weight_output_golden_dram};
    UNUSED(emb_17_embbag_dedw_weight_output_golden_tr_info); // For single op tests
    synTensor emb_17_embbag_dedw_weight_output_golden = createTensor(2U, syn_type_single, emb_17_embbag_dedw_weight_output_golden_sizes, true, "emb_17_embbag_dedw_weight_output_golden");
    UNUSED(emb_17_embbag_dedw_weight_output_golden); // For single op tests

    // create emb_17_embbag_dedw_momentum_output tensor
    const unsigned emb_17_embbag_dedw_momentum_output_sizes[] = {5580, 32};
    uint64_t emb_17_embbag_dedw_momentum_output_dram;
    unsigned emb_17_embbag_dedw_momentum_output_size = 5580*32;
    unsigned emb_17_embbag_dedw_momentum_output_size_in_bytes = emb_17_embbag_dedw_momentum_output_size * sizeof(float) ;
    status = hbmAlloc(emb_17_embbag_dedw_momentum_output_size_in_bytes, &emb_17_embbag_dedw_momentum_output_dram, "emb_17_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_17_embbag_dedw_momentum_output dram malloc failed!");
    synLaunchTensorInfo emb_17_embbag_dedw_momentum_output_tr_info = {"emb_17_embbag_dedw_momentum_output",
                                                                      emb_17_embbag_dedw_momentum_output_dram};
    UNUSED(emb_17_embbag_dedw_momentum_output_tr_info); // For single op tests
    synTensor emb_17_embbag_dedw_momentum_output = createTensor(2U, syn_type_single, emb_17_embbag_dedw_momentum_output_sizes, true, "emb_17_embbag_dedw_momentum_output");
    UNUSED(emb_17_embbag_dedw_momentum_output); // For single op tests

    // create emb_17_embbag_dedw_weight_output tensor
    const unsigned emb_17_embbag_dedw_weight_output_sizes[] = {5580, 32};
    uint64_t emb_17_embbag_dedw_weight_output_dram = emb_17_embbag_weight_dram;
    synLaunchTensorInfo emb_17_embbag_dedw_weight_output_tr_info = {"emb_17_embbag_dedw_weight_output",
                                                                    emb_17_embbag_dedw_weight_output_dram};
    UNUSED(emb_17_embbag_dedw_weight_output_tr_info); // For single op tests
    synTensor emb_17_embbag_dedw_weight_output = createTensor(2U, syn_type_bf16, emb_17_embbag_dedw_weight_output_sizes, true, "emb_17_embbag_dedw_weight_output");
    UNUSED(emb_17_embbag_dedw_weight_output); // For single op tests

    synTensor emb_17_embbag_dedw_EMB_out_vec[3] = {emb_17_embbag_dedw_weight_output_golden, emb_17_embbag_dedw_momentum_output, emb_17_embbag_dedw_weight_output};


    status = synNodeCreate(graphHandle, emb_17_embbag_dedw_EMB_in_vec, emb_17_embbag_dedw_EMB_out_vec, 9, 3, (void *)&emb_17_embbag_dedw_EMB_kernel_params, sizeof(emb_17_embbag_dedw_EMB_kernel_params), "embedding_bag_sgd_bwd_f32", "emb_17_embbag_dedw_EMB", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_17_embbag_dedw_EMB failed!");

    /*************
     * emb_18_embbag_dedw_SLS node
     * inputs: [concat_interact0_grad_input19(128, 32)(dtype=float32), emb_18_embbag_dedw_grad_indices[128](dtype=int32), emb_18_embbag_dedw_lengths[128](dtype=int32), emb_18_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_18_embbag_dedw_grad_inter(128, 32)(dtype=float32)]
     *************/
    ns_SparseLengthsSum::Params emb_18_embbag_dedw_SLS_kernel_params;
    emb_18_embbag_dedw_SLS_kernel_params.mode = EMBEDDED_SC_ZP;

    // create emb_18_embbag_dedw_grad_indices tensor
    const unsigned emb_18_embbag_dedw_grad_indices_sizes[] = {128,};
    uint64_t emb_18_embbag_dedw_grad_indices_dram;
    unsigned emb_18_embbag_dedw_grad_indices_size = 128;
    unsigned emb_18_embbag_dedw_grad_indices_size_in_bytes = emb_18_embbag_dedw_grad_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_18_embbag_dedw_grad_indices_size_in_bytes, &emb_18_embbag_dedw_grad_indices_dram, "emb_18_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_18_embbag_dedw_grad_indices dram malloc failed!");
    synLaunchTensorInfo emb_18_embbag_dedw_grad_indices_tr_info = {"emb_18_embbag_dedw_grad_indices",
                                                                   emb_18_embbag_dedw_grad_indices_dram};
    UNUSED(emb_18_embbag_dedw_grad_indices_tr_info); // For single op tests
    synTensor emb_18_embbag_dedw_grad_indices = createTensor(1U, syn_type_int32, emb_18_embbag_dedw_grad_indices_sizes, true, "emb_18_embbag_dedw_grad_indices");
    UNUSED(emb_18_embbag_dedw_grad_indices); // For single op tests

    // create emb_18_embbag_dedw_lengths tensor
    const unsigned emb_18_embbag_dedw_lengths_sizes[] = {128,};
    uint64_t emb_18_embbag_dedw_lengths_dram;
    unsigned emb_18_embbag_dedw_lengths_size = 128;
    unsigned emb_18_embbag_dedw_lengths_size_in_bytes = emb_18_embbag_dedw_lengths_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_18_embbag_dedw_lengths_size_in_bytes, &emb_18_embbag_dedw_lengths_dram, "emb_18_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_18_embbag_dedw_lengths dram malloc failed!");
    synLaunchTensorInfo emb_18_embbag_dedw_lengths_tr_info = {"emb_18_embbag_dedw_lengths",
                                                              emb_18_embbag_dedw_lengths_dram};
    UNUSED(emb_18_embbag_dedw_lengths_tr_info); // For single op tests
    synTensor emb_18_embbag_dedw_lengths = createTensor(1U, syn_type_int32, emb_18_embbag_dedw_lengths_sizes, true, "emb_18_embbag_dedw_lengths");
    UNUSED(emb_18_embbag_dedw_lengths); // For single op tests

    // create emb_18_embbag_valid_indices tensor
    const unsigned emb_18_embbag_valid_indices_sizes[] = {1,};
    uint64_t emb_18_embbag_valid_indices_dram;
    unsigned emb_18_embbag_valid_indices_size = 1;
    unsigned emb_18_embbag_valid_indices_size_in_bytes = emb_18_embbag_valid_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_18_embbag_valid_indices_size_in_bytes, &emb_18_embbag_valid_indices_dram, "emb_18_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_18_embbag_valid_indices dram malloc failed!");
    synLaunchTensorInfo emb_18_embbag_valid_indices_tr_info = {"emb_18_embbag_valid_indices",
                                                               emb_18_embbag_valid_indices_dram};
    UNUSED(emb_18_embbag_valid_indices_tr_info); // For single op tests
    synTensor emb_18_embbag_valid_indices = createTensor(1U, syn_type_int32, emb_18_embbag_valid_indices_sizes, true, "emb_18_embbag_valid_indices");
    UNUSED(emb_18_embbag_valid_indices); // For single op tests

    synTensor emb_18_embbag_dedw_SLS_in_vec[4] = {concat_interact0_grad_input19, emb_18_embbag_dedw_grad_indices, emb_18_embbag_dedw_lengths, emb_18_embbag_valid_indices};


    // create emb_18_embbag_dedw_grad_inter tensor
    const unsigned emb_18_embbag_dedw_grad_inter_sizes[] = {128, 32};
    synTensor emb_18_embbag_dedw_grad_inter = createTensor(2U, syn_type_single, emb_18_embbag_dedw_grad_inter_sizes, false, "emb_18_embbag_dedw_grad_inter");
    UNUSED(emb_18_embbag_dedw_grad_inter); // For single op tests

    synTensor emb_18_embbag_dedw_SLS_out_vec[1] = {emb_18_embbag_dedw_grad_inter};


    status = synNodeCreate(graphHandle, emb_18_embbag_dedw_SLS_in_vec, emb_18_embbag_dedw_SLS_out_vec, 4, 1, (void *)&emb_18_embbag_dedw_SLS_kernel_params, sizeof(emb_18_embbag_dedw_SLS_kernel_params), "sparse_lengths_sum_fwd_f32", "emb_18_embbag_dedw_SLS", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_18_embbag_dedw_SLS failed!");

    /*************
     * emb_18_embbag_dedw_EMB node
     * inputs: [emb_18_embbag_dedw_grad_inter(128, 32)(dtype=float32), emb_18_embbag_weight_golden[2171, 32](dtype=float32), emb_18_embbag_momentum[2171, 32](dtype=float32), emb_18_embbag_dedw_param_table_indices[128](dtype=int32), emb_18_offset_shape[128](dtype=int32), emb_0_embbag_timestamp[1](dtype=int32), emb_0_embbag_rate[1](dtype=float32), emb_18_embbag_valid_indices[1](dtype=int32), emb_18_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_18_embbag_dedw_weight_output_golden(2171, 32)(dtype=float32), emb_18_embbag_dedw_momentum_output(2171, 32)(dtype=float32), emb_18_embbag_dedw_weight_output(2171, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_18_embbag_dedw_EMB_kernel_params;
    emb_18_embbag_dedw_EMB_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_18_embbag_dedw_EMB_kernel_params.sgd.wd = 0;
    emb_18_embbag_dedw_EMB_kernel_params.sgd.mom = 1;
    emb_18_embbag_dedw_EMB_kernel_params.sgd.damp = 0;
    emb_18_embbag_dedw_EMB_kernel_params.sgd.nesterov = false;

    // create emb_18_embbag_weight_golden tensor
    const unsigned emb_18_embbag_weight_golden_sizes[] = {2171, 32};
    uint64_t emb_18_embbag_weight_golden_dram;
    unsigned emb_18_embbag_weight_golden_size = 2171*32;
    unsigned emb_18_embbag_weight_golden_size_in_bytes = emb_18_embbag_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(emb_18_embbag_weight_golden_size_in_bytes, &emb_18_embbag_weight_golden_dram, "emb_18_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_18_embbag_weight_golden dram malloc failed!");
    synLaunchTensorInfo emb_18_embbag_weight_golden_tr_info = {"emb_18_embbag_weight_golden",
                                                               emb_18_embbag_weight_golden_dram};
    UNUSED(emb_18_embbag_weight_golden_tr_info); // For single op tests
    synTensor emb_18_embbag_weight_golden = createTensor(2U, syn_type_single, emb_18_embbag_weight_golden_sizes, true, "emb_18_embbag_weight_golden");
    UNUSED(emb_18_embbag_weight_golden); // For single op tests

    // create emb_18_embbag_momentum tensor
    const unsigned emb_18_embbag_momentum_sizes[] = {2171, 32};
    uint64_t emb_18_embbag_momentum_dram;
    unsigned emb_18_embbag_momentum_size = 2171*32;
    unsigned emb_18_embbag_momentum_size_in_bytes = emb_18_embbag_momentum_size * sizeof(float) ;
    status = hbmAlloc(emb_18_embbag_momentum_size_in_bytes, &emb_18_embbag_momentum_dram, "emb_18_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_18_embbag_momentum dram malloc failed!");
    synLaunchTensorInfo emb_18_embbag_momentum_tr_info = {"emb_18_embbag_momentum", emb_18_embbag_momentum_dram};
    UNUSED(emb_18_embbag_momentum_tr_info); // For single op tests
    synTensor emb_18_embbag_momentum = createTensor(2U, syn_type_single, emb_18_embbag_momentum_sizes, true, "emb_18_embbag_momentum");
    UNUSED(emb_18_embbag_momentum); // For single op tests

    // create emb_18_embbag_dedw_param_table_indices tensor
    const unsigned emb_18_embbag_dedw_param_table_indices_sizes[] = {128,};
    uint64_t emb_18_embbag_dedw_param_table_indices_dram;
    unsigned emb_18_embbag_dedw_param_table_indices_size = 128;
    unsigned emb_18_embbag_dedw_param_table_indices_size_in_bytes = emb_18_embbag_dedw_param_table_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_18_embbag_dedw_param_table_indices_size_in_bytes, &emb_18_embbag_dedw_param_table_indices_dram, "emb_18_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_18_embbag_dedw_param_table_indices dram malloc failed!");
    synLaunchTensorInfo emb_18_embbag_dedw_param_table_indices_tr_info = {"emb_18_embbag_dedw_param_table_indices",
                                                                          emb_18_embbag_dedw_param_table_indices_dram};
    UNUSED(emb_18_embbag_dedw_param_table_indices_tr_info); // For single op tests
    synTensor emb_18_embbag_dedw_param_table_indices = createTensor(1U, syn_type_int32, emb_18_embbag_dedw_param_table_indices_sizes, true, "emb_18_embbag_dedw_param_table_indices");
    UNUSED(emb_18_embbag_dedw_param_table_indices); // For single op tests

    // create emb_18_offset_shape tensor
    const unsigned emb_18_offset_shape_sizes[] = {128,};
    uint64_t emb_18_offset_shape_dram;
    unsigned emb_18_offset_shape_size = 128;
    unsigned emb_18_offset_shape_size_in_bytes = emb_18_offset_shape_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_18_offset_shape_size_in_bytes, &emb_18_offset_shape_dram, "emb_18_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_18_offset_shape dram malloc failed!");
    synLaunchTensorInfo emb_18_offset_shape_tr_info = {"emb_18_offset_shape", emb_18_offset_shape_dram};
    UNUSED(emb_18_offset_shape_tr_info); // For single op tests
    synTensor emb_18_offset_shape = createTensor(1U, syn_type_int32, emb_18_offset_shape_sizes, true, "emb_18_offset_shape");
    UNUSED(emb_18_offset_shape); // For single op tests

    synTensor emb_18_embbag_dedw_EMB_in_vec[9] = {emb_18_embbag_dedw_grad_inter, emb_18_embbag_weight_golden, emb_18_embbag_momentum, emb_18_embbag_dedw_param_table_indices, emb_18_offset_shape, emb_0_embbag_timestamp, emb_0_embbag_rate, emb_18_embbag_valid_indices, emb_18_embbag_valid_indices};


    // create emb_18_embbag_dedw_weight_output_golden tensor
    const unsigned emb_18_embbag_dedw_weight_output_golden_sizes[] = {2171, 32};
    uint64_t emb_18_embbag_dedw_weight_output_golden_dram = emb_18_embbag_weight_golden_dram;
    synLaunchTensorInfo emb_18_embbag_dedw_weight_output_golden_tr_info = {
        "emb_18_embbag_dedw_weight_output_golden",
        emb_18_embbag_dedw_weight_output_golden_dram};
    UNUSED(emb_18_embbag_dedw_weight_output_golden_tr_info); // For single op tests
    synTensor emb_18_embbag_dedw_weight_output_golden = createTensor(2U, syn_type_single, emb_18_embbag_dedw_weight_output_golden_sizes, true, "emb_18_embbag_dedw_weight_output_golden");
    UNUSED(emb_18_embbag_dedw_weight_output_golden); // For single op tests

    // create emb_18_embbag_dedw_momentum_output tensor
    const unsigned emb_18_embbag_dedw_momentum_output_sizes[] = {2171, 32};
    uint64_t emb_18_embbag_dedw_momentum_output_dram;
    unsigned emb_18_embbag_dedw_momentum_output_size = 2171*32;
    unsigned emb_18_embbag_dedw_momentum_output_size_in_bytes = emb_18_embbag_dedw_momentum_output_size * sizeof(float) ;
    status = hbmAlloc(emb_18_embbag_dedw_momentum_output_size_in_bytes, &emb_18_embbag_dedw_momentum_output_dram, "emb_18_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_18_embbag_dedw_momentum_output dram malloc failed!");
    synLaunchTensorInfo emb_18_embbag_dedw_momentum_output_tr_info = {"emb_18_embbag_dedw_momentum_output",
                                                                      emb_18_embbag_dedw_momentum_output_dram};
    UNUSED(emb_18_embbag_dedw_momentum_output_tr_info); // For single op tests
    synTensor emb_18_embbag_dedw_momentum_output = createTensor(2U, syn_type_single, emb_18_embbag_dedw_momentum_output_sizes, true, "emb_18_embbag_dedw_momentum_output");
    UNUSED(emb_18_embbag_dedw_momentum_output); // For single op tests

    // create emb_18_embbag_dedw_weight_output tensor
    const unsigned emb_18_embbag_dedw_weight_output_sizes[] = {2171, 32};
    uint64_t emb_18_embbag_dedw_weight_output_dram = emb_18_embbag_weight_dram;
    synLaunchTensorInfo emb_18_embbag_dedw_weight_output_tr_info = {"emb_18_embbag_dedw_weight_output",
                                                                    emb_18_embbag_dedw_weight_output_dram};
    UNUSED(emb_18_embbag_dedw_weight_output_tr_info); // For single op tests
    synTensor emb_18_embbag_dedw_weight_output = createTensor(2U, syn_type_bf16, emb_18_embbag_dedw_weight_output_sizes, true, "emb_18_embbag_dedw_weight_output");
    UNUSED(emb_18_embbag_dedw_weight_output); // For single op tests

    synTensor emb_18_embbag_dedw_EMB_out_vec[3] = {emb_18_embbag_dedw_weight_output_golden, emb_18_embbag_dedw_momentum_output, emb_18_embbag_dedw_weight_output};


    status = synNodeCreate(graphHandle, emb_18_embbag_dedw_EMB_in_vec, emb_18_embbag_dedw_EMB_out_vec, 9, 3, (void *)&emb_18_embbag_dedw_EMB_kernel_params, sizeof(emb_18_embbag_dedw_EMB_kernel_params), "embedding_bag_sgd_bwd_f32", "emb_18_embbag_dedw_EMB", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_18_embbag_dedw_EMB failed!");

    /*************
     * emb_19_embbag_dedw_SLS node
     * inputs: [concat_interact0_grad_input20(128, 32)(dtype=float32), emb_19_embbag_dedw_grad_indices[128](dtype=int32), emb_19_embbag_dedw_lengths[128](dtype=int32), emb_19_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_19_embbag_dedw_grad_inter(128, 32)(dtype=float32)]
     *************/
    ns_SparseLengthsSum::Params emb_19_embbag_dedw_SLS_kernel_params;
    emb_19_embbag_dedw_SLS_kernel_params.mode = EMBEDDED_SC_ZP;

    // create emb_19_embbag_dedw_grad_indices tensor
    const unsigned emb_19_embbag_dedw_grad_indices_sizes[] = {128,};
    uint64_t emb_19_embbag_dedw_grad_indices_dram;
    unsigned emb_19_embbag_dedw_grad_indices_size = 128;
    unsigned emb_19_embbag_dedw_grad_indices_size_in_bytes = emb_19_embbag_dedw_grad_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_19_embbag_dedw_grad_indices_size_in_bytes, &emb_19_embbag_dedw_grad_indices_dram, "emb_19_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_19_embbag_dedw_grad_indices dram malloc failed!");
    synLaunchTensorInfo emb_19_embbag_dedw_grad_indices_tr_info = {"emb_19_embbag_dedw_grad_indices",
                                                                   emb_19_embbag_dedw_grad_indices_dram};
    UNUSED(emb_19_embbag_dedw_grad_indices_tr_info); // For single op tests
    synTensor emb_19_embbag_dedw_grad_indices = createTensor(1U, syn_type_int32, emb_19_embbag_dedw_grad_indices_sizes, true, "emb_19_embbag_dedw_grad_indices");
    UNUSED(emb_19_embbag_dedw_grad_indices); // For single op tests

    // create emb_19_embbag_dedw_lengths tensor
    const unsigned emb_19_embbag_dedw_lengths_sizes[] = {128,};
    uint64_t emb_19_embbag_dedw_lengths_dram;
    unsigned emb_19_embbag_dedw_lengths_size = 128;
    unsigned emb_19_embbag_dedw_lengths_size_in_bytes = emb_19_embbag_dedw_lengths_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_19_embbag_dedw_lengths_size_in_bytes, &emb_19_embbag_dedw_lengths_dram, "emb_19_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_19_embbag_dedw_lengths dram malloc failed!");
    synLaunchTensorInfo emb_19_embbag_dedw_lengths_tr_info = {"emb_19_embbag_dedw_lengths",
                                                              emb_19_embbag_dedw_lengths_dram};
    UNUSED(emb_19_embbag_dedw_lengths_tr_info); // For single op tests
    synTensor emb_19_embbag_dedw_lengths = createTensor(1U, syn_type_int32, emb_19_embbag_dedw_lengths_sizes, true, "emb_19_embbag_dedw_lengths");
    UNUSED(emb_19_embbag_dedw_lengths); // For single op tests

    // create emb_19_embbag_valid_indices tensor
    const unsigned emb_19_embbag_valid_indices_sizes[] = {1,};
    uint64_t emb_19_embbag_valid_indices_dram;
    unsigned emb_19_embbag_valid_indices_size = 1;
    unsigned emb_19_embbag_valid_indices_size_in_bytes = emb_19_embbag_valid_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_19_embbag_valid_indices_size_in_bytes, &emb_19_embbag_valid_indices_dram, "emb_19_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_19_embbag_valid_indices dram malloc failed!");
    synLaunchTensorInfo emb_19_embbag_valid_indices_tr_info = {"emb_19_embbag_valid_indices",
                                                               emb_19_embbag_valid_indices_dram};
    UNUSED(emb_19_embbag_valid_indices_tr_info); // For single op tests
    synTensor emb_19_embbag_valid_indices = createTensor(1U, syn_type_int32, emb_19_embbag_valid_indices_sizes, true, "emb_19_embbag_valid_indices");
    UNUSED(emb_19_embbag_valid_indices); // For single op tests

    synTensor emb_19_embbag_dedw_SLS_in_vec[4] = {concat_interact0_grad_input20, emb_19_embbag_dedw_grad_indices, emb_19_embbag_dedw_lengths, emb_19_embbag_valid_indices};


    // create emb_19_embbag_dedw_grad_inter tensor
    const unsigned emb_19_embbag_dedw_grad_inter_sizes[] = {128, 32};
    synTensor emb_19_embbag_dedw_grad_inter = createTensor(2U, syn_type_single, emb_19_embbag_dedw_grad_inter_sizes, false, "emb_19_embbag_dedw_grad_inter");
    UNUSED(emb_19_embbag_dedw_grad_inter); // For single op tests

    synTensor emb_19_embbag_dedw_SLS_out_vec[1] = {emb_19_embbag_dedw_grad_inter};


    status = synNodeCreate(graphHandle, emb_19_embbag_dedw_SLS_in_vec, emb_19_embbag_dedw_SLS_out_vec, 4, 1, (void *)&emb_19_embbag_dedw_SLS_kernel_params, sizeof(emb_19_embbag_dedw_SLS_kernel_params), "sparse_lengths_sum_fwd_f32", "emb_19_embbag_dedw_SLS", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_19_embbag_dedw_SLS failed!");

    /*************
     * emb_19_embbag_dedw_EMB node
     * inputs: [emb_19_embbag_dedw_grad_inter(128, 32)(dtype=float32), emb_19_embbag_weight_golden[4, 32](dtype=float32), emb_19_embbag_momentum[4, 32](dtype=float32), emb_19_embbag_dedw_param_table_indices[128](dtype=int32), emb_19_offset_shape[128](dtype=int32), emb_0_embbag_timestamp[1](dtype=int32), emb_0_embbag_rate[1](dtype=float32), emb_19_embbag_valid_indices[1](dtype=int32), emb_19_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_19_embbag_dedw_weight_output_golden(4, 32)(dtype=float32), emb_19_embbag_dedw_momentum_output(4, 32)(dtype=float32), emb_19_embbag_dedw_weight_output(4, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_19_embbag_dedw_EMB_kernel_params;
    emb_19_embbag_dedw_EMB_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_19_embbag_dedw_EMB_kernel_params.sgd.wd = 0;
    emb_19_embbag_dedw_EMB_kernel_params.sgd.mom = 1;
    emb_19_embbag_dedw_EMB_kernel_params.sgd.damp = 0;
    emb_19_embbag_dedw_EMB_kernel_params.sgd.nesterov = false;

    // create emb_19_embbag_weight_golden tensor
    const unsigned emb_19_embbag_weight_golden_sizes[] = {4, 32};
    uint64_t emb_19_embbag_weight_golden_dram;
    unsigned emb_19_embbag_weight_golden_size = 4*32;
    unsigned emb_19_embbag_weight_golden_size_in_bytes = emb_19_embbag_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(emb_19_embbag_weight_golden_size_in_bytes, &emb_19_embbag_weight_golden_dram, "emb_19_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_19_embbag_weight_golden dram malloc failed!");
    synLaunchTensorInfo emb_19_embbag_weight_golden_tr_info = {"emb_19_embbag_weight_golden",
                                                               emb_19_embbag_weight_golden_dram};
    UNUSED(emb_19_embbag_weight_golden_tr_info); // For single op tests
    synTensor emb_19_embbag_weight_golden = createTensor(2U, syn_type_single, emb_19_embbag_weight_golden_sizes, true, "emb_19_embbag_weight_golden");
    UNUSED(emb_19_embbag_weight_golden); // For single op tests

    // create emb_19_embbag_momentum tensor
    const unsigned emb_19_embbag_momentum_sizes[] = {4, 32};
    uint64_t emb_19_embbag_momentum_dram;
    unsigned emb_19_embbag_momentum_size = 4*32;
    unsigned emb_19_embbag_momentum_size_in_bytes = emb_19_embbag_momentum_size * sizeof(float) ;
    status = hbmAlloc(emb_19_embbag_momentum_size_in_bytes, &emb_19_embbag_momentum_dram, "emb_19_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_19_embbag_momentum dram malloc failed!");
    synLaunchTensorInfo emb_19_embbag_momentum_tr_info = {"emb_19_embbag_momentum", emb_19_embbag_momentum_dram};
    UNUSED(emb_19_embbag_momentum_tr_info); // For single op tests
    synTensor emb_19_embbag_momentum = createTensor(2U, syn_type_single, emb_19_embbag_momentum_sizes, true, "emb_19_embbag_momentum");
    UNUSED(emb_19_embbag_momentum); // For single op tests

    // create emb_19_embbag_dedw_param_table_indices tensor
    const unsigned emb_19_embbag_dedw_param_table_indices_sizes[] = {128,};
    uint64_t emb_19_embbag_dedw_param_table_indices_dram;
    unsigned emb_19_embbag_dedw_param_table_indices_size = 128;
    unsigned emb_19_embbag_dedw_param_table_indices_size_in_bytes = emb_19_embbag_dedw_param_table_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_19_embbag_dedw_param_table_indices_size_in_bytes, &emb_19_embbag_dedw_param_table_indices_dram, "emb_19_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_19_embbag_dedw_param_table_indices dram malloc failed!");
    synLaunchTensorInfo emb_19_embbag_dedw_param_table_indices_tr_info = {"emb_19_embbag_dedw_param_table_indices",
                                                                          emb_19_embbag_dedw_param_table_indices_dram};
    UNUSED(emb_19_embbag_dedw_param_table_indices_tr_info); // For single op tests
    synTensor emb_19_embbag_dedw_param_table_indices = createTensor(1U, syn_type_int32, emb_19_embbag_dedw_param_table_indices_sizes, true, "emb_19_embbag_dedw_param_table_indices");
    UNUSED(emb_19_embbag_dedw_param_table_indices); // For single op tests

    // create emb_19_offset_shape tensor
    const unsigned emb_19_offset_shape_sizes[] = {128,};
    uint64_t emb_19_offset_shape_dram;
    unsigned emb_19_offset_shape_size = 128;
    unsigned emb_19_offset_shape_size_in_bytes = emb_19_offset_shape_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_19_offset_shape_size_in_bytes, &emb_19_offset_shape_dram, "emb_19_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_19_offset_shape dram malloc failed!");
    synLaunchTensorInfo emb_19_offset_shape_tr_info = {"emb_19_offset_shape", emb_19_offset_shape_dram};
    UNUSED(emb_19_offset_shape_tr_info); // For single op tests
    synTensor emb_19_offset_shape = createTensor(1U, syn_type_int32, emb_19_offset_shape_sizes, true, "emb_19_offset_shape");
    UNUSED(emb_19_offset_shape); // For single op tests

    synTensor emb_19_embbag_dedw_EMB_in_vec[9] = {emb_19_embbag_dedw_grad_inter, emb_19_embbag_weight_golden, emb_19_embbag_momentum, emb_19_embbag_dedw_param_table_indices, emb_19_offset_shape, emb_0_embbag_timestamp, emb_0_embbag_rate, emb_19_embbag_valid_indices, emb_19_embbag_valid_indices};


    // create emb_19_embbag_dedw_weight_output_golden tensor
    const unsigned emb_19_embbag_dedw_weight_output_golden_sizes[] = {4, 32};
    uint64_t emb_19_embbag_dedw_weight_output_golden_dram = emb_19_embbag_weight_golden_dram;
    synLaunchTensorInfo emb_19_embbag_dedw_weight_output_golden_tr_info = {
        "emb_19_embbag_dedw_weight_output_golden",
        emb_19_embbag_dedw_weight_output_golden_dram};
    UNUSED(emb_19_embbag_dedw_weight_output_golden_tr_info); // For single op tests
    synTensor emb_19_embbag_dedw_weight_output_golden = createTensor(2U, syn_type_single, emb_19_embbag_dedw_weight_output_golden_sizes, true, "emb_19_embbag_dedw_weight_output_golden");
    UNUSED(emb_19_embbag_dedw_weight_output_golden); // For single op tests

    // create emb_19_embbag_dedw_momentum_output tensor
    const unsigned emb_19_embbag_dedw_momentum_output_sizes[] = {4, 32};
    uint64_t emb_19_embbag_dedw_momentum_output_dram;
    unsigned emb_19_embbag_dedw_momentum_output_size = 4*32;
    unsigned emb_19_embbag_dedw_momentum_output_size_in_bytes = emb_19_embbag_dedw_momentum_output_size * sizeof(float) ;
    status = hbmAlloc(emb_19_embbag_dedw_momentum_output_size_in_bytes, &emb_19_embbag_dedw_momentum_output_dram, "emb_19_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_19_embbag_dedw_momentum_output dram malloc failed!");
    synLaunchTensorInfo emb_19_embbag_dedw_momentum_output_tr_info = {"emb_19_embbag_dedw_momentum_output",
                                                                      emb_19_embbag_dedw_momentum_output_dram};
    UNUSED(emb_19_embbag_dedw_momentum_output_tr_info); // For single op tests
    synTensor emb_19_embbag_dedw_momentum_output = createTensor(2U, syn_type_single, emb_19_embbag_dedw_momentum_output_sizes, true, "emb_19_embbag_dedw_momentum_output");
    UNUSED(emb_19_embbag_dedw_momentum_output); // For single op tests

    // create emb_19_embbag_dedw_weight_output tensor
    const unsigned emb_19_embbag_dedw_weight_output_sizes[] = {4, 32};
    uint64_t emb_19_embbag_dedw_weight_output_dram = emb_19_embbag_weight_dram;
    synLaunchTensorInfo emb_19_embbag_dedw_weight_output_tr_info = {"emb_19_embbag_dedw_weight_output",
                                                                    emb_19_embbag_dedw_weight_output_dram};
    UNUSED(emb_19_embbag_dedw_weight_output_tr_info); // For single op tests
    synTensor emb_19_embbag_dedw_weight_output = createTensor(2U, syn_type_bf16, emb_19_embbag_dedw_weight_output_sizes, true, "emb_19_embbag_dedw_weight_output");
    UNUSED(emb_19_embbag_dedw_weight_output); // For single op tests

    synTensor emb_19_embbag_dedw_EMB_out_vec[3] = {emb_19_embbag_dedw_weight_output_golden, emb_19_embbag_dedw_momentum_output, emb_19_embbag_dedw_weight_output};


    status = synNodeCreate(graphHandle, emb_19_embbag_dedw_EMB_in_vec, emb_19_embbag_dedw_EMB_out_vec, 9, 3, (void *)&emb_19_embbag_dedw_EMB_kernel_params, sizeof(emb_19_embbag_dedw_EMB_kernel_params), "embedding_bag_sgd_bwd_f32", "emb_19_embbag_dedw_EMB", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_19_embbag_dedw_EMB failed!");

    /*************
     * emb_20_embbag_dedw_SLS node
     * inputs: [concat_interact0_grad_input21(128, 32)(dtype=float32), emb_20_embbag_dedw_grad_indices[128](dtype=int32), emb_20_embbag_dedw_lengths[128](dtype=int32), emb_20_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_20_embbag_dedw_grad_inter(128, 32)(dtype=float32)]
     *************/
    ns_SparseLengthsSum::Params emb_20_embbag_dedw_SLS_kernel_params;
    emb_20_embbag_dedw_SLS_kernel_params.mode = EMBEDDED_SC_ZP;

    // create emb_20_embbag_dedw_grad_indices tensor
    const unsigned emb_20_embbag_dedw_grad_indices_sizes[] = {128,};
    uint64_t emb_20_embbag_dedw_grad_indices_dram;
    unsigned emb_20_embbag_dedw_grad_indices_size = 128;
    unsigned emb_20_embbag_dedw_grad_indices_size_in_bytes = emb_20_embbag_dedw_grad_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_20_embbag_dedw_grad_indices_size_in_bytes, &emb_20_embbag_dedw_grad_indices_dram, "emb_20_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_20_embbag_dedw_grad_indices dram malloc failed!");
    synLaunchTensorInfo emb_20_embbag_dedw_grad_indices_tr_info = {"emb_20_embbag_dedw_grad_indices",
                                                                   emb_20_embbag_dedw_grad_indices_dram};
    UNUSED(emb_20_embbag_dedw_grad_indices_tr_info); // For single op tests
    synTensor emb_20_embbag_dedw_grad_indices = createTensor(1U, syn_type_int32, emb_20_embbag_dedw_grad_indices_sizes, true, "emb_20_embbag_dedw_grad_indices");
    UNUSED(emb_20_embbag_dedw_grad_indices); // For single op tests

    // create emb_20_embbag_dedw_lengths tensor
    const unsigned emb_20_embbag_dedw_lengths_sizes[] = {128,};
    uint64_t emb_20_embbag_dedw_lengths_dram;
    unsigned emb_20_embbag_dedw_lengths_size = 128;
    unsigned emb_20_embbag_dedw_lengths_size_in_bytes = emb_20_embbag_dedw_lengths_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_20_embbag_dedw_lengths_size_in_bytes, &emb_20_embbag_dedw_lengths_dram, "emb_20_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_20_embbag_dedw_lengths dram malloc failed!");
    synLaunchTensorInfo emb_20_embbag_dedw_lengths_tr_info = {"emb_20_embbag_dedw_lengths",
                                                              emb_20_embbag_dedw_lengths_dram};
    UNUSED(emb_20_embbag_dedw_lengths_tr_info); // For single op tests
    synTensor emb_20_embbag_dedw_lengths = createTensor(1U, syn_type_int32, emb_20_embbag_dedw_lengths_sizes, true, "emb_20_embbag_dedw_lengths");
    UNUSED(emb_20_embbag_dedw_lengths); // For single op tests

    // create emb_20_embbag_valid_indices tensor
    const unsigned emb_20_embbag_valid_indices_sizes[] = {1,};
    uint64_t emb_20_embbag_valid_indices_dram;
    unsigned emb_20_embbag_valid_indices_size = 1;
    unsigned emb_20_embbag_valid_indices_size_in_bytes = emb_20_embbag_valid_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_20_embbag_valid_indices_size_in_bytes, &emb_20_embbag_valid_indices_dram, "emb_20_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_20_embbag_valid_indices dram malloc failed!");
    synLaunchTensorInfo emb_20_embbag_valid_indices_tr_info = {"emb_20_embbag_valid_indices",
                                                               emb_20_embbag_valid_indices_dram};
    UNUSED(emb_20_embbag_valid_indices_tr_info); // For single op tests
    synTensor emb_20_embbag_valid_indices = createTensor(1U, syn_type_int32, emb_20_embbag_valid_indices_sizes, true, "emb_20_embbag_valid_indices");
    UNUSED(emb_20_embbag_valid_indices); // For single op tests

    synTensor emb_20_embbag_dedw_SLS_in_vec[4] = {concat_interact0_grad_input21, emb_20_embbag_dedw_grad_indices, emb_20_embbag_dedw_lengths, emb_20_embbag_valid_indices};


    // create emb_20_embbag_dedw_grad_inter tensor
    const unsigned emb_20_embbag_dedw_grad_inter_sizes[] = {128, 32};
    synTensor emb_20_embbag_dedw_grad_inter = createTensor(2U, syn_type_single, emb_20_embbag_dedw_grad_inter_sizes, false, "emb_20_embbag_dedw_grad_inter");
    UNUSED(emb_20_embbag_dedw_grad_inter); // For single op tests

    synTensor emb_20_embbag_dedw_SLS_out_vec[1] = {emb_20_embbag_dedw_grad_inter};


    status = synNodeCreate(graphHandle, emb_20_embbag_dedw_SLS_in_vec, emb_20_embbag_dedw_SLS_out_vec, 4, 1, (void *)&emb_20_embbag_dedw_SLS_kernel_params, sizeof(emb_20_embbag_dedw_SLS_kernel_params), "sparse_lengths_sum_fwd_f32", "emb_20_embbag_dedw_SLS", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_20_embbag_dedw_SLS failed!");

    /*************
     * emb_20_embbag_dedw_EMB node
     * inputs: [emb_20_embbag_dedw_grad_inter(128, 32)(dtype=float32), emb_20_embbag_weight_golden[6183794, 32](dtype=float32), emb_20_embbag_momentum[6183794, 32](dtype=float32), emb_20_embbag_dedw_param_table_indices[128](dtype=int32), emb_20_offset_shape[128](dtype=int32), emb_0_embbag_timestamp[1](dtype=int32), emb_0_embbag_rate[1](dtype=float32), emb_20_embbag_valid_indices[1](dtype=int32), emb_20_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_20_embbag_dedw_weight_output_golden(6183794, 32)(dtype=float32), emb_20_embbag_dedw_momentum_output(6183794, 32)(dtype=float32), emb_20_embbag_dedw_weight_output(6183794, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_20_embbag_dedw_EMB_kernel_params;
    emb_20_embbag_dedw_EMB_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_20_embbag_dedw_EMB_kernel_params.sgd.wd = 0;
    emb_20_embbag_dedw_EMB_kernel_params.sgd.mom = 1;
    emb_20_embbag_dedw_EMB_kernel_params.sgd.damp = 0;
    emb_20_embbag_dedw_EMB_kernel_params.sgd.nesterov = false;

    // create emb_20_embbag_weight_golden tensor
    const unsigned emb_20_embbag_weight_golden_sizes[] = {6183794, 32};
    uint64_t emb_20_embbag_weight_golden_dram;
    unsigned emb_20_embbag_weight_golden_size = 6183794*32;
    unsigned emb_20_embbag_weight_golden_size_in_bytes = emb_20_embbag_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(emb_20_embbag_weight_golden_size_in_bytes, &emb_20_embbag_weight_golden_dram, "emb_20_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_20_embbag_weight_golden dram malloc failed!");
    synLaunchTensorInfo emb_20_embbag_weight_golden_tr_info = {"emb_20_embbag_weight_golden",
                                                               emb_20_embbag_weight_golden_dram};
    UNUSED(emb_20_embbag_weight_golden_tr_info); // For single op tests
    synTensor emb_20_embbag_weight_golden = createTensor(2U, syn_type_single, emb_20_embbag_weight_golden_sizes, true, "emb_20_embbag_weight_golden");
    UNUSED(emb_20_embbag_weight_golden); // For single op tests

    // create emb_20_embbag_momentum tensor
    const unsigned emb_20_embbag_momentum_sizes[] = {6183794, 32};
    uint64_t emb_20_embbag_momentum_dram;
    unsigned emb_20_embbag_momentum_size = 6183794*32;
    unsigned emb_20_embbag_momentum_size_in_bytes = emb_20_embbag_momentum_size * sizeof(float) ;
    status = hbmAlloc(emb_20_embbag_momentum_size_in_bytes, &emb_20_embbag_momentum_dram, "emb_20_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_20_embbag_momentum dram malloc failed!");
    synLaunchTensorInfo emb_20_embbag_momentum_tr_info = {"emb_20_embbag_momentum", emb_20_embbag_momentum_dram};
    UNUSED(emb_20_embbag_momentum_tr_info); // For single op tests
    synTensor emb_20_embbag_momentum = createTensor(2U, syn_type_single, emb_20_embbag_momentum_sizes, true, "emb_20_embbag_momentum");
    UNUSED(emb_20_embbag_momentum); // For single op tests

    // create emb_20_embbag_dedw_param_table_indices tensor
    const unsigned emb_20_embbag_dedw_param_table_indices_sizes[] = {128,};
    uint64_t emb_20_embbag_dedw_param_table_indices_dram;
    unsigned emb_20_embbag_dedw_param_table_indices_size = 128;
    unsigned emb_20_embbag_dedw_param_table_indices_size_in_bytes = emb_20_embbag_dedw_param_table_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_20_embbag_dedw_param_table_indices_size_in_bytes, &emb_20_embbag_dedw_param_table_indices_dram, "emb_20_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_20_embbag_dedw_param_table_indices dram malloc failed!");
    synLaunchTensorInfo emb_20_embbag_dedw_param_table_indices_tr_info = {"emb_20_embbag_dedw_param_table_indices",
                                                                          emb_20_embbag_dedw_param_table_indices_dram};
    UNUSED(emb_20_embbag_dedw_param_table_indices_tr_info); // For single op tests
    synTensor emb_20_embbag_dedw_param_table_indices = createTensor(1U, syn_type_int32, emb_20_embbag_dedw_param_table_indices_sizes, true, "emb_20_embbag_dedw_param_table_indices");
    UNUSED(emb_20_embbag_dedw_param_table_indices); // For single op tests

    // create emb_20_offset_shape tensor
    const unsigned emb_20_offset_shape_sizes[] = {128,};
    uint64_t emb_20_offset_shape_dram;
    unsigned emb_20_offset_shape_size = 128;
    unsigned emb_20_offset_shape_size_in_bytes = emb_20_offset_shape_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_20_offset_shape_size_in_bytes, &emb_20_offset_shape_dram, "emb_20_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_20_offset_shape dram malloc failed!");
    synLaunchTensorInfo emb_20_offset_shape_tr_info = {"emb_20_offset_shape", emb_20_offset_shape_dram};
    UNUSED(emb_20_offset_shape_tr_info); // For single op tests
    synTensor emb_20_offset_shape = createTensor(1U, syn_type_int32, emb_20_offset_shape_sizes, true, "emb_20_offset_shape");
    UNUSED(emb_20_offset_shape); // For single op tests

    synTensor emb_20_embbag_dedw_EMB_in_vec[9] = {emb_20_embbag_dedw_grad_inter, emb_20_embbag_weight_golden, emb_20_embbag_momentum, emb_20_embbag_dedw_param_table_indices, emb_20_offset_shape, emb_0_embbag_timestamp, emb_0_embbag_rate, emb_20_embbag_valid_indices, emb_20_embbag_valid_indices};


    // create emb_20_embbag_dedw_weight_output_golden tensor
    const unsigned emb_20_embbag_dedw_weight_output_golden_sizes[] = {6183794, 32};
    uint64_t emb_20_embbag_dedw_weight_output_golden_dram = emb_20_embbag_weight_golden_dram;
    synLaunchTensorInfo emb_20_embbag_dedw_weight_output_golden_tr_info = {
        "emb_20_embbag_dedw_weight_output_golden",
        emb_20_embbag_dedw_weight_output_golden_dram};
    UNUSED(emb_20_embbag_dedw_weight_output_golden_tr_info); // For single op tests
    synTensor emb_20_embbag_dedw_weight_output_golden = createTensor(2U, syn_type_single, emb_20_embbag_dedw_weight_output_golden_sizes, true, "emb_20_embbag_dedw_weight_output_golden");
    UNUSED(emb_20_embbag_dedw_weight_output_golden); // For single op tests

    // create emb_20_embbag_dedw_momentum_output tensor
    const unsigned emb_20_embbag_dedw_momentum_output_sizes[] = {6183794, 32};
    uint64_t emb_20_embbag_dedw_momentum_output_dram;
    unsigned emb_20_embbag_dedw_momentum_output_size = 6183794*32;
    unsigned emb_20_embbag_dedw_momentum_output_size_in_bytes = emb_20_embbag_dedw_momentum_output_size * sizeof(float) ;
    status = hbmAlloc(emb_20_embbag_dedw_momentum_output_size_in_bytes, &emb_20_embbag_dedw_momentum_output_dram, "emb_20_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_20_embbag_dedw_momentum_output dram malloc failed!");
    synLaunchTensorInfo emb_20_embbag_dedw_momentum_output_tr_info = {"emb_20_embbag_dedw_momentum_output",
                                                                      emb_20_embbag_dedw_momentum_output_dram};
    UNUSED(emb_20_embbag_dedw_momentum_output_tr_info); // For single op tests
    synTensor emb_20_embbag_dedw_momentum_output = createTensor(2U, syn_type_single, emb_20_embbag_dedw_momentum_output_sizes, true, "emb_20_embbag_dedw_momentum_output");
    UNUSED(emb_20_embbag_dedw_momentum_output); // For single op tests

    // create emb_20_embbag_dedw_weight_output tensor
    const unsigned emb_20_embbag_dedw_weight_output_sizes[] = {6183794, 32};
    uint64_t emb_20_embbag_dedw_weight_output_dram = emb_20_embbag_weight_dram;
    synLaunchTensorInfo emb_20_embbag_dedw_weight_output_tr_info = {"emb_20_embbag_dedw_weight_output",
                                                                    emb_20_embbag_dedw_weight_output_dram};
    UNUSED(emb_20_embbag_dedw_weight_output_tr_info); // For single op tests
    synTensor emb_20_embbag_dedw_weight_output = createTensor(2U, syn_type_bf16, emb_20_embbag_dedw_weight_output_sizes, true, "emb_20_embbag_dedw_weight_output");
    UNUSED(emb_20_embbag_dedw_weight_output); // For single op tests

    synTensor emb_20_embbag_dedw_EMB_out_vec[3] = {emb_20_embbag_dedw_weight_output_golden, emb_20_embbag_dedw_momentum_output, emb_20_embbag_dedw_weight_output};


    status = synNodeCreate(graphHandle, emb_20_embbag_dedw_EMB_in_vec, emb_20_embbag_dedw_EMB_out_vec, 9, 3, (void *)&emb_20_embbag_dedw_EMB_kernel_params, sizeof(emb_20_embbag_dedw_EMB_kernel_params), "embedding_bag_sgd_bwd_f32", "emb_20_embbag_dedw_EMB", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_20_embbag_dedw_EMB failed!");

    /*************
     * emb_21_embbag_dedw_SLS node
     * inputs: [concat_interact0_grad_input22(128, 32)(dtype=float32), emb_21_embbag_dedw_grad_indices[128](dtype=int32), emb_21_embbag_dedw_lengths[128](dtype=int32), emb_21_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_21_embbag_dedw_grad_inter(128, 32)(dtype=float32)]
     *************/
    ns_SparseLengthsSum::Params emb_21_embbag_dedw_SLS_kernel_params;
    emb_21_embbag_dedw_SLS_kernel_params.mode = EMBEDDED_SC_ZP;

    // create emb_21_embbag_dedw_grad_indices tensor
    const unsigned emb_21_embbag_dedw_grad_indices_sizes[] = {128,};
    uint64_t emb_21_embbag_dedw_grad_indices_dram;
    unsigned emb_21_embbag_dedw_grad_indices_size = 128;
    unsigned emb_21_embbag_dedw_grad_indices_size_in_bytes = emb_21_embbag_dedw_grad_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_21_embbag_dedw_grad_indices_size_in_bytes, &emb_21_embbag_dedw_grad_indices_dram, "emb_21_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_21_embbag_dedw_grad_indices dram malloc failed!");
    synLaunchTensorInfo emb_21_embbag_dedw_grad_indices_tr_info = {"emb_21_embbag_dedw_grad_indices",
                                                                   emb_21_embbag_dedw_grad_indices_dram};
    UNUSED(emb_21_embbag_dedw_grad_indices_tr_info); // For single op tests
    synTensor emb_21_embbag_dedw_grad_indices = createTensor(1U, syn_type_int32, emb_21_embbag_dedw_grad_indices_sizes, true, "emb_21_embbag_dedw_grad_indices");
    UNUSED(emb_21_embbag_dedw_grad_indices); // For single op tests

    // create emb_21_embbag_dedw_lengths tensor
    const unsigned emb_21_embbag_dedw_lengths_sizes[] = {128,};
    uint64_t emb_21_embbag_dedw_lengths_dram;
    unsigned emb_21_embbag_dedw_lengths_size = 128;
    unsigned emb_21_embbag_dedw_lengths_size_in_bytes = emb_21_embbag_dedw_lengths_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_21_embbag_dedw_lengths_size_in_bytes, &emb_21_embbag_dedw_lengths_dram, "emb_21_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_21_embbag_dedw_lengths dram malloc failed!");
    synLaunchTensorInfo emb_21_embbag_dedw_lengths_tr_info = {"emb_21_embbag_dedw_lengths",
                                                              emb_21_embbag_dedw_lengths_dram};
    UNUSED(emb_21_embbag_dedw_lengths_tr_info); // For single op tests
    synTensor emb_21_embbag_dedw_lengths = createTensor(1U, syn_type_int32, emb_21_embbag_dedw_lengths_sizes, true, "emb_21_embbag_dedw_lengths");
    UNUSED(emb_21_embbag_dedw_lengths); // For single op tests

    // create emb_21_embbag_valid_indices tensor
    const unsigned emb_21_embbag_valid_indices_sizes[] = {1,};
    uint64_t emb_21_embbag_valid_indices_dram;
    unsigned emb_21_embbag_valid_indices_size = 1;
    unsigned emb_21_embbag_valid_indices_size_in_bytes = emb_21_embbag_valid_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_21_embbag_valid_indices_size_in_bytes, &emb_21_embbag_valid_indices_dram, "emb_21_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_21_embbag_valid_indices dram malloc failed!");
    synLaunchTensorInfo emb_21_embbag_valid_indices_tr_info = {"emb_21_embbag_valid_indices",
                                                               emb_21_embbag_valid_indices_dram};
    UNUSED(emb_21_embbag_valid_indices_tr_info); // For single op tests
    synTensor emb_21_embbag_valid_indices = createTensor(1U, syn_type_int32, emb_21_embbag_valid_indices_sizes, true, "emb_21_embbag_valid_indices");
    UNUSED(emb_21_embbag_valid_indices); // For single op tests

    synTensor emb_21_embbag_dedw_SLS_in_vec[4] = {concat_interact0_grad_input22, emb_21_embbag_dedw_grad_indices, emb_21_embbag_dedw_lengths, emb_21_embbag_valid_indices};


    // create emb_21_embbag_dedw_grad_inter tensor
    const unsigned emb_21_embbag_dedw_grad_inter_sizes[] = {128, 32};
    synTensor emb_21_embbag_dedw_grad_inter = createTensor(2U, syn_type_single, emb_21_embbag_dedw_grad_inter_sizes, false, "emb_21_embbag_dedw_grad_inter");
    UNUSED(emb_21_embbag_dedw_grad_inter); // For single op tests

    synTensor emb_21_embbag_dedw_SLS_out_vec[1] = {emb_21_embbag_dedw_grad_inter};


    status = synNodeCreate(graphHandle, emb_21_embbag_dedw_SLS_in_vec, emb_21_embbag_dedw_SLS_out_vec, 4, 1, (void *)&emb_21_embbag_dedw_SLS_kernel_params, sizeof(emb_21_embbag_dedw_SLS_kernel_params), "sparse_lengths_sum_fwd_f32", "emb_21_embbag_dedw_SLS", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_21_embbag_dedw_SLS failed!");

    /*************
     * emb_21_embbag_dedw_EMB node
     * inputs: [emb_21_embbag_dedw_grad_inter(128, 32)(dtype=float32), emb_21_embbag_weight_golden[18, 32](dtype=float32), emb_21_embbag_momentum[18, 32](dtype=float32), emb_21_embbag_dedw_param_table_indices[128](dtype=int32), emb_21_offset_shape[128](dtype=int32), emb_0_embbag_timestamp[1](dtype=int32), emb_0_embbag_rate[1](dtype=float32), emb_21_embbag_valid_indices[1](dtype=int32), emb_21_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_21_embbag_dedw_weight_output_golden(18, 32)(dtype=float32), emb_21_embbag_dedw_momentum_output(18, 32)(dtype=float32), emb_21_embbag_dedw_weight_output(18, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_21_embbag_dedw_EMB_kernel_params;
    emb_21_embbag_dedw_EMB_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_21_embbag_dedw_EMB_kernel_params.sgd.wd = 0;
    emb_21_embbag_dedw_EMB_kernel_params.sgd.mom = 1;
    emb_21_embbag_dedw_EMB_kernel_params.sgd.damp = 0;
    emb_21_embbag_dedw_EMB_kernel_params.sgd.nesterov = false;

    // create emb_21_embbag_weight_golden tensor
    const unsigned emb_21_embbag_weight_golden_sizes[] = {18, 32};
    uint64_t emb_21_embbag_weight_golden_dram;
    unsigned emb_21_embbag_weight_golden_size = 18*32;
    unsigned emb_21_embbag_weight_golden_size_in_bytes = emb_21_embbag_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(emb_21_embbag_weight_golden_size_in_bytes, &emb_21_embbag_weight_golden_dram, "emb_21_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_21_embbag_weight_golden dram malloc failed!");
    synLaunchTensorInfo emb_21_embbag_weight_golden_tr_info = {"emb_21_embbag_weight_golden",
                                                               emb_21_embbag_weight_golden_dram};
    UNUSED(emb_21_embbag_weight_golden_tr_info); // For single op tests
    synTensor emb_21_embbag_weight_golden = createTensor(2U, syn_type_single, emb_21_embbag_weight_golden_sizes, true, "emb_21_embbag_weight_golden");
    UNUSED(emb_21_embbag_weight_golden); // For single op tests

    // create emb_21_embbag_momentum tensor
    const unsigned emb_21_embbag_momentum_sizes[] = {18, 32};
    uint64_t emb_21_embbag_momentum_dram;
    unsigned emb_21_embbag_momentum_size = 18*32;
    unsigned emb_21_embbag_momentum_size_in_bytes = emb_21_embbag_momentum_size * sizeof(float) ;
    status = hbmAlloc(emb_21_embbag_momentum_size_in_bytes, &emb_21_embbag_momentum_dram, "emb_21_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_21_embbag_momentum dram malloc failed!");
    synLaunchTensorInfo emb_21_embbag_momentum_tr_info = {"emb_21_embbag_momentum", emb_21_embbag_momentum_dram};
    UNUSED(emb_21_embbag_momentum_tr_info); // For single op tests
    synTensor emb_21_embbag_momentum = createTensor(2U, syn_type_single, emb_21_embbag_momentum_sizes, true, "emb_21_embbag_momentum");
    UNUSED(emb_21_embbag_momentum); // For single op tests

    // create emb_21_embbag_dedw_param_table_indices tensor
    const unsigned emb_21_embbag_dedw_param_table_indices_sizes[] = {128,};
    uint64_t emb_21_embbag_dedw_param_table_indices_dram;
    unsigned emb_21_embbag_dedw_param_table_indices_size = 128;
    unsigned emb_21_embbag_dedw_param_table_indices_size_in_bytes = emb_21_embbag_dedw_param_table_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_21_embbag_dedw_param_table_indices_size_in_bytes, &emb_21_embbag_dedw_param_table_indices_dram, "emb_21_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_21_embbag_dedw_param_table_indices dram malloc failed!");
    synLaunchTensorInfo emb_21_embbag_dedw_param_table_indices_tr_info = {"emb_21_embbag_dedw_param_table_indices",
                                                                          emb_21_embbag_dedw_param_table_indices_dram};
    UNUSED(emb_21_embbag_dedw_param_table_indices_tr_info); // For single op tests
    synTensor emb_21_embbag_dedw_param_table_indices = createTensor(1U, syn_type_int32, emb_21_embbag_dedw_param_table_indices_sizes, true, "emb_21_embbag_dedw_param_table_indices");
    UNUSED(emb_21_embbag_dedw_param_table_indices); // For single op tests

    // create emb_21_offset_shape tensor
    const unsigned emb_21_offset_shape_sizes[] = {128,};
    uint64_t emb_21_offset_shape_dram;
    unsigned emb_21_offset_shape_size = 128;
    unsigned emb_21_offset_shape_size_in_bytes = emb_21_offset_shape_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_21_offset_shape_size_in_bytes, &emb_21_offset_shape_dram, "emb_21_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_21_offset_shape dram malloc failed!");
    synLaunchTensorInfo emb_21_offset_shape_tr_info = {"emb_21_offset_shape", emb_21_offset_shape_dram};
    UNUSED(emb_21_offset_shape_tr_info); // For single op tests
    synTensor emb_21_offset_shape = createTensor(1U, syn_type_int32, emb_21_offset_shape_sizes, true, "emb_21_offset_shape");
    UNUSED(emb_21_offset_shape); // For single op tests

    synTensor emb_21_embbag_dedw_EMB_in_vec[9] = {emb_21_embbag_dedw_grad_inter, emb_21_embbag_weight_golden, emb_21_embbag_momentum, emb_21_embbag_dedw_param_table_indices, emb_21_offset_shape, emb_0_embbag_timestamp, emb_0_embbag_rate, emb_21_embbag_valid_indices, emb_21_embbag_valid_indices};


    // create emb_21_embbag_dedw_weight_output_golden tensor
    const unsigned emb_21_embbag_dedw_weight_output_golden_sizes[] = {18, 32};
    uint64_t emb_21_embbag_dedw_weight_output_golden_dram = emb_21_embbag_weight_golden_dram;
    synLaunchTensorInfo emb_21_embbag_dedw_weight_output_golden_tr_info = {
        "emb_21_embbag_dedw_weight_output_golden",
        emb_21_embbag_dedw_weight_output_golden_dram};
    UNUSED(emb_21_embbag_dedw_weight_output_golden_tr_info); // For single op tests
    synTensor emb_21_embbag_dedw_weight_output_golden = createTensor(2U, syn_type_single, emb_21_embbag_dedw_weight_output_golden_sizes, true, "emb_21_embbag_dedw_weight_output_golden");
    UNUSED(emb_21_embbag_dedw_weight_output_golden); // For single op tests

    // create emb_21_embbag_dedw_momentum_output tensor
    const unsigned emb_21_embbag_dedw_momentum_output_sizes[] = {18, 32};
    uint64_t emb_21_embbag_dedw_momentum_output_dram;
    unsigned emb_21_embbag_dedw_momentum_output_size = 18*32;
    unsigned emb_21_embbag_dedw_momentum_output_size_in_bytes = emb_21_embbag_dedw_momentum_output_size * sizeof(float) ;
    status = hbmAlloc(emb_21_embbag_dedw_momentum_output_size_in_bytes, &emb_21_embbag_dedw_momentum_output_dram, "emb_21_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_21_embbag_dedw_momentum_output dram malloc failed!");
    synLaunchTensorInfo emb_21_embbag_dedw_momentum_output_tr_info = {"emb_21_embbag_dedw_momentum_output",
                                                                      emb_21_embbag_dedw_momentum_output_dram};
    UNUSED(emb_21_embbag_dedw_momentum_output_tr_info); // For single op tests
    synTensor emb_21_embbag_dedw_momentum_output = createTensor(2U, syn_type_single, emb_21_embbag_dedw_momentum_output_sizes, true, "emb_21_embbag_dedw_momentum_output");
    UNUSED(emb_21_embbag_dedw_momentum_output); // For single op tests

    // create emb_21_embbag_dedw_weight_output tensor
    const unsigned emb_21_embbag_dedw_weight_output_sizes[] = {18, 32};
    uint64_t emb_21_embbag_dedw_weight_output_dram = emb_21_embbag_weight_dram;
    synLaunchTensorInfo emb_21_embbag_dedw_weight_output_tr_info = {"emb_21_embbag_dedw_weight_output",
                                                                    emb_21_embbag_dedw_weight_output_dram};
    UNUSED(emb_21_embbag_dedw_weight_output_tr_info); // For single op tests
    synTensor emb_21_embbag_dedw_weight_output = createTensor(2U, syn_type_bf16, emb_21_embbag_dedw_weight_output_sizes, true, "emb_21_embbag_dedw_weight_output");
    UNUSED(emb_21_embbag_dedw_weight_output); // For single op tests

    synTensor emb_21_embbag_dedw_EMB_out_vec[3] = {emb_21_embbag_dedw_weight_output_golden, emb_21_embbag_dedw_momentum_output, emb_21_embbag_dedw_weight_output};


    status = synNodeCreate(graphHandle, emb_21_embbag_dedw_EMB_in_vec, emb_21_embbag_dedw_EMB_out_vec, 9, 3, (void *)&emb_21_embbag_dedw_EMB_kernel_params, sizeof(emb_21_embbag_dedw_EMB_kernel_params), "embedding_bag_sgd_bwd_f32", "emb_21_embbag_dedw_EMB", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_21_embbag_dedw_EMB failed!");

    /*************
     * emb_22_embbag_dedw_SLS node
     * inputs: [concat_interact0_grad_input23(128, 32)(dtype=float32), emb_22_embbag_dedw_grad_indices[128](dtype=int32), emb_22_embbag_dedw_lengths[128](dtype=int32), emb_22_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_22_embbag_dedw_grad_inter(128, 32)(dtype=float32)]
     *************/
    ns_SparseLengthsSum::Params emb_22_embbag_dedw_SLS_kernel_params;
    emb_22_embbag_dedw_SLS_kernel_params.mode = EMBEDDED_SC_ZP;

    // create emb_22_embbag_dedw_grad_indices tensor
    const unsigned emb_22_embbag_dedw_grad_indices_sizes[] = {128,};
    uint64_t emb_22_embbag_dedw_grad_indices_dram;
    unsigned emb_22_embbag_dedw_grad_indices_size = 128;
    unsigned emb_22_embbag_dedw_grad_indices_size_in_bytes = emb_22_embbag_dedw_grad_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_22_embbag_dedw_grad_indices_size_in_bytes, &emb_22_embbag_dedw_grad_indices_dram, "emb_22_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_22_embbag_dedw_grad_indices dram malloc failed!");
    synLaunchTensorInfo emb_22_embbag_dedw_grad_indices_tr_info = {"emb_22_embbag_dedw_grad_indices",
                                                                   emb_22_embbag_dedw_grad_indices_dram};
    UNUSED(emb_22_embbag_dedw_grad_indices_tr_info); // For single op tests
    synTensor emb_22_embbag_dedw_grad_indices = createTensor(1U, syn_type_int32, emb_22_embbag_dedw_grad_indices_sizes, true, "emb_22_embbag_dedw_grad_indices");
    UNUSED(emb_22_embbag_dedw_grad_indices); // For single op tests

    // create emb_22_embbag_dedw_lengths tensor
    const unsigned emb_22_embbag_dedw_lengths_sizes[] = {128,};
    uint64_t emb_22_embbag_dedw_lengths_dram;
    unsigned emb_22_embbag_dedw_lengths_size = 128;
    unsigned emb_22_embbag_dedw_lengths_size_in_bytes = emb_22_embbag_dedw_lengths_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_22_embbag_dedw_lengths_size_in_bytes, &emb_22_embbag_dedw_lengths_dram, "emb_22_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_22_embbag_dedw_lengths dram malloc failed!");
    synLaunchTensorInfo emb_22_embbag_dedw_lengths_tr_info = {"emb_22_embbag_dedw_lengths",
                                                              emb_22_embbag_dedw_lengths_dram};
    UNUSED(emb_22_embbag_dedw_lengths_tr_info); // For single op tests
    synTensor emb_22_embbag_dedw_lengths = createTensor(1U, syn_type_int32, emb_22_embbag_dedw_lengths_sizes, true, "emb_22_embbag_dedw_lengths");
    UNUSED(emb_22_embbag_dedw_lengths); // For single op tests

    // create emb_22_embbag_valid_indices tensor
    const unsigned emb_22_embbag_valid_indices_sizes[] = {1,};
    uint64_t emb_22_embbag_valid_indices_dram;
    unsigned emb_22_embbag_valid_indices_size = 1;
    unsigned emb_22_embbag_valid_indices_size_in_bytes = emb_22_embbag_valid_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_22_embbag_valid_indices_size_in_bytes, &emb_22_embbag_valid_indices_dram, "emb_22_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_22_embbag_valid_indices dram malloc failed!");
    synLaunchTensorInfo emb_22_embbag_valid_indices_tr_info = {"emb_22_embbag_valid_indices",
                                                               emb_22_embbag_valid_indices_dram};
    UNUSED(emb_22_embbag_valid_indices_tr_info); // For single op tests
    synTensor emb_22_embbag_valid_indices = createTensor(1U, syn_type_int32, emb_22_embbag_valid_indices_sizes, true, "emb_22_embbag_valid_indices");
    UNUSED(emb_22_embbag_valid_indices); // For single op tests

    synTensor emb_22_embbag_dedw_SLS_in_vec[4] = {concat_interact0_grad_input23, emb_22_embbag_dedw_grad_indices, emb_22_embbag_dedw_lengths, emb_22_embbag_valid_indices};


    // create emb_22_embbag_dedw_grad_inter tensor
    const unsigned emb_22_embbag_dedw_grad_inter_sizes[] = {128, 32};
    synTensor emb_22_embbag_dedw_grad_inter = createTensor(2U, syn_type_single, emb_22_embbag_dedw_grad_inter_sizes, false, "emb_22_embbag_dedw_grad_inter");
    UNUSED(emb_22_embbag_dedw_grad_inter); // For single op tests

    synTensor emb_22_embbag_dedw_SLS_out_vec[1] = {emb_22_embbag_dedw_grad_inter};


    status = synNodeCreate(graphHandle, emb_22_embbag_dedw_SLS_in_vec, emb_22_embbag_dedw_SLS_out_vec, 4, 1, (void *)&emb_22_embbag_dedw_SLS_kernel_params, sizeof(emb_22_embbag_dedw_SLS_kernel_params), "sparse_lengths_sum_fwd_f32", "emb_22_embbag_dedw_SLS", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_22_embbag_dedw_SLS failed!");

    /*************
     * emb_22_embbag_dedw_EMB node
     * inputs: [emb_22_embbag_dedw_grad_inter(128, 32)(dtype=float32), emb_22_embbag_weight_golden[15, 32](dtype=float32), emb_22_embbag_momentum[15, 32](dtype=float32), emb_22_embbag_dedw_param_table_indices[128](dtype=int32), emb_22_offset_shape[128](dtype=int32), emb_0_embbag_timestamp[1](dtype=int32), emb_0_embbag_rate[1](dtype=float32), emb_22_embbag_valid_indices[1](dtype=int32), emb_22_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_22_embbag_dedw_weight_output_golden(15, 32)(dtype=float32), emb_22_embbag_dedw_momentum_output(15, 32)(dtype=float32), emb_22_embbag_dedw_weight_output(15, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_22_embbag_dedw_EMB_kernel_params;
    emb_22_embbag_dedw_EMB_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_22_embbag_dedw_EMB_kernel_params.sgd.wd = 0;
    emb_22_embbag_dedw_EMB_kernel_params.sgd.mom = 1;
    emb_22_embbag_dedw_EMB_kernel_params.sgd.damp = 0;
    emb_22_embbag_dedw_EMB_kernel_params.sgd.nesterov = false;

    // create emb_22_embbag_weight_golden tensor
    const unsigned emb_22_embbag_weight_golden_sizes[] = {15, 32};
    uint64_t emb_22_embbag_weight_golden_dram;
    unsigned emb_22_embbag_weight_golden_size = 15*32;
    unsigned emb_22_embbag_weight_golden_size_in_bytes = emb_22_embbag_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(emb_22_embbag_weight_golden_size_in_bytes, &emb_22_embbag_weight_golden_dram, "emb_22_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_22_embbag_weight_golden dram malloc failed!");
    synLaunchTensorInfo emb_22_embbag_weight_golden_tr_info = {"emb_22_embbag_weight_golden",
                                                               emb_22_embbag_weight_golden_dram};
    UNUSED(emb_22_embbag_weight_golden_tr_info); // For single op tests
    synTensor emb_22_embbag_weight_golden = createTensor(2U, syn_type_single, emb_22_embbag_weight_golden_sizes, true, "emb_22_embbag_weight_golden");
    UNUSED(emb_22_embbag_weight_golden); // For single op tests

    // create emb_22_embbag_momentum tensor
    const unsigned emb_22_embbag_momentum_sizes[] = {15, 32};
    uint64_t emb_22_embbag_momentum_dram;
    unsigned emb_22_embbag_momentum_size = 15*32;
    unsigned emb_22_embbag_momentum_size_in_bytes = emb_22_embbag_momentum_size * sizeof(float) ;
    status = hbmAlloc(emb_22_embbag_momentum_size_in_bytes, &emb_22_embbag_momentum_dram, "emb_22_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_22_embbag_momentum dram malloc failed!");
    synLaunchTensorInfo emb_22_embbag_momentum_tr_info = {"emb_22_embbag_momentum", emb_22_embbag_momentum_dram};
    UNUSED(emb_22_embbag_momentum_tr_info); // For single op tests
    synTensor emb_22_embbag_momentum = createTensor(2U, syn_type_single, emb_22_embbag_momentum_sizes, true, "emb_22_embbag_momentum");
    UNUSED(emb_22_embbag_momentum); // For single op tests

    // create emb_22_embbag_dedw_param_table_indices tensor
    const unsigned emb_22_embbag_dedw_param_table_indices_sizes[] = {128,};
    uint64_t emb_22_embbag_dedw_param_table_indices_dram;
    unsigned emb_22_embbag_dedw_param_table_indices_size = 128;
    unsigned emb_22_embbag_dedw_param_table_indices_size_in_bytes = emb_22_embbag_dedw_param_table_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_22_embbag_dedw_param_table_indices_size_in_bytes, &emb_22_embbag_dedw_param_table_indices_dram, "emb_22_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_22_embbag_dedw_param_table_indices dram malloc failed!");
    synLaunchTensorInfo emb_22_embbag_dedw_param_table_indices_tr_info = {"emb_22_embbag_dedw_param_table_indices",
                                                                          emb_22_embbag_dedw_param_table_indices_dram};
    UNUSED(emb_22_embbag_dedw_param_table_indices_tr_info); // For single op tests
    synTensor emb_22_embbag_dedw_param_table_indices = createTensor(1U, syn_type_int32, emb_22_embbag_dedw_param_table_indices_sizes, true, "emb_22_embbag_dedw_param_table_indices");
    UNUSED(emb_22_embbag_dedw_param_table_indices); // For single op tests

    // create emb_22_offset_shape tensor
    const unsigned emb_22_offset_shape_sizes[] = {128,};
    uint64_t emb_22_offset_shape_dram;
    unsigned emb_22_offset_shape_size = 128;
    unsigned emb_22_offset_shape_size_in_bytes = emb_22_offset_shape_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_22_offset_shape_size_in_bytes, &emb_22_offset_shape_dram, "emb_22_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_22_offset_shape dram malloc failed!");
    synLaunchTensorInfo emb_22_offset_shape_tr_info = {"emb_22_offset_shape", emb_22_offset_shape_dram};
    UNUSED(emb_22_offset_shape_tr_info); // For single op tests
    synTensor emb_22_offset_shape = createTensor(1U, syn_type_int32, emb_22_offset_shape_sizes, true, "emb_22_offset_shape");
    UNUSED(emb_22_offset_shape); // For single op tests

    synTensor emb_22_embbag_dedw_EMB_in_vec[9] = {emb_22_embbag_dedw_grad_inter, emb_22_embbag_weight_golden, emb_22_embbag_momentum, emb_22_embbag_dedw_param_table_indices, emb_22_offset_shape, emb_0_embbag_timestamp, emb_0_embbag_rate, emb_22_embbag_valid_indices, emb_22_embbag_valid_indices};


    // create emb_22_embbag_dedw_weight_output_golden tensor
    const unsigned emb_22_embbag_dedw_weight_output_golden_sizes[] = {15, 32};
    uint64_t emb_22_embbag_dedw_weight_output_golden_dram = emb_22_embbag_weight_golden_dram;
    synLaunchTensorInfo emb_22_embbag_dedw_weight_output_golden_tr_info = {
        "emb_22_embbag_dedw_weight_output_golden",
        emb_22_embbag_dedw_weight_output_golden_dram};
    UNUSED(emb_22_embbag_dedw_weight_output_golden_tr_info); // For single op tests
    synTensor emb_22_embbag_dedw_weight_output_golden = createTensor(2U, syn_type_single, emb_22_embbag_dedw_weight_output_golden_sizes, true, "emb_22_embbag_dedw_weight_output_golden");
    UNUSED(emb_22_embbag_dedw_weight_output_golden); // For single op tests

    // create emb_22_embbag_dedw_momentum_output tensor
    const unsigned emb_22_embbag_dedw_momentum_output_sizes[] = {15, 32};
    uint64_t emb_22_embbag_dedw_momentum_output_dram;
    unsigned emb_22_embbag_dedw_momentum_output_size = 15*32;
    unsigned emb_22_embbag_dedw_momentum_output_size_in_bytes = emb_22_embbag_dedw_momentum_output_size * sizeof(float) ;
    status = hbmAlloc(emb_22_embbag_dedw_momentum_output_size_in_bytes, &emb_22_embbag_dedw_momentum_output_dram, "emb_22_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_22_embbag_dedw_momentum_output dram malloc failed!");
    synLaunchTensorInfo emb_22_embbag_dedw_momentum_output_tr_info = {"emb_22_embbag_dedw_momentum_output",
                                                                      emb_22_embbag_dedw_momentum_output_dram};
    UNUSED(emb_22_embbag_dedw_momentum_output_tr_info); // For single op tests
    synTensor emb_22_embbag_dedw_momentum_output = createTensor(2U, syn_type_single, emb_22_embbag_dedw_momentum_output_sizes, true, "emb_22_embbag_dedw_momentum_output");
    UNUSED(emb_22_embbag_dedw_momentum_output); // For single op tests

    // create emb_22_embbag_dedw_weight_output tensor
    const unsigned emb_22_embbag_dedw_weight_output_sizes[] = {15, 32};
    uint64_t emb_22_embbag_dedw_weight_output_dram = emb_22_embbag_weight_dram;
    synLaunchTensorInfo emb_22_embbag_dedw_weight_output_tr_info = {"emb_22_embbag_dedw_weight_output",
                                                                    emb_22_embbag_dedw_weight_output_dram};
    UNUSED(emb_22_embbag_dedw_weight_output_tr_info); // For single op tests
    synTensor emb_22_embbag_dedw_weight_output = createTensor(2U, syn_type_bf16, emb_22_embbag_dedw_weight_output_sizes, true, "emb_22_embbag_dedw_weight_output");
    UNUSED(emb_22_embbag_dedw_weight_output); // For single op tests

    synTensor emb_22_embbag_dedw_EMB_out_vec[3] = {emb_22_embbag_dedw_weight_output_golden, emb_22_embbag_dedw_momentum_output, emb_22_embbag_dedw_weight_output};


    status = synNodeCreate(graphHandle, emb_22_embbag_dedw_EMB_in_vec, emb_22_embbag_dedw_EMB_out_vec, 9, 3, (void *)&emb_22_embbag_dedw_EMB_kernel_params, sizeof(emb_22_embbag_dedw_EMB_kernel_params), "embedding_bag_sgd_bwd_f32", "emb_22_embbag_dedw_EMB", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_22_embbag_dedw_EMB failed!");

    /*************
     * emb_23_embbag_dedw_SLS node
     * inputs: [concat_interact0_grad_input24(128, 32)(dtype=float32), emb_23_embbag_dedw_grad_indices[128](dtype=int32), emb_23_embbag_dedw_lengths[128](dtype=int32), emb_23_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_23_embbag_dedw_grad_inter(128, 32)(dtype=float32)]
     *************/
    ns_SparseLengthsSum::Params emb_23_embbag_dedw_SLS_kernel_params;
    emb_23_embbag_dedw_SLS_kernel_params.mode = EMBEDDED_SC_ZP;

    // create emb_23_embbag_dedw_grad_indices tensor
    const unsigned emb_23_embbag_dedw_grad_indices_sizes[] = {128,};
    uint64_t emb_23_embbag_dedw_grad_indices_dram;
    unsigned emb_23_embbag_dedw_grad_indices_size = 128;
    unsigned emb_23_embbag_dedw_grad_indices_size_in_bytes = emb_23_embbag_dedw_grad_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_23_embbag_dedw_grad_indices_size_in_bytes, &emb_23_embbag_dedw_grad_indices_dram, "emb_23_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_23_embbag_dedw_grad_indices dram malloc failed!");
    synLaunchTensorInfo emb_23_embbag_dedw_grad_indices_tr_info = {"emb_23_embbag_dedw_grad_indices",
                                                                   emb_23_embbag_dedw_grad_indices_dram};
    UNUSED(emb_23_embbag_dedw_grad_indices_tr_info); // For single op tests
    synTensor emb_23_embbag_dedw_grad_indices = createTensor(1U, syn_type_int32, emb_23_embbag_dedw_grad_indices_sizes, true, "emb_23_embbag_dedw_grad_indices");
    UNUSED(emb_23_embbag_dedw_grad_indices); // For single op tests

    // create emb_23_embbag_dedw_lengths tensor
    const unsigned emb_23_embbag_dedw_lengths_sizes[] = {128,};
    uint64_t emb_23_embbag_dedw_lengths_dram;
    unsigned emb_23_embbag_dedw_lengths_size = 128;
    unsigned emb_23_embbag_dedw_lengths_size_in_bytes = emb_23_embbag_dedw_lengths_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_23_embbag_dedw_lengths_size_in_bytes, &emb_23_embbag_dedw_lengths_dram, "emb_23_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_23_embbag_dedw_lengths dram malloc failed!");
    synLaunchTensorInfo emb_23_embbag_dedw_lengths_tr_info = {"emb_23_embbag_dedw_lengths",
                                                              emb_23_embbag_dedw_lengths_dram};
    UNUSED(emb_23_embbag_dedw_lengths_tr_info); // For single op tests
    synTensor emb_23_embbag_dedw_lengths = createTensor(1U, syn_type_int32, emb_23_embbag_dedw_lengths_sizes, true, "emb_23_embbag_dedw_lengths");
    UNUSED(emb_23_embbag_dedw_lengths); // For single op tests

    // create emb_23_embbag_valid_indices tensor
    const unsigned emb_23_embbag_valid_indices_sizes[] = {1,};
    uint64_t emb_23_embbag_valid_indices_dram;
    unsigned emb_23_embbag_valid_indices_size = 1;
    unsigned emb_23_embbag_valid_indices_size_in_bytes = emb_23_embbag_valid_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_23_embbag_valid_indices_size_in_bytes, &emb_23_embbag_valid_indices_dram, "emb_23_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_23_embbag_valid_indices dram malloc failed!");
    synLaunchTensorInfo emb_23_embbag_valid_indices_tr_info = {"emb_23_embbag_valid_indices",
                                                               emb_23_embbag_valid_indices_dram};
    UNUSED(emb_23_embbag_valid_indices_tr_info); // For single op tests
    synTensor emb_23_embbag_valid_indices = createTensor(1U, syn_type_int32, emb_23_embbag_valid_indices_sizes, true, "emb_23_embbag_valid_indices");
    UNUSED(emb_23_embbag_valid_indices); // For single op tests

    synTensor emb_23_embbag_dedw_SLS_in_vec[4] = {concat_interact0_grad_input24, emb_23_embbag_dedw_grad_indices, emb_23_embbag_dedw_lengths, emb_23_embbag_valid_indices};


    // create emb_23_embbag_dedw_grad_inter tensor
    const unsigned emb_23_embbag_dedw_grad_inter_sizes[] = {128, 32};
    synTensor emb_23_embbag_dedw_grad_inter = createTensor(2U, syn_type_single, emb_23_embbag_dedw_grad_inter_sizes, false, "emb_23_embbag_dedw_grad_inter");
    UNUSED(emb_23_embbag_dedw_grad_inter); // For single op tests

    synTensor emb_23_embbag_dedw_SLS_out_vec[1] = {emb_23_embbag_dedw_grad_inter};


    status = synNodeCreate(graphHandle, emb_23_embbag_dedw_SLS_in_vec, emb_23_embbag_dedw_SLS_out_vec, 4, 1, (void *)&emb_23_embbag_dedw_SLS_kernel_params, sizeof(emb_23_embbag_dedw_SLS_kernel_params), "sparse_lengths_sum_fwd_f32", "emb_23_embbag_dedw_SLS", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_23_embbag_dedw_SLS failed!");

    /*************
     * emb_23_embbag_dedw_EMB node
     * inputs: [emb_23_embbag_dedw_grad_inter(128, 32)(dtype=float32), emb_23_embbag_weight_golden[266403, 32](dtype=float32), emb_23_embbag_momentum[266403, 32](dtype=float32), emb_23_embbag_dedw_param_table_indices[128](dtype=int32), emb_23_offset_shape[128](dtype=int32), emb_0_embbag_timestamp[1](dtype=int32), emb_0_embbag_rate[1](dtype=float32), emb_23_embbag_valid_indices[1](dtype=int32), emb_23_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_23_embbag_dedw_weight_output_golden(266403, 32)(dtype=float32), emb_23_embbag_dedw_momentum_output(266403, 32)(dtype=float32), emb_23_embbag_dedw_weight_output(266403, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_23_embbag_dedw_EMB_kernel_params;
    emb_23_embbag_dedw_EMB_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_23_embbag_dedw_EMB_kernel_params.sgd.wd = 0;
    emb_23_embbag_dedw_EMB_kernel_params.sgd.mom = 1;
    emb_23_embbag_dedw_EMB_kernel_params.sgd.damp = 0;
    emb_23_embbag_dedw_EMB_kernel_params.sgd.nesterov = false;

    // create emb_23_embbag_weight_golden tensor
    const unsigned emb_23_embbag_weight_golden_sizes[] = {266403, 32};
    uint64_t emb_23_embbag_weight_golden_dram;
    unsigned emb_23_embbag_weight_golden_size = 266403*32;
    unsigned emb_23_embbag_weight_golden_size_in_bytes = emb_23_embbag_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(emb_23_embbag_weight_golden_size_in_bytes, &emb_23_embbag_weight_golden_dram, "emb_23_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_23_embbag_weight_golden dram malloc failed!");
    synLaunchTensorInfo emb_23_embbag_weight_golden_tr_info = {"emb_23_embbag_weight_golden",
                                                               emb_23_embbag_weight_golden_dram};
    UNUSED(emb_23_embbag_weight_golden_tr_info); // For single op tests
    synTensor emb_23_embbag_weight_golden = createTensor(2U, syn_type_single, emb_23_embbag_weight_golden_sizes, true, "emb_23_embbag_weight_golden");
    UNUSED(emb_23_embbag_weight_golden); // For single op tests

    // create emb_23_embbag_momentum tensor
    const unsigned emb_23_embbag_momentum_sizes[] = {266403, 32};
    uint64_t emb_23_embbag_momentum_dram;
    unsigned emb_23_embbag_momentum_size = 266403*32;
    unsigned emb_23_embbag_momentum_size_in_bytes = emb_23_embbag_momentum_size * sizeof(float) ;
    status = hbmAlloc(emb_23_embbag_momentum_size_in_bytes, &emb_23_embbag_momentum_dram, "emb_23_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_23_embbag_momentum dram malloc failed!");
    synLaunchTensorInfo emb_23_embbag_momentum_tr_info = {"emb_23_embbag_momentum", emb_23_embbag_momentum_dram};
    UNUSED(emb_23_embbag_momentum_tr_info); // For single op tests
    synTensor emb_23_embbag_momentum = createTensor(2U, syn_type_single, emb_23_embbag_momentum_sizes, true, "emb_23_embbag_momentum");
    UNUSED(emb_23_embbag_momentum); // For single op tests

    // create emb_23_embbag_dedw_param_table_indices tensor
    const unsigned emb_23_embbag_dedw_param_table_indices_sizes[] = {128,};
    uint64_t emb_23_embbag_dedw_param_table_indices_dram;
    unsigned emb_23_embbag_dedw_param_table_indices_size = 128;
    unsigned emb_23_embbag_dedw_param_table_indices_size_in_bytes = emb_23_embbag_dedw_param_table_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_23_embbag_dedw_param_table_indices_size_in_bytes, &emb_23_embbag_dedw_param_table_indices_dram, "emb_23_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_23_embbag_dedw_param_table_indices dram malloc failed!");
    synLaunchTensorInfo emb_23_embbag_dedw_param_table_indices_tr_info = {"emb_23_embbag_dedw_param_table_indices",
                                                                          emb_23_embbag_dedw_param_table_indices_dram};
    UNUSED(emb_23_embbag_dedw_param_table_indices_tr_info); // For single op tests
    synTensor emb_23_embbag_dedw_param_table_indices = createTensor(1U, syn_type_int32, emb_23_embbag_dedw_param_table_indices_sizes, true, "emb_23_embbag_dedw_param_table_indices");
    UNUSED(emb_23_embbag_dedw_param_table_indices); // For single op tests

    // create emb_23_offset_shape tensor
    const unsigned emb_23_offset_shape_sizes[] = {128,};
    uint64_t emb_23_offset_shape_dram;
    unsigned emb_23_offset_shape_size = 128;
    unsigned emb_23_offset_shape_size_in_bytes = emb_23_offset_shape_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_23_offset_shape_size_in_bytes, &emb_23_offset_shape_dram, "emb_23_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_23_offset_shape dram malloc failed!");
    synLaunchTensorInfo emb_23_offset_shape_tr_info = {"emb_23_offset_shape", emb_23_offset_shape_dram};
    UNUSED(emb_23_offset_shape_tr_info); // For single op tests
    synTensor emb_23_offset_shape = createTensor(1U, syn_type_int32, emb_23_offset_shape_sizes, true, "emb_23_offset_shape");
    UNUSED(emb_23_offset_shape); // For single op tests

    synTensor emb_23_embbag_dedw_EMB_in_vec[9] = {emb_23_embbag_dedw_grad_inter, emb_23_embbag_weight_golden, emb_23_embbag_momentum, emb_23_embbag_dedw_param_table_indices, emb_23_offset_shape, emb_0_embbag_timestamp, emb_0_embbag_rate, emb_23_embbag_valid_indices, emb_23_embbag_valid_indices};


    // create emb_23_embbag_dedw_weight_output_golden tensor
    const unsigned emb_23_embbag_dedw_weight_output_golden_sizes[] = {266403, 32};
    uint64_t emb_23_embbag_dedw_weight_output_golden_dram = emb_23_embbag_weight_golden_dram;
    synLaunchTensorInfo emb_23_embbag_dedw_weight_output_golden_tr_info = {
        "emb_23_embbag_dedw_weight_output_golden",
        emb_23_embbag_dedw_weight_output_golden_dram};
    UNUSED(emb_23_embbag_dedw_weight_output_golden_tr_info); // For single op tests
    synTensor emb_23_embbag_dedw_weight_output_golden = createTensor(2U, syn_type_single, emb_23_embbag_dedw_weight_output_golden_sizes, true, "emb_23_embbag_dedw_weight_output_golden");
    UNUSED(emb_23_embbag_dedw_weight_output_golden); // For single op tests

    // create emb_23_embbag_dedw_momentum_output tensor
    const unsigned emb_23_embbag_dedw_momentum_output_sizes[] = {266403, 32};
    uint64_t emb_23_embbag_dedw_momentum_output_dram;
    unsigned emb_23_embbag_dedw_momentum_output_size = 266403*32;
    unsigned emb_23_embbag_dedw_momentum_output_size_in_bytes = emb_23_embbag_dedw_momentum_output_size * sizeof(float) ;
    status = hbmAlloc(emb_23_embbag_dedw_momentum_output_size_in_bytes, &emb_23_embbag_dedw_momentum_output_dram, "emb_23_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_23_embbag_dedw_momentum_output dram malloc failed!");
    synLaunchTensorInfo emb_23_embbag_dedw_momentum_output_tr_info = {"emb_23_embbag_dedw_momentum_output",
                                                                      emb_23_embbag_dedw_momentum_output_dram};
    UNUSED(emb_23_embbag_dedw_momentum_output_tr_info); // For single op tests
    synTensor emb_23_embbag_dedw_momentum_output = createTensor(2U, syn_type_single, emb_23_embbag_dedw_momentum_output_sizes, true, "emb_23_embbag_dedw_momentum_output");
    UNUSED(emb_23_embbag_dedw_momentum_output); // For single op tests

    // create emb_23_embbag_dedw_weight_output tensor
    const unsigned emb_23_embbag_dedw_weight_output_sizes[] = {266403, 32};
    uint64_t emb_23_embbag_dedw_weight_output_dram = emb_23_embbag_weight_dram;
    synLaunchTensorInfo emb_23_embbag_dedw_weight_output_tr_info = {"emb_23_embbag_dedw_weight_output",
                                                                    emb_23_embbag_dedw_weight_output_dram};
    UNUSED(emb_23_embbag_dedw_weight_output_tr_info); // For single op tests
    synTensor emb_23_embbag_dedw_weight_output = createTensor(2U, syn_type_bf16, emb_23_embbag_dedw_weight_output_sizes, true, "emb_23_embbag_dedw_weight_output");
    UNUSED(emb_23_embbag_dedw_weight_output); // For single op tests

    synTensor emb_23_embbag_dedw_EMB_out_vec[3] = {emb_23_embbag_dedw_weight_output_golden, emb_23_embbag_dedw_momentum_output, emb_23_embbag_dedw_weight_output};


    status = synNodeCreate(graphHandle, emb_23_embbag_dedw_EMB_in_vec, emb_23_embbag_dedw_EMB_out_vec, 9, 3, (void *)&emb_23_embbag_dedw_EMB_kernel_params, sizeof(emb_23_embbag_dedw_EMB_kernel_params), "embedding_bag_sgd_bwd_f32", "emb_23_embbag_dedw_EMB", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_23_embbag_dedw_EMB failed!");

    /*************
     * emb_24_embbag_dedw_SLS node
     * inputs: [concat_interact0_grad_input25(128, 32)(dtype=float32), emb_24_embbag_dedw_grad_indices[128](dtype=int32), emb_24_embbag_dedw_lengths[128](dtype=int32), emb_24_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_24_embbag_dedw_grad_inter(128, 32)(dtype=float32)]
     *************/
    ns_SparseLengthsSum::Params emb_24_embbag_dedw_SLS_kernel_params;
    emb_24_embbag_dedw_SLS_kernel_params.mode = EMBEDDED_SC_ZP;

    // create emb_24_embbag_dedw_grad_indices tensor
    const unsigned emb_24_embbag_dedw_grad_indices_sizes[] = {128,};
    uint64_t emb_24_embbag_dedw_grad_indices_dram;
    unsigned emb_24_embbag_dedw_grad_indices_size = 128;
    unsigned emb_24_embbag_dedw_grad_indices_size_in_bytes = emb_24_embbag_dedw_grad_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_24_embbag_dedw_grad_indices_size_in_bytes, &emb_24_embbag_dedw_grad_indices_dram, "emb_24_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_24_embbag_dedw_grad_indices dram malloc failed!");
    synLaunchTensorInfo emb_24_embbag_dedw_grad_indices_tr_info = {"emb_24_embbag_dedw_grad_indices",
                                                                   emb_24_embbag_dedw_grad_indices_dram};
    UNUSED(emb_24_embbag_dedw_grad_indices_tr_info); // For single op tests
    synTensor emb_24_embbag_dedw_grad_indices = createTensor(1U, syn_type_int32, emb_24_embbag_dedw_grad_indices_sizes, true, "emb_24_embbag_dedw_grad_indices");
    UNUSED(emb_24_embbag_dedw_grad_indices); // For single op tests

    // create emb_24_embbag_dedw_lengths tensor
    const unsigned emb_24_embbag_dedw_lengths_sizes[] = {128,};
    uint64_t emb_24_embbag_dedw_lengths_dram;
    unsigned emb_24_embbag_dedw_lengths_size = 128;
    unsigned emb_24_embbag_dedw_lengths_size_in_bytes = emb_24_embbag_dedw_lengths_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_24_embbag_dedw_lengths_size_in_bytes, &emb_24_embbag_dedw_lengths_dram, "emb_24_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_24_embbag_dedw_lengths dram malloc failed!");
    synLaunchTensorInfo emb_24_embbag_dedw_lengths_tr_info = {"emb_24_embbag_dedw_lengths",
                                                              emb_24_embbag_dedw_lengths_dram};
    UNUSED(emb_24_embbag_dedw_lengths_tr_info); // For single op tests
    synTensor emb_24_embbag_dedw_lengths = createTensor(1U, syn_type_int32, emb_24_embbag_dedw_lengths_sizes, true, "emb_24_embbag_dedw_lengths");
    UNUSED(emb_24_embbag_dedw_lengths); // For single op tests

    // create emb_24_embbag_valid_indices tensor
    const unsigned emb_24_embbag_valid_indices_sizes[] = {1,};
    uint64_t emb_24_embbag_valid_indices_dram;
    unsigned emb_24_embbag_valid_indices_size = 1;
    unsigned emb_24_embbag_valid_indices_size_in_bytes = emb_24_embbag_valid_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_24_embbag_valid_indices_size_in_bytes, &emb_24_embbag_valid_indices_dram, "emb_24_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_24_embbag_valid_indices dram malloc failed!");
    synLaunchTensorInfo emb_24_embbag_valid_indices_tr_info = {"emb_24_embbag_valid_indices",
                                                               emb_24_embbag_valid_indices_dram};
    UNUSED(emb_24_embbag_valid_indices_tr_info); // For single op tests
    synTensor emb_24_embbag_valid_indices = createTensor(1U, syn_type_int32, emb_24_embbag_valid_indices_sizes, true, "emb_24_embbag_valid_indices");
    UNUSED(emb_24_embbag_valid_indices); // For single op tests

    synTensor emb_24_embbag_dedw_SLS_in_vec[4] = {concat_interact0_grad_input25, emb_24_embbag_dedw_grad_indices, emb_24_embbag_dedw_lengths, emb_24_embbag_valid_indices};


    // create emb_24_embbag_dedw_grad_inter tensor
    const unsigned emb_24_embbag_dedw_grad_inter_sizes[] = {128, 32};
    synTensor emb_24_embbag_dedw_grad_inter = createTensor(2U, syn_type_single, emb_24_embbag_dedw_grad_inter_sizes, false, "emb_24_embbag_dedw_grad_inter");
    UNUSED(emb_24_embbag_dedw_grad_inter); // For single op tests

    synTensor emb_24_embbag_dedw_SLS_out_vec[1] = {emb_24_embbag_dedw_grad_inter};


    status = synNodeCreate(graphHandle, emb_24_embbag_dedw_SLS_in_vec, emb_24_embbag_dedw_SLS_out_vec, 4, 1, (void *)&emb_24_embbag_dedw_SLS_kernel_params, sizeof(emb_24_embbag_dedw_SLS_kernel_params), "sparse_lengths_sum_fwd_f32", "emb_24_embbag_dedw_SLS", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_24_embbag_dedw_SLS failed!");

    /*************
     * emb_24_embbag_dedw_EMB node
     * inputs: [emb_24_embbag_dedw_grad_inter(128, 32)(dtype=float32), emb_24_embbag_weight_golden[105, 32](dtype=float32), emb_24_embbag_momentum[105, 32](dtype=float32), emb_24_embbag_dedw_param_table_indices[128](dtype=int32), emb_24_offset_shape[128](dtype=int32), emb_0_embbag_timestamp[1](dtype=int32), emb_0_embbag_rate[1](dtype=float32), emb_24_embbag_valid_indices[1](dtype=int32), emb_24_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_24_embbag_dedw_weight_output_golden(105, 32)(dtype=float32), emb_24_embbag_dedw_momentum_output(105, 32)(dtype=float32), emb_24_embbag_dedw_weight_output(105, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_24_embbag_dedw_EMB_kernel_params;
    emb_24_embbag_dedw_EMB_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_24_embbag_dedw_EMB_kernel_params.sgd.wd = 0;
    emb_24_embbag_dedw_EMB_kernel_params.sgd.mom = 1;
    emb_24_embbag_dedw_EMB_kernel_params.sgd.damp = 0;
    emb_24_embbag_dedw_EMB_kernel_params.sgd.nesterov = false;

    // create emb_24_embbag_weight_golden tensor
    const unsigned emb_24_embbag_weight_golden_sizes[] = {105, 32};
    uint64_t emb_24_embbag_weight_golden_dram;
    unsigned emb_24_embbag_weight_golden_size = 105*32;
    unsigned emb_24_embbag_weight_golden_size_in_bytes = emb_24_embbag_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(emb_24_embbag_weight_golden_size_in_bytes, &emb_24_embbag_weight_golden_dram, "emb_24_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_24_embbag_weight_golden dram malloc failed!");
    synLaunchTensorInfo emb_24_embbag_weight_golden_tr_info = {"emb_24_embbag_weight_golden",
                                                               emb_24_embbag_weight_golden_dram};
    UNUSED(emb_24_embbag_weight_golden_tr_info); // For single op tests
    synTensor emb_24_embbag_weight_golden = createTensor(2U, syn_type_single, emb_24_embbag_weight_golden_sizes, true, "emb_24_embbag_weight_golden");
    UNUSED(emb_24_embbag_weight_golden); // For single op tests

    // create emb_24_embbag_momentum tensor
    const unsigned emb_24_embbag_momentum_sizes[] = {105, 32};
    uint64_t emb_24_embbag_momentum_dram;
    unsigned emb_24_embbag_momentum_size = 105*32;
    unsigned emb_24_embbag_momentum_size_in_bytes = emb_24_embbag_momentum_size * sizeof(float) ;
    status = hbmAlloc(emb_24_embbag_momentum_size_in_bytes, &emb_24_embbag_momentum_dram, "emb_24_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_24_embbag_momentum dram malloc failed!");
    synLaunchTensorInfo emb_24_embbag_momentum_tr_info = {"emb_24_embbag_momentum", emb_24_embbag_momentum_dram};
    UNUSED(emb_24_embbag_momentum_tr_info); // For single op tests
    synTensor emb_24_embbag_momentum = createTensor(2U, syn_type_single, emb_24_embbag_momentum_sizes, true, "emb_24_embbag_momentum");
    UNUSED(emb_24_embbag_momentum); // For single op tests

    // create emb_24_embbag_dedw_param_table_indices tensor
    const unsigned emb_24_embbag_dedw_param_table_indices_sizes[] = {128,};
    uint64_t emb_24_embbag_dedw_param_table_indices_dram;
    unsigned emb_24_embbag_dedw_param_table_indices_size = 128;
    unsigned emb_24_embbag_dedw_param_table_indices_size_in_bytes = emb_24_embbag_dedw_param_table_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_24_embbag_dedw_param_table_indices_size_in_bytes, &emb_24_embbag_dedw_param_table_indices_dram, "emb_24_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_24_embbag_dedw_param_table_indices dram malloc failed!");
    synLaunchTensorInfo emb_24_embbag_dedw_param_table_indices_tr_info = {"emb_24_embbag_dedw_param_table_indices",
                                                                          emb_24_embbag_dedw_param_table_indices_dram};
    UNUSED(emb_24_embbag_dedw_param_table_indices_tr_info); // For single op tests
    synTensor emb_24_embbag_dedw_param_table_indices = createTensor(1U, syn_type_int32, emb_24_embbag_dedw_param_table_indices_sizes, true, "emb_24_embbag_dedw_param_table_indices");
    UNUSED(emb_24_embbag_dedw_param_table_indices); // For single op tests

    // create emb_24_offset_shape tensor
    const unsigned emb_24_offset_shape_sizes[] = {128,};
    uint64_t emb_24_offset_shape_dram;
    unsigned emb_24_offset_shape_size = 128;
    unsigned emb_24_offset_shape_size_in_bytes = emb_24_offset_shape_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_24_offset_shape_size_in_bytes, &emb_24_offset_shape_dram, "emb_24_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_24_offset_shape dram malloc failed!");
    synLaunchTensorInfo emb_24_offset_shape_tr_info = {"emb_24_offset_shape", emb_24_offset_shape_dram};
    UNUSED(emb_24_offset_shape_tr_info); // For single op tests
    synTensor emb_24_offset_shape = createTensor(1U, syn_type_int32, emb_24_offset_shape_sizes, true, "emb_24_offset_shape");
    UNUSED(emb_24_offset_shape); // For single op tests

    synTensor emb_24_embbag_dedw_EMB_in_vec[9] = {emb_24_embbag_dedw_grad_inter, emb_24_embbag_weight_golden, emb_24_embbag_momentum, emb_24_embbag_dedw_param_table_indices, emb_24_offset_shape, emb_0_embbag_timestamp, emb_0_embbag_rate, emb_24_embbag_valid_indices, emb_24_embbag_valid_indices};


    // create emb_24_embbag_dedw_weight_output_golden tensor
    const unsigned emb_24_embbag_dedw_weight_output_golden_sizes[] = {105, 32};
    uint64_t emb_24_embbag_dedw_weight_output_golden_dram = emb_24_embbag_weight_golden_dram;
    synLaunchTensorInfo emb_24_embbag_dedw_weight_output_golden_tr_info = {
        "emb_24_embbag_dedw_weight_output_golden",
        emb_24_embbag_dedw_weight_output_golden_dram};
    UNUSED(emb_24_embbag_dedw_weight_output_golden_tr_info); // For single op tests
    synTensor emb_24_embbag_dedw_weight_output_golden = createTensor(2U, syn_type_single, emb_24_embbag_dedw_weight_output_golden_sizes, true, "emb_24_embbag_dedw_weight_output_golden");
    UNUSED(emb_24_embbag_dedw_weight_output_golden); // For single op tests

    // create emb_24_embbag_dedw_momentum_output tensor
    const unsigned emb_24_embbag_dedw_momentum_output_sizes[] = {105, 32};
    uint64_t emb_24_embbag_dedw_momentum_output_dram;
    unsigned emb_24_embbag_dedw_momentum_output_size = 105*32;
    unsigned emb_24_embbag_dedw_momentum_output_size_in_bytes = emb_24_embbag_dedw_momentum_output_size * sizeof(float) ;
    status = hbmAlloc(emb_24_embbag_dedw_momentum_output_size_in_bytes, &emb_24_embbag_dedw_momentum_output_dram, "emb_24_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_24_embbag_dedw_momentum_output dram malloc failed!");
    synLaunchTensorInfo emb_24_embbag_dedw_momentum_output_tr_info = {"emb_24_embbag_dedw_momentum_output",
                                                                      emb_24_embbag_dedw_momentum_output_dram};
    UNUSED(emb_24_embbag_dedw_momentum_output_tr_info); // For single op tests
    synTensor emb_24_embbag_dedw_momentum_output = createTensor(2U, syn_type_single, emb_24_embbag_dedw_momentum_output_sizes, true, "emb_24_embbag_dedw_momentum_output");
    UNUSED(emb_24_embbag_dedw_momentum_output); // For single op tests

    // create emb_24_embbag_dedw_weight_output tensor
    const unsigned emb_24_embbag_dedw_weight_output_sizes[] = {105, 32};
    uint64_t emb_24_embbag_dedw_weight_output_dram = emb_24_embbag_weight_dram;
    synLaunchTensorInfo emb_24_embbag_dedw_weight_output_tr_info = {"emb_24_embbag_dedw_weight_output",
                                                                    emb_24_embbag_dedw_weight_output_dram};
    UNUSED(emb_24_embbag_dedw_weight_output_tr_info); // For single op tests
    synTensor emb_24_embbag_dedw_weight_output = createTensor(2U, syn_type_bf16, emb_24_embbag_dedw_weight_output_sizes, true, "emb_24_embbag_dedw_weight_output");
    UNUSED(emb_24_embbag_dedw_weight_output); // For single op tests

    synTensor emb_24_embbag_dedw_EMB_out_vec[3] = {emb_24_embbag_dedw_weight_output_golden, emb_24_embbag_dedw_momentum_output, emb_24_embbag_dedw_weight_output};


    status = synNodeCreate(graphHandle, emb_24_embbag_dedw_EMB_in_vec, emb_24_embbag_dedw_EMB_out_vec, 9, 3, (void *)&emb_24_embbag_dedw_EMB_kernel_params, sizeof(emb_24_embbag_dedw_EMB_kernel_params), "embedding_bag_sgd_bwd_f32", "emb_24_embbag_dedw_EMB", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_24_embbag_dedw_EMB failed!");

    /*************
     * emb_25_embbag_dedw_SLS node
     * inputs: [concat_interact0_grad_input26(128, 32)(dtype=float32), emb_25_embbag_dedw_grad_indices[128](dtype=int32), emb_25_embbag_dedw_lengths[128](dtype=int32), emb_25_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_25_embbag_dedw_grad_inter(128, 32)(dtype=float32)]
     *************/
    ns_SparseLengthsSum::Params emb_25_embbag_dedw_SLS_kernel_params;
    emb_25_embbag_dedw_SLS_kernel_params.mode = EMBEDDED_SC_ZP;

    // create emb_25_embbag_dedw_grad_indices tensor
    const unsigned emb_25_embbag_dedw_grad_indices_sizes[] = {128,};
    uint64_t emb_25_embbag_dedw_grad_indices_dram;
    unsigned emb_25_embbag_dedw_grad_indices_size = 128;
    unsigned emb_25_embbag_dedw_grad_indices_size_in_bytes = emb_25_embbag_dedw_grad_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_25_embbag_dedw_grad_indices_size_in_bytes, &emb_25_embbag_dedw_grad_indices_dram, "emb_25_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_25_embbag_dedw_grad_indices dram malloc failed!");
    synLaunchTensorInfo emb_25_embbag_dedw_grad_indices_tr_info = {"emb_25_embbag_dedw_grad_indices",
                                                                   emb_25_embbag_dedw_grad_indices_dram};
    UNUSED(emb_25_embbag_dedw_grad_indices_tr_info); // For single op tests
    synTensor emb_25_embbag_dedw_grad_indices = createTensor(1U, syn_type_int32, emb_25_embbag_dedw_grad_indices_sizes, true, "emb_25_embbag_dedw_grad_indices");
    UNUSED(emb_25_embbag_dedw_grad_indices); // For single op tests

    // create emb_25_embbag_dedw_lengths tensor
    const unsigned emb_25_embbag_dedw_lengths_sizes[] = {128,};
    uint64_t emb_25_embbag_dedw_lengths_dram;
    unsigned emb_25_embbag_dedw_lengths_size = 128;
    unsigned emb_25_embbag_dedw_lengths_size_in_bytes = emb_25_embbag_dedw_lengths_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_25_embbag_dedw_lengths_size_in_bytes, &emb_25_embbag_dedw_lengths_dram, "emb_25_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_25_embbag_dedw_lengths dram malloc failed!");
    synLaunchTensorInfo emb_25_embbag_dedw_lengths_tr_info = {"emb_25_embbag_dedw_lengths",
                                                              emb_25_embbag_dedw_lengths_dram};
    UNUSED(emb_25_embbag_dedw_lengths_tr_info); // For single op tests
    synTensor emb_25_embbag_dedw_lengths = createTensor(1U, syn_type_int32, emb_25_embbag_dedw_lengths_sizes, true, "emb_25_embbag_dedw_lengths");
    UNUSED(emb_25_embbag_dedw_lengths); // For single op tests

    // create emb_25_embbag_valid_indices tensor
    const unsigned emb_25_embbag_valid_indices_sizes[] = {1,};
    uint64_t emb_25_embbag_valid_indices_dram;
    unsigned emb_25_embbag_valid_indices_size = 1;
    unsigned emb_25_embbag_valid_indices_size_in_bytes = emb_25_embbag_valid_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_25_embbag_valid_indices_size_in_bytes, &emb_25_embbag_valid_indices_dram, "emb_25_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_25_embbag_valid_indices dram malloc failed!");
    synLaunchTensorInfo emb_25_embbag_valid_indices_tr_info = {"emb_25_embbag_valid_indices",
                                                               emb_25_embbag_valid_indices_dram};
    UNUSED(emb_25_embbag_valid_indices_tr_info); // For single op tests
    synTensor emb_25_embbag_valid_indices = createTensor(1U, syn_type_int32, emb_25_embbag_valid_indices_sizes, true, "emb_25_embbag_valid_indices");
    UNUSED(emb_25_embbag_valid_indices); // For single op tests

    synTensor emb_25_embbag_dedw_SLS_in_vec[4] = {concat_interact0_grad_input26, emb_25_embbag_dedw_grad_indices, emb_25_embbag_dedw_lengths, emb_25_embbag_valid_indices};


    // create emb_25_embbag_dedw_grad_inter tensor
    const unsigned emb_25_embbag_dedw_grad_inter_sizes[] = {128, 32};
    synTensor emb_25_embbag_dedw_grad_inter = createTensor(2U, syn_type_single, emb_25_embbag_dedw_grad_inter_sizes, false, "emb_25_embbag_dedw_grad_inter");
    UNUSED(emb_25_embbag_dedw_grad_inter); // For single op tests

    synTensor emb_25_embbag_dedw_SLS_out_vec[1] = {emb_25_embbag_dedw_grad_inter};


    status = synNodeCreate(graphHandle, emb_25_embbag_dedw_SLS_in_vec, emb_25_embbag_dedw_SLS_out_vec, 4, 1, (void *)&emb_25_embbag_dedw_SLS_kernel_params, sizeof(emb_25_embbag_dedw_SLS_kernel_params), "sparse_lengths_sum_fwd_f32", "emb_25_embbag_dedw_SLS", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_25_embbag_dedw_SLS failed!");

    /*************
     * emb_25_embbag_dedw_EMB node
     * inputs: [emb_25_embbag_dedw_grad_inter(128, 32)(dtype=float32), emb_25_embbag_weight_golden[135786, 32](dtype=float32), emb_25_embbag_momentum[135786, 32](dtype=float32), emb_25_embbag_dedw_param_table_indices[128](dtype=int32), emb_25_offset_shape[128](dtype=int32), emb_0_embbag_timestamp[1](dtype=int32), emb_0_embbag_rate[1](dtype=float32), emb_25_embbag_valid_indices[1](dtype=int32), emb_25_embbag_valid_indices[1](dtype=int32)]
     * output: [emb_25_embbag_dedw_weight_output_golden(135786, 32)(dtype=float32), emb_25_embbag_dedw_momentum_output(135786, 32)(dtype=float32), emb_25_embbag_dedw_weight_output(135786, 32)(dtype=bf16)]
     *************/
    ns_EmbeddingBagWithSgdKernel::Params emb_25_embbag_dedw_EMB_kernel_params;
    emb_25_embbag_dedw_EMB_kernel_params.mode = EMBEDDING_BAG_MODE_SUM;
    emb_25_embbag_dedw_EMB_kernel_params.sgd.wd = 0;
    emb_25_embbag_dedw_EMB_kernel_params.sgd.mom = 1;
    emb_25_embbag_dedw_EMB_kernel_params.sgd.damp = 0;
    emb_25_embbag_dedw_EMB_kernel_params.sgd.nesterov = false;

    // create emb_25_embbag_weight_golden tensor
    const unsigned emb_25_embbag_weight_golden_sizes[] = {135786, 32};
    uint64_t emb_25_embbag_weight_golden_dram;
    unsigned emb_25_embbag_weight_golden_size = 135786*32;
    unsigned emb_25_embbag_weight_golden_size_in_bytes = emb_25_embbag_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(emb_25_embbag_weight_golden_size_in_bytes, &emb_25_embbag_weight_golden_dram, "emb_25_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_25_embbag_weight_golden dram malloc failed!");
    synLaunchTensorInfo emb_25_embbag_weight_golden_tr_info = {"emb_25_embbag_weight_golden",
                                                               emb_25_embbag_weight_golden_dram};
    UNUSED(emb_25_embbag_weight_golden_tr_info); // For single op tests
    synTensor emb_25_embbag_weight_golden = createTensor(2U, syn_type_single, emb_25_embbag_weight_golden_sizes, true, "emb_25_embbag_weight_golden");
    UNUSED(emb_25_embbag_weight_golden); // For single op tests

    // create emb_25_embbag_momentum tensor
    const unsigned emb_25_embbag_momentum_sizes[] = {135786, 32};
    uint64_t emb_25_embbag_momentum_dram;
    unsigned emb_25_embbag_momentum_size = 135786*32;
    unsigned emb_25_embbag_momentum_size_in_bytes = emb_25_embbag_momentum_size * sizeof(float) ;
    status = hbmAlloc(emb_25_embbag_momentum_size_in_bytes, &emb_25_embbag_momentum_dram, "emb_25_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_25_embbag_momentum dram malloc failed!");
    synLaunchTensorInfo emb_25_embbag_momentum_tr_info = {"emb_25_embbag_momentum", emb_25_embbag_momentum_dram};
    UNUSED(emb_25_embbag_momentum_tr_info); // For single op tests
    synTensor emb_25_embbag_momentum = createTensor(2U, syn_type_single, emb_25_embbag_momentum_sizes, true, "emb_25_embbag_momentum");
    UNUSED(emb_25_embbag_momentum); // For single op tests

    // create emb_25_embbag_dedw_param_table_indices tensor
    const unsigned emb_25_embbag_dedw_param_table_indices_sizes[] = {128,};
    uint64_t emb_25_embbag_dedw_param_table_indices_dram;
    unsigned emb_25_embbag_dedw_param_table_indices_size = 128;
    unsigned emb_25_embbag_dedw_param_table_indices_size_in_bytes = emb_25_embbag_dedw_param_table_indices_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_25_embbag_dedw_param_table_indices_size_in_bytes, &emb_25_embbag_dedw_param_table_indices_dram, "emb_25_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_25_embbag_dedw_param_table_indices dram malloc failed!");
    synLaunchTensorInfo emb_25_embbag_dedw_param_table_indices_tr_info = {"emb_25_embbag_dedw_param_table_indices",
                                                                          emb_25_embbag_dedw_param_table_indices_dram};
    UNUSED(emb_25_embbag_dedw_param_table_indices_tr_info); // For single op tests
    synTensor emb_25_embbag_dedw_param_table_indices = createTensor(1U, syn_type_int32, emb_25_embbag_dedw_param_table_indices_sizes, true, "emb_25_embbag_dedw_param_table_indices");
    UNUSED(emb_25_embbag_dedw_param_table_indices); // For single op tests

    // create emb_25_offset_shape tensor
    const unsigned emb_25_offset_shape_sizes[] = {128,};
    uint64_t emb_25_offset_shape_dram;
    unsigned emb_25_offset_shape_size = 128;
    unsigned emb_25_offset_shape_size_in_bytes = emb_25_offset_shape_size * sizeof(int32_t) ;
    status = hbmAlloc(emb_25_offset_shape_size_in_bytes, &emb_25_offset_shape_dram, "emb_25_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_25_offset_shape dram malloc failed!");
    synLaunchTensorInfo emb_25_offset_shape_tr_info = {"emb_25_offset_shape", emb_25_offset_shape_dram};
    UNUSED(emb_25_offset_shape_tr_info); // For single op tests
    synTensor emb_25_offset_shape = createTensor(1U, syn_type_int32, emb_25_offset_shape_sizes, true, "emb_25_offset_shape");
    UNUSED(emb_25_offset_shape); // For single op tests

    synTensor emb_25_embbag_dedw_EMB_in_vec[9] = {emb_25_embbag_dedw_grad_inter, emb_25_embbag_weight_golden, emb_25_embbag_momentum, emb_25_embbag_dedw_param_table_indices, emb_25_offset_shape, emb_0_embbag_timestamp, emb_0_embbag_rate, emb_25_embbag_valid_indices, emb_25_embbag_valid_indices};


    // create emb_25_embbag_dedw_weight_output_golden tensor
    const unsigned emb_25_embbag_dedw_weight_output_golden_sizes[] = {135786, 32};
    uint64_t emb_25_embbag_dedw_weight_output_golden_dram = emb_25_embbag_weight_golden_dram;
    synLaunchTensorInfo emb_25_embbag_dedw_weight_output_golden_tr_info = {
        "emb_25_embbag_dedw_weight_output_golden",
        emb_25_embbag_dedw_weight_output_golden_dram};
    UNUSED(emb_25_embbag_dedw_weight_output_golden_tr_info); // For single op tests
    synTensor emb_25_embbag_dedw_weight_output_golden = createTensor(2U, syn_type_single, emb_25_embbag_dedw_weight_output_golden_sizes, true, "emb_25_embbag_dedw_weight_output_golden");
    UNUSED(emb_25_embbag_dedw_weight_output_golden); // For single op tests

    // create emb_25_embbag_dedw_momentum_output tensor
    const unsigned emb_25_embbag_dedw_momentum_output_sizes[] = {135786, 32};
    uint64_t emb_25_embbag_dedw_momentum_output_dram;
    unsigned emb_25_embbag_dedw_momentum_output_size = 135786*32;
    unsigned emb_25_embbag_dedw_momentum_output_size_in_bytes = emb_25_embbag_dedw_momentum_output_size * sizeof(float) ;
    status = hbmAlloc(emb_25_embbag_dedw_momentum_output_size_in_bytes, &emb_25_embbag_dedw_momentum_output_dram, "emb_25_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_25_embbag_dedw_momentum_output dram malloc failed!");
    synLaunchTensorInfo emb_25_embbag_dedw_momentum_output_tr_info = {"emb_25_embbag_dedw_momentum_output",
                                                                      emb_25_embbag_dedw_momentum_output_dram};
    UNUSED(emb_25_embbag_dedw_momentum_output_tr_info); // For single op tests
    synTensor emb_25_embbag_dedw_momentum_output = createTensor(2U, syn_type_single, emb_25_embbag_dedw_momentum_output_sizes, true, "emb_25_embbag_dedw_momentum_output");
    UNUSED(emb_25_embbag_dedw_momentum_output); // For single op tests

    // create emb_25_embbag_dedw_weight_output tensor
    const unsigned emb_25_embbag_dedw_weight_output_sizes[] = {135786, 32};
    uint64_t emb_25_embbag_dedw_weight_output_dram = emb_25_embbag_weight_dram;
    synLaunchTensorInfo emb_25_embbag_dedw_weight_output_tr_info = {"emb_25_embbag_dedw_weight_output",
                                                                    emb_25_embbag_dedw_weight_output_dram};
    UNUSED(emb_25_embbag_dedw_weight_output_tr_info); // For single op tests
    synTensor emb_25_embbag_dedw_weight_output = createTensor(2U, syn_type_bf16, emb_25_embbag_dedw_weight_output_sizes, true, "emb_25_embbag_dedw_weight_output");
    UNUSED(emb_25_embbag_dedw_weight_output); // For single op tests

    synTensor emb_25_embbag_dedw_EMB_out_vec[3] = {emb_25_embbag_dedw_weight_output_golden, emb_25_embbag_dedw_momentum_output, emb_25_embbag_dedw_weight_output};


    status = synNodeCreate(graphHandle, emb_25_embbag_dedw_EMB_in_vec, emb_25_embbag_dedw_EMB_out_vec, 9, 3, (void *)&emb_25_embbag_dedw_EMB_kernel_params, sizeof(emb_25_embbag_dedw_EMB_kernel_params), "embedding_bag_sgd_bwd_f32", "emb_25_embbag_dedw_EMB", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for emb_25_embbag_dedw_EMB failed!");

    /*************
     * bot_l_4_relu_bwd_add_grads_concat_output_reshape node
     * inputs: [add_grads_concat_output(128, 32)(dtype=bf16)]
     * output: [bot_l_4_relu_bwd_add_grads_concat_output_tensor_reshape(128, 1, 1, 32)(dtype=bf16)]
     *************/

    synTensor bot_l_4_relu_bwd_add_grads_concat_output_reshape_in_vec[1] = {add_grads_concat_output};


    // create bot_l_4_relu_bwd_add_grads_concat_output_tensor_reshape tensor
    const unsigned bot_l_4_relu_bwd_add_grads_concat_output_tensor_reshape_sizes[] = {128, 1, 1, 32};
    synTensor bot_l_4_relu_bwd_add_grads_concat_output_tensor_reshape = createTensor(4U, syn_type_bf16, bot_l_4_relu_bwd_add_grads_concat_output_tensor_reshape_sizes, false, "bot_l_4_relu_bwd_add_grads_concat_output_tensor_reshape");
    UNUSED(bot_l_4_relu_bwd_add_grads_concat_output_tensor_reshape); // For single op tests

    synTensor bot_l_4_relu_bwd_add_grads_concat_output_reshape_out_vec[1] = {bot_l_4_relu_bwd_add_grads_concat_output_tensor_reshape};


    status = synNodeCreate(graphHandle, bot_l_4_relu_bwd_add_grads_concat_output_reshape_in_vec, bot_l_4_relu_bwd_add_grads_concat_output_reshape_out_vec, 1, 1, nullptr, 0, "reshape", "bot_l_4_relu_bwd_add_grads_concat_output_reshape", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bot_l_4_relu_bwd_add_grads_concat_output_reshape failed!");

    /*************
     * bot_l_4_relu_bwd node
     * inputs: [bot_l_4_relu_bwd_add_grads_concat_output_tensor_reshape(128, 1, 1, 32)(dtype=bf16), bot_l_4_relu_output(128, 1, 1, 32)(dtype=bf16)]
     * output: [bot_l_4_relu_grad_input(128, 1, 1, 32)(dtype=bf16)]
     *************/

    synTensor bot_l_4_relu_bwd_in_vec[2] = {bot_l_4_relu_bwd_add_grads_concat_output_tensor_reshape, bot_l_4_relu_output};


    // create bot_l_4_relu_grad_input tensor
    const unsigned bot_l_4_relu_grad_input_sizes[] = {128, 1, 1, 32};
    synTensor bot_l_4_relu_grad_input = createTensor(4U, syn_type_bf16, bot_l_4_relu_grad_input_sizes, false, "bot_l_4_relu_grad_input");
    UNUSED(bot_l_4_relu_grad_input); // For single op tests

    synTensor bot_l_4_relu_bwd_out_vec[1] = {bot_l_4_relu_grad_input};


    status = synNodeCreate(graphHandle, bot_l_4_relu_bwd_in_vec, bot_l_4_relu_bwd_out_vec, 2, 1, nullptr, 0, "relu_bwd_bf16", "bot_l_4_relu_bwd", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bot_l_4_relu_bwd failed!");

    /*************
     * bot_l_4_linear_dedx node
     * inputs: [bot_l_4_relu_grad_input(128, 1, 1, 32)(dtype=bf16), bot_l_4_linear_weight(1, 1, 512, 32)(dtype=bf16)]
     * output: [bot_l_4_linear_grad_input(128, 1, 1, 512)(dtype=bf16)]
     *************/
    synConvolutionParams bot_l_4_linear_dedx_kernel_params;
    bot_l_4_linear_dedx_kernel_params.dH = 1;
    bot_l_4_linear_dedx_kernel_params.dW = 1;
    bot_l_4_linear_dedx_kernel_params.kH = 1;
    bot_l_4_linear_dedx_kernel_params.kW = 1;
    bot_l_4_linear_dedx_kernel_params.padT = 0;
    bot_l_4_linear_dedx_kernel_params.padB = 0;
    bot_l_4_linear_dedx_kernel_params.padL = 0;
    bot_l_4_linear_dedx_kernel_params.padR = 0;
    bot_l_4_linear_dedx_kernel_params.dilH = 1;
    bot_l_4_linear_dedx_kernel_params.dilW = 1;

    synTensor bot_l_4_linear_dedx_in_vec[2] = {bot_l_4_relu_grad_input, bot_l_4_linear_weight};


    // create bot_l_4_linear_grad_input tensor
    const unsigned bot_l_4_linear_grad_input_sizes[] = {128, 1, 1, 512};
    uint64_t bot_l_4_linear_grad_input_dram;
    unsigned bot_l_4_linear_grad_input_size = 128*1*1*512;
    unsigned bot_l_4_linear_grad_input_size_in_bytes = bot_l_4_linear_grad_input_size * sizeof(bfloat16) ;
    status = hbmAlloc(bot_l_4_linear_grad_input_size_in_bytes, &bot_l_4_linear_grad_input_dram, "bot_l_4_linear_grad_input");
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_grad_input dram malloc failed!");
    synLaunchTensorInfo bot_l_4_linear_grad_input_tr_info = {"bot_l_4_linear_grad_input",
                                                             bot_l_4_linear_grad_input_dram};
    UNUSED(bot_l_4_linear_grad_input_tr_info); // For single op tests
    synTensor bot_l_4_linear_grad_input = createTensor(4U, syn_type_bf16, bot_l_4_linear_grad_input_sizes, true, "bot_l_4_linear_grad_input");
    UNUSED(bot_l_4_linear_grad_input); // For single op tests

    synTensor bot_l_4_linear_dedx_out_vec[1] = {bot_l_4_linear_grad_input};


    status = synNodeCreate(graphHandle, bot_l_4_linear_dedx_in_vec, bot_l_4_linear_dedx_out_vec, 2, 1, (void *)&bot_l_4_linear_dedx_kernel_params, sizeof(bot_l_4_linear_dedx_kernel_params), "dedx", "bot_l_4_linear_dedx", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bot_l_4_linear_dedx failed!");

    /*************
     * bot_l_4_linear_dedw node
     * inputs: [bot_l_4_relu_grad_input(128, 1, 1, 32)(dtype=bf16), bot_l_2_relu_output(128, 1, 1, 512)(dtype=bf16)]
     * output: [bot_l_4_linear_weight_grad(1, 1, 512, 32)(dtype=float32)]
     *************/
    synConvolutionParams bot_l_4_linear_dedw_kernel_params;
    bot_l_4_linear_dedw_kernel_params.dH = 1;
    bot_l_4_linear_dedw_kernel_params.dW = 1;
    bot_l_4_linear_dedw_kernel_params.kH = 1;
    bot_l_4_linear_dedw_kernel_params.kW = 1;
    bot_l_4_linear_dedw_kernel_params.padT = 0;
    bot_l_4_linear_dedw_kernel_params.padB = 0;
    bot_l_4_linear_dedw_kernel_params.padL = 0;
    bot_l_4_linear_dedw_kernel_params.padR = 0;
    bot_l_4_linear_dedw_kernel_params.dilH = 1;
    bot_l_4_linear_dedw_kernel_params.dilW = 1;

    synTensor bot_l_4_linear_dedw_in_vec[2] = {bot_l_4_relu_grad_input, bot_l_2_relu_output};


    // create bot_l_4_linear_weight_grad tensor
    const unsigned bot_l_4_linear_weight_grad_sizes[] = {1, 1, 512, 32};
    uint64_t bot_l_4_linear_weight_grad_dram;
    unsigned bot_l_4_linear_weight_grad_size = 1*1*512*32;
    unsigned bot_l_4_linear_weight_grad_size_in_bytes = bot_l_4_linear_weight_grad_size * sizeof(float) ;
    status = hbmAlloc(bot_l_4_linear_weight_grad_size_in_bytes, &bot_l_4_linear_weight_grad_dram, "bot_l_4_linear_weight_grad");
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_weight_grad dram malloc failed!");
    synLaunchTensorInfo bot_l_4_linear_weight_grad_tr_info = {"bot_l_4_linear_weight_grad",
                                                              bot_l_4_linear_weight_grad_dram};
    UNUSED(bot_l_4_linear_weight_grad_tr_info); // For single op tests
    synTensor bot_l_4_linear_weight_grad = createTensor(4U, syn_type_single, bot_l_4_linear_weight_grad_sizes, true, "bot_l_4_linear_weight_grad");
    UNUSED(bot_l_4_linear_weight_grad); // For single op tests

    synTensor bot_l_4_linear_dedw_out_vec[1] = {bot_l_4_linear_weight_grad};


    status = synNodeCreate(graphHandle, bot_l_4_linear_dedw_in_vec, bot_l_4_linear_dedw_out_vec, 2, 1, (void *)&bot_l_4_linear_dedw_kernel_params, sizeof(bot_l_4_linear_dedw_kernel_params), "dedw", "bot_l_4_linear_dedw", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bot_l_4_linear_dedw failed!");

    /*************
     * bot_l_4_linear_dedb_bot_l_4_relu_grad_input_reshape node
     * inputs: [bot_l_4_relu_grad_input(128, 1, 1, 32)(dtype=bf16)]
     * output: [bot_l_4_linear_dedb_bot_l_4_relu_grad_input_tensor_reshape(128, 32)(dtype=bf16)]
     *************/

    synTensor bot_l_4_linear_dedb_bot_l_4_relu_grad_input_reshape_in_vec[1] = {bot_l_4_relu_grad_input};


    // create bot_l_4_linear_dedb_bot_l_4_relu_grad_input_tensor_reshape tensor
    const unsigned bot_l_4_linear_dedb_bot_l_4_relu_grad_input_tensor_reshape_sizes[] = {128, 32};
    synTensor bot_l_4_linear_dedb_bot_l_4_relu_grad_input_tensor_reshape = createTensor(2U, syn_type_bf16, bot_l_4_linear_dedb_bot_l_4_relu_grad_input_tensor_reshape_sizes, false, "bot_l_4_linear_dedb_bot_l_4_relu_grad_input_tensor_reshape");
    UNUSED(bot_l_4_linear_dedb_bot_l_4_relu_grad_input_tensor_reshape); // For single op tests

    synTensor bot_l_4_linear_dedb_bot_l_4_relu_grad_input_reshape_out_vec[1] = {bot_l_4_linear_dedb_bot_l_4_relu_grad_input_tensor_reshape};


    status = synNodeCreate(graphHandle, bot_l_4_linear_dedb_bot_l_4_relu_grad_input_reshape_in_vec, bot_l_4_linear_dedb_bot_l_4_relu_grad_input_reshape_out_vec, 1, 1, nullptr, 0, "reshape", "bot_l_4_linear_dedb_bot_l_4_relu_grad_input_reshape", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bot_l_4_linear_dedb_bot_l_4_relu_grad_input_reshape failed!");

    /*************
     * bot_l_4_linear_dedb node
     * inputs: [bot_l_4_linear_dedb_bot_l_4_relu_grad_input_tensor_reshape(128, 32)(dtype=bf16)]
     * output: [bot_l_4_linear_bias_grad(32,)(dtype=float32)]
     *************/
    ns_Reduction::Params bot_l_4_linear_dedb_kernel_params;
    bot_l_4_linear_dedb_kernel_params.reductionDimension = 1;

    synTensor bot_l_4_linear_dedb_in_vec[1] = {bot_l_4_linear_dedb_bot_l_4_relu_grad_input_tensor_reshape};


    // create bot_l_4_linear_bias_grad tensor
    const unsigned bot_l_4_linear_bias_grad_sizes[] = {32,};
    uint64_t bot_l_4_linear_bias_grad_dram;
    unsigned bot_l_4_linear_bias_grad_size = 32;
    unsigned bot_l_4_linear_bias_grad_size_in_bytes = bot_l_4_linear_bias_grad_size * sizeof(float) ;
    status = hbmAlloc(bot_l_4_linear_bias_grad_size_in_bytes, &bot_l_4_linear_bias_grad_dram, "bot_l_4_linear_bias_grad");
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_bias_grad dram malloc failed!");
    synLaunchTensorInfo bot_l_4_linear_bias_grad_tr_info = {"bot_l_4_linear_bias_grad", bot_l_4_linear_bias_grad_dram};
    UNUSED(bot_l_4_linear_bias_grad_tr_info); // For single op tests
    synTensor bot_l_4_linear_bias_grad = createTensor(1U, syn_type_single, bot_l_4_linear_bias_grad_sizes, true, "bot_l_4_linear_bias_grad");
    UNUSED(bot_l_4_linear_bias_grad); // For single op tests

    synTensor bot_l_4_linear_dedb_out_vec[1] = {bot_l_4_linear_bias_grad};


    status = synNodeCreate(graphHandle, bot_l_4_linear_dedb_in_vec, bot_l_4_linear_dedb_out_vec, 1, 1, (void *)&bot_l_4_linear_dedb_kernel_params, sizeof(bot_l_4_linear_dedb_kernel_params), "reduce_sum_fwd_bf16", "bot_l_4_linear_dedb", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bot_l_4_linear_dedb failed!");

    /*************
     * bot_l_2_relu_bwd node
     * inputs: [bot_l_4_linear_grad_input(128, 1, 1, 512)(dtype=bf16), bot_l_2_relu_output(128, 1, 1, 512)(dtype=bf16)]
     * output: [bot_l_2_relu_grad_input(128, 1, 1, 512)(dtype=bf16)]
     *************/

    synTensor bot_l_2_relu_bwd_in_vec[2] = {bot_l_4_linear_grad_input, bot_l_2_relu_output};


    // create bot_l_2_relu_grad_input tensor
    const unsigned bot_l_2_relu_grad_input_sizes[] = {128, 1, 1, 512};
    synTensor bot_l_2_relu_grad_input = createTensor(4U, syn_type_bf16, bot_l_2_relu_grad_input_sizes, false, "bot_l_2_relu_grad_input");
    UNUSED(bot_l_2_relu_grad_input); // For single op tests

    synTensor bot_l_2_relu_bwd_out_vec[1] = {bot_l_2_relu_grad_input};


    status = synNodeCreate(graphHandle, bot_l_2_relu_bwd_in_vec, bot_l_2_relu_bwd_out_vec, 2, 1, nullptr, 0, "relu_bwd_bf16", "bot_l_2_relu_bwd", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bot_l_2_relu_bwd failed!");

    /*************
     * bot_l_2_linear_dedx node
     * inputs: [bot_l_2_relu_grad_input(128, 1, 1, 512)(dtype=bf16), bot_l_2_linear_weight(1, 1, 512, 512)(dtype=bf16)]
     * output: [bot_l_2_linear_grad_input(128, 1, 1, 512)(dtype=bf16)]
     *************/
    synConvolutionParams bot_l_2_linear_dedx_kernel_params;
    bot_l_2_linear_dedx_kernel_params.dH = 1;
    bot_l_2_linear_dedx_kernel_params.dW = 1;
    bot_l_2_linear_dedx_kernel_params.kH = 1;
    bot_l_2_linear_dedx_kernel_params.kW = 1;
    bot_l_2_linear_dedx_kernel_params.padT = 0;
    bot_l_2_linear_dedx_kernel_params.padB = 0;
    bot_l_2_linear_dedx_kernel_params.padL = 0;
    bot_l_2_linear_dedx_kernel_params.padR = 0;
    bot_l_2_linear_dedx_kernel_params.dilH = 1;
    bot_l_2_linear_dedx_kernel_params.dilW = 1;

    synTensor bot_l_2_linear_dedx_in_vec[2] = {bot_l_2_relu_grad_input, bot_l_2_linear_weight};


    // create bot_l_2_linear_grad_input tensor
    const unsigned bot_l_2_linear_grad_input_sizes[] = {128, 1, 1, 512};
    uint64_t bot_l_2_linear_grad_input_dram;
    unsigned bot_l_2_linear_grad_input_size = 128*1*1*512;
    unsigned bot_l_2_linear_grad_input_size_in_bytes = bot_l_2_linear_grad_input_size * sizeof(bfloat16) ;
    status = hbmAlloc(bot_l_2_linear_grad_input_size_in_bytes, &bot_l_2_linear_grad_input_dram, "bot_l_2_linear_grad_input");
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_grad_input dram malloc failed!");
    synLaunchTensorInfo bot_l_2_linear_grad_input_tr_info = {"bot_l_2_linear_grad_input",
                                                             bot_l_2_linear_grad_input_dram};
    UNUSED(bot_l_2_linear_grad_input_tr_info); // For single op tests
    synTensor bot_l_2_linear_grad_input = createTensor(4U, syn_type_bf16, bot_l_2_linear_grad_input_sizes, true, "bot_l_2_linear_grad_input");
    UNUSED(bot_l_2_linear_grad_input); // For single op tests

    synTensor bot_l_2_linear_dedx_out_vec[1] = {bot_l_2_linear_grad_input};


    status = synNodeCreate(graphHandle, bot_l_2_linear_dedx_in_vec, bot_l_2_linear_dedx_out_vec, 2, 1, (void *)&bot_l_2_linear_dedx_kernel_params, sizeof(bot_l_2_linear_dedx_kernel_params), "dedx", "bot_l_2_linear_dedx", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bot_l_2_linear_dedx failed!");

    /*************
     * bot_l_2_linear_dedw node
     * inputs: [bot_l_2_relu_grad_input(128, 1, 1, 512)(dtype=bf16), bot_l_0_relu_output(128, 1, 1, 512)(dtype=bf16)]
     * output: [bot_l_2_linear_weight_grad(1, 1, 512, 512)(dtype=float32)]
     *************/
    synConvolutionParams bot_l_2_linear_dedw_kernel_params;
    bot_l_2_linear_dedw_kernel_params.dH = 1;
    bot_l_2_linear_dedw_kernel_params.dW = 1;
    bot_l_2_linear_dedw_kernel_params.kH = 1;
    bot_l_2_linear_dedw_kernel_params.kW = 1;
    bot_l_2_linear_dedw_kernel_params.padT = 0;
    bot_l_2_linear_dedw_kernel_params.padB = 0;
    bot_l_2_linear_dedw_kernel_params.padL = 0;
    bot_l_2_linear_dedw_kernel_params.padR = 0;
    bot_l_2_linear_dedw_kernel_params.dilH = 1;
    bot_l_2_linear_dedw_kernel_params.dilW = 1;

    synTensor bot_l_2_linear_dedw_in_vec[2] = {bot_l_2_relu_grad_input, bot_l_0_relu_output};


    // create bot_l_2_linear_weight_grad tensor
    const unsigned bot_l_2_linear_weight_grad_sizes[] = {1, 1, 512, 512};
    uint64_t bot_l_2_linear_weight_grad_dram;
    unsigned bot_l_2_linear_weight_grad_size = 1*1*512*512;
    unsigned bot_l_2_linear_weight_grad_size_in_bytes = bot_l_2_linear_weight_grad_size * sizeof(float) ;
    status = hbmAlloc(bot_l_2_linear_weight_grad_size_in_bytes, &bot_l_2_linear_weight_grad_dram, "bot_l_2_linear_weight_grad");
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_weight_grad dram malloc failed!");
    synLaunchTensorInfo bot_l_2_linear_weight_grad_tr_info = {"bot_l_2_linear_weight_grad",
                                                              bot_l_2_linear_weight_grad_dram};
    UNUSED(bot_l_2_linear_weight_grad_tr_info); // For single op tests
    synTensor bot_l_2_linear_weight_grad = createTensor(4U, syn_type_single, bot_l_2_linear_weight_grad_sizes, true, "bot_l_2_linear_weight_grad");
    UNUSED(bot_l_2_linear_weight_grad); // For single op tests

    synTensor bot_l_2_linear_dedw_out_vec[1] = {bot_l_2_linear_weight_grad};


    status = synNodeCreate(graphHandle, bot_l_2_linear_dedw_in_vec, bot_l_2_linear_dedw_out_vec, 2, 1, (void *)&bot_l_2_linear_dedw_kernel_params, sizeof(bot_l_2_linear_dedw_kernel_params), "dedw", "bot_l_2_linear_dedw", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bot_l_2_linear_dedw failed!");

    /*************
     * bot_l_2_linear_dedb_bot_l_2_relu_grad_input_reshape node
     * inputs: [bot_l_2_relu_grad_input(128, 1, 1, 512)(dtype=bf16)]
     * output: [bot_l_2_linear_dedb_bot_l_2_relu_grad_input_tensor_reshape(128, 512)(dtype=bf16)]
     *************/

    synTensor bot_l_2_linear_dedb_bot_l_2_relu_grad_input_reshape_in_vec[1] = {bot_l_2_relu_grad_input};


    // create bot_l_2_linear_dedb_bot_l_2_relu_grad_input_tensor_reshape tensor
    const unsigned bot_l_2_linear_dedb_bot_l_2_relu_grad_input_tensor_reshape_sizes[] = {128, 512};
    synTensor bot_l_2_linear_dedb_bot_l_2_relu_grad_input_tensor_reshape = createTensor(2U, syn_type_bf16, bot_l_2_linear_dedb_bot_l_2_relu_grad_input_tensor_reshape_sizes, false, "bot_l_2_linear_dedb_bot_l_2_relu_grad_input_tensor_reshape");
    UNUSED(bot_l_2_linear_dedb_bot_l_2_relu_grad_input_tensor_reshape); // For single op tests

    synTensor bot_l_2_linear_dedb_bot_l_2_relu_grad_input_reshape_out_vec[1] = {bot_l_2_linear_dedb_bot_l_2_relu_grad_input_tensor_reshape};


    status = synNodeCreate(graphHandle, bot_l_2_linear_dedb_bot_l_2_relu_grad_input_reshape_in_vec, bot_l_2_linear_dedb_bot_l_2_relu_grad_input_reshape_out_vec, 1, 1, nullptr, 0, "reshape", "bot_l_2_linear_dedb_bot_l_2_relu_grad_input_reshape", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bot_l_2_linear_dedb_bot_l_2_relu_grad_input_reshape failed!");

    /*************
     * bot_l_2_linear_dedb node
     * inputs: [bot_l_2_linear_dedb_bot_l_2_relu_grad_input_tensor_reshape(128, 512)(dtype=bf16)]
     * output: [bot_l_2_linear_bias_grad(512,)(dtype=float32)]
     *************/
    ns_Reduction::Params bot_l_2_linear_dedb_kernel_params;
    bot_l_2_linear_dedb_kernel_params.reductionDimension = 1;

    synTensor bot_l_2_linear_dedb_in_vec[1] = {bot_l_2_linear_dedb_bot_l_2_relu_grad_input_tensor_reshape};


    // create bot_l_2_linear_bias_grad tensor
    const unsigned bot_l_2_linear_bias_grad_sizes[] = {512,};
    uint64_t bot_l_2_linear_bias_grad_dram;
    unsigned bot_l_2_linear_bias_grad_size = 512;
    unsigned bot_l_2_linear_bias_grad_size_in_bytes = bot_l_2_linear_bias_grad_size * sizeof(float) ;
    status = hbmAlloc(bot_l_2_linear_bias_grad_size_in_bytes, &bot_l_2_linear_bias_grad_dram, "bot_l_2_linear_bias_grad");
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_bias_grad dram malloc failed!");
    synLaunchTensorInfo bot_l_2_linear_bias_grad_tr_info = {"bot_l_2_linear_bias_grad", bot_l_2_linear_bias_grad_dram};
    UNUSED(bot_l_2_linear_bias_grad_tr_info); // For single op tests
    synTensor bot_l_2_linear_bias_grad = createTensor(1U, syn_type_single, bot_l_2_linear_bias_grad_sizes, true, "bot_l_2_linear_bias_grad");
    UNUSED(bot_l_2_linear_bias_grad); // For single op tests

    synTensor bot_l_2_linear_dedb_out_vec[1] = {bot_l_2_linear_bias_grad};


    status = synNodeCreate(graphHandle, bot_l_2_linear_dedb_in_vec, bot_l_2_linear_dedb_out_vec, 1, 1, (void *)&bot_l_2_linear_dedb_kernel_params, sizeof(bot_l_2_linear_dedb_kernel_params), "reduce_sum_fwd_bf16", "bot_l_2_linear_dedb", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bot_l_2_linear_dedb failed!");

    /*************
     * bot_l_0_relu_bwd node
     * inputs: [bot_l_2_linear_grad_input(128, 1, 1, 512)(dtype=bf16), bot_l_0_relu_output(128, 1, 1, 512)(dtype=bf16)]
     * output: [bot_l_0_relu_grad_input(128, 1, 1, 512)(dtype=bf16)]
     *************/

    synTensor bot_l_0_relu_bwd_in_vec[2] = {bot_l_2_linear_grad_input, bot_l_0_relu_output};


    // create bot_l_0_relu_grad_input tensor
    const unsigned bot_l_0_relu_grad_input_sizes[] = {128, 1, 1, 512};
    synTensor bot_l_0_relu_grad_input = createTensor(4U, syn_type_bf16, bot_l_0_relu_grad_input_sizes, false, "bot_l_0_relu_grad_input");
    UNUSED(bot_l_0_relu_grad_input); // For single op tests

    synTensor bot_l_0_relu_bwd_out_vec[1] = {bot_l_0_relu_grad_input};


    status = synNodeCreate(graphHandle, bot_l_0_relu_bwd_in_vec, bot_l_0_relu_bwd_out_vec, 2, 1, nullptr, 0, "relu_bwd_bf16", "bot_l_0_relu_bwd", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bot_l_0_relu_bwd failed!");

    /*************
     * bot_l_0_linear_dedx node
     * inputs: [bot_l_0_relu_grad_input(128, 1, 1, 512)(dtype=bf16), bot_l_0_linear_weight(1, 1, 13, 512)(dtype=bf16)]
     * output: [bot_l_0_linear_grad_input(128, 1, 1, 13)(dtype=bf16)]
     *************/
    synConvolutionParams bot_l_0_linear_dedx_kernel_params;
    bot_l_0_linear_dedx_kernel_params.dH = 1;
    bot_l_0_linear_dedx_kernel_params.dW = 1;
    bot_l_0_linear_dedx_kernel_params.kH = 1;
    bot_l_0_linear_dedx_kernel_params.kW = 1;
    bot_l_0_linear_dedx_kernel_params.padT = 0;
    bot_l_0_linear_dedx_kernel_params.padB = 0;
    bot_l_0_linear_dedx_kernel_params.padL = 0;
    bot_l_0_linear_dedx_kernel_params.padR = 0;
    bot_l_0_linear_dedx_kernel_params.dilH = 1;
    bot_l_0_linear_dedx_kernel_params.dilW = 1;

    synTensor bot_l_0_linear_dedx_in_vec[2] = {bot_l_0_relu_grad_input, bot_l_0_linear_weight};


    // create bot_l_0_linear_grad_input tensor
    const unsigned bot_l_0_linear_grad_input_sizes[] = {128, 1, 1, 13};
    uint64_t bot_l_0_linear_grad_input_dram;
    unsigned bot_l_0_linear_grad_input_size = 128*1*1*13;
    unsigned bot_l_0_linear_grad_input_size_in_bytes = bot_l_0_linear_grad_input_size * sizeof(bfloat16) ;
    status = hbmAlloc(bot_l_0_linear_grad_input_size_in_bytes, &bot_l_0_linear_grad_input_dram, "bot_l_0_linear_grad_input");
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_grad_input dram malloc failed!");
    synLaunchTensorInfo bot_l_0_linear_grad_input_tr_info = {"bot_l_0_linear_grad_input",
                                                             bot_l_0_linear_grad_input_dram};
    UNUSED(bot_l_0_linear_grad_input_tr_info); // For single op tests
    synTensor bot_l_0_linear_grad_input = createTensor(4U, syn_type_bf16, bot_l_0_linear_grad_input_sizes, true, "bot_l_0_linear_grad_input");
    UNUSED(bot_l_0_linear_grad_input); // For single op tests

    synTensor bot_l_0_linear_dedx_out_vec[1] = {bot_l_0_linear_grad_input};


    status = synNodeCreate(graphHandle, bot_l_0_linear_dedx_in_vec, bot_l_0_linear_dedx_out_vec, 2, 1, (void *)&bot_l_0_linear_dedx_kernel_params, sizeof(bot_l_0_linear_dedx_kernel_params), "dedx", "bot_l_0_linear_dedx", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bot_l_0_linear_dedx failed!");

    /*************
     * bot_l_0_linear_dedw node
     * inputs: [bot_l_0_relu_grad_input(128, 1, 1, 512)(dtype=bf16), X_int(128, 1, 1, 13)(dtype=bf16)]
     * output: [bot_l_0_linear_weight_grad(1, 1, 13, 512)(dtype=float32)]
     *************/
    synConvolutionParams bot_l_0_linear_dedw_kernel_params;
    bot_l_0_linear_dedw_kernel_params.dH = 1;
    bot_l_0_linear_dedw_kernel_params.dW = 1;
    bot_l_0_linear_dedw_kernel_params.kH = 1;
    bot_l_0_linear_dedw_kernel_params.kW = 1;
    bot_l_0_linear_dedw_kernel_params.padT = 0;
    bot_l_0_linear_dedw_kernel_params.padB = 0;
    bot_l_0_linear_dedw_kernel_params.padL = 0;
    bot_l_0_linear_dedw_kernel_params.padR = 0;
    bot_l_0_linear_dedw_kernel_params.dilH = 1;
    bot_l_0_linear_dedw_kernel_params.dilW = 1;

    synTensor bot_l_0_linear_dedw_in_vec[2] = {bot_l_0_relu_grad_input, X_int};


    // create bot_l_0_linear_weight_grad tensor
    const unsigned bot_l_0_linear_weight_grad_sizes[] = {1, 1, 13, 512};
    uint64_t bot_l_0_linear_weight_grad_dram;
    unsigned bot_l_0_linear_weight_grad_size = 1*1*13*512;
    unsigned bot_l_0_linear_weight_grad_size_in_bytes = bot_l_0_linear_weight_grad_size * sizeof(float) ;
    status = hbmAlloc(bot_l_0_linear_weight_grad_size_in_bytes, &bot_l_0_linear_weight_grad_dram, "bot_l_0_linear_weight_grad");
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_weight_grad dram malloc failed!");
    synLaunchTensorInfo bot_l_0_linear_weight_grad_tr_info = {"bot_l_0_linear_weight_grad",
                                                              bot_l_0_linear_weight_grad_dram};
    UNUSED(bot_l_0_linear_weight_grad_tr_info); // For single op tests
    synTensor bot_l_0_linear_weight_grad = createTensor(4U, syn_type_single, bot_l_0_linear_weight_grad_sizes, true, "bot_l_0_linear_weight_grad");
    UNUSED(bot_l_0_linear_weight_grad); // For single op tests

    synTensor bot_l_0_linear_dedw_out_vec[1] = {bot_l_0_linear_weight_grad};


    status = synNodeCreate(graphHandle, bot_l_0_linear_dedw_in_vec, bot_l_0_linear_dedw_out_vec, 2, 1, (void *)&bot_l_0_linear_dedw_kernel_params, sizeof(bot_l_0_linear_dedw_kernel_params), "dedw", "bot_l_0_linear_dedw", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bot_l_0_linear_dedw failed!");

    /*************
     * bot_l_0_linear_dedb_bot_l_0_relu_grad_input_reshape node
     * inputs: [bot_l_0_relu_grad_input(128, 1, 1, 512)(dtype=bf16)]
     * output: [bot_l_0_linear_dedb_bot_l_0_relu_grad_input_tensor_reshape(128, 512)(dtype=bf16)]
     *************/

    synTensor bot_l_0_linear_dedb_bot_l_0_relu_grad_input_reshape_in_vec[1] = {bot_l_0_relu_grad_input};


    // create bot_l_0_linear_dedb_bot_l_0_relu_grad_input_tensor_reshape tensor
    const unsigned bot_l_0_linear_dedb_bot_l_0_relu_grad_input_tensor_reshape_sizes[] = {128, 512};
    synTensor bot_l_0_linear_dedb_bot_l_0_relu_grad_input_tensor_reshape = createTensor(2U, syn_type_bf16, bot_l_0_linear_dedb_bot_l_0_relu_grad_input_tensor_reshape_sizes, false, "bot_l_0_linear_dedb_bot_l_0_relu_grad_input_tensor_reshape");
    UNUSED(bot_l_0_linear_dedb_bot_l_0_relu_grad_input_tensor_reshape); // For single op tests

    synTensor bot_l_0_linear_dedb_bot_l_0_relu_grad_input_reshape_out_vec[1] = {bot_l_0_linear_dedb_bot_l_0_relu_grad_input_tensor_reshape};


    status = synNodeCreate(graphHandle, bot_l_0_linear_dedb_bot_l_0_relu_grad_input_reshape_in_vec, bot_l_0_linear_dedb_bot_l_0_relu_grad_input_reshape_out_vec, 1, 1, nullptr, 0, "reshape", "bot_l_0_linear_dedb_bot_l_0_relu_grad_input_reshape", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bot_l_0_linear_dedb_bot_l_0_relu_grad_input_reshape failed!");

    /*************
     * bot_l_0_linear_dedb node
     * inputs: [bot_l_0_linear_dedb_bot_l_0_relu_grad_input_tensor_reshape(128, 512)(dtype=bf16)]
     * output: [bot_l_0_linear_bias_grad(512,)(dtype=float32)]
     *************/
    ns_Reduction::Params bot_l_0_linear_dedb_kernel_params;
    bot_l_0_linear_dedb_kernel_params.reductionDimension = 1;

    synTensor bot_l_0_linear_dedb_in_vec[1] = {bot_l_0_linear_dedb_bot_l_0_relu_grad_input_tensor_reshape};


    // create bot_l_0_linear_bias_grad tensor
    const unsigned bot_l_0_linear_bias_grad_sizes[] = {512,};
    uint64_t bot_l_0_linear_bias_grad_dram;
    unsigned bot_l_0_linear_bias_grad_size = 512;
    unsigned bot_l_0_linear_bias_grad_size_in_bytes = bot_l_0_linear_bias_grad_size * sizeof(float) ;
    status = hbmAlloc(bot_l_0_linear_bias_grad_size_in_bytes, &bot_l_0_linear_bias_grad_dram, "bot_l_0_linear_bias_grad");
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_bias_grad dram malloc failed!");
    synLaunchTensorInfo bot_l_0_linear_bias_grad_tr_info = {"bot_l_0_linear_bias_grad", bot_l_0_linear_bias_grad_dram};
    UNUSED(bot_l_0_linear_bias_grad_tr_info); // For single op tests
    synTensor bot_l_0_linear_bias_grad = createTensor(1U, syn_type_single, bot_l_0_linear_bias_grad_sizes, true, "bot_l_0_linear_bias_grad");
    UNUSED(bot_l_0_linear_bias_grad); // For single op tests

    synTensor bot_l_0_linear_dedb_out_vec[1] = {bot_l_0_linear_bias_grad};


    status = synNodeCreate(graphHandle, bot_l_0_linear_dedb_in_vec, bot_l_0_linear_dedb_out_vec, 1, 1, (void *)&bot_l_0_linear_dedb_kernel_params, sizeof(bot_l_0_linear_dedb_kernel_params), "reduce_sum_fwd_bf16", "bot_l_0_linear_dedb", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bot_l_0_linear_dedb failed!");


    // generate graph
    LaunchInfo dlrmLaunchInfo = compileAllocateAndLoadGraph(graphHandle);
    // Init tensors data from files

    // init tensor X_int from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, X_int_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/X_int", typed_data, X_int_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, X_int_dram, X_int_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor bot_l_0_linear_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, bot_l_0_linear_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/bot_l_0_linear_weight", typed_data, bot_l_0_linear_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, bot_l_0_linear_weight_dram, bot_l_0_linear_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor bot_l_0_linear_bias from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, bot_l_0_linear_bias_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/bot_l_0_linear_bias", typed_data, bot_l_0_linear_bias_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, bot_l_0_linear_bias_dram, bot_l_0_linear_bias_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor bot_l_2_linear_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, bot_l_2_linear_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/bot_l_2_linear_weight", typed_data, bot_l_2_linear_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, bot_l_2_linear_weight_dram, bot_l_2_linear_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor bot_l_2_linear_bias from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, bot_l_2_linear_bias_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/bot_l_2_linear_bias", typed_data, bot_l_2_linear_bias_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, bot_l_2_linear_bias_dram, bot_l_2_linear_bias_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor bot_l_4_linear_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, bot_l_4_linear_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/bot_l_4_linear_weight", typed_data, bot_l_4_linear_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, bot_l_4_linear_weight_dram, bot_l_4_linear_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor bot_l_4_linear_bias from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, bot_l_4_linear_bias_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/bot_l_4_linear_bias", typed_data, bot_l_4_linear_bias_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, bot_l_4_linear_bias_dram, bot_l_4_linear_bias_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_indices_0 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_indices_0_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_indices_0", typed_data, lS_indices_0_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_indices_0_dram, lS_indices_0_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_offset_0 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_offset_0_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_offset_0", typed_data, lS_offset_0_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_offset_0_dram, lS_offset_0_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_0_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_0_embbag_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_0_embbag_weight", typed_data, emb_0_embbag_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_0_embbag_weight_dram, emb_0_embbag_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_indices_1 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_indices_1_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_indices_1", typed_data, lS_indices_1_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_indices_1_dram, lS_indices_1_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_offset_1 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_offset_1_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_offset_1", typed_data, lS_offset_1_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_offset_1_dram, lS_offset_1_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_1_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_1_embbag_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_1_embbag_weight", typed_data, emb_1_embbag_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_1_embbag_weight_dram, emb_1_embbag_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_indices_2 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_indices_2_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_indices_2", typed_data, lS_indices_2_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_indices_2_dram, lS_indices_2_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_offset_2 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_offset_2_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_offset_2", typed_data, lS_offset_2_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_offset_2_dram, lS_offset_2_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_2_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_2_embbag_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_2_embbag_weight", typed_data, emb_2_embbag_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_2_embbag_weight_dram, emb_2_embbag_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_indices_3 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_indices_3_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_indices_3", typed_data, lS_indices_3_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_indices_3_dram, lS_indices_3_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_offset_3 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_offset_3_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_offset_3", typed_data, lS_offset_3_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_offset_3_dram, lS_offset_3_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_3_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_3_embbag_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_3_embbag_weight", typed_data, emb_3_embbag_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_3_embbag_weight_dram, emb_3_embbag_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_indices_4 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_indices_4_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_indices_4", typed_data, lS_indices_4_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_indices_4_dram, lS_indices_4_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_offset_4 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_offset_4_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_offset_4", typed_data, lS_offset_4_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_offset_4_dram, lS_offset_4_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_4_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_4_embbag_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_4_embbag_weight", typed_data, emb_4_embbag_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_4_embbag_weight_dram, emb_4_embbag_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_indices_5 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_indices_5_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_indices_5", typed_data, lS_indices_5_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_indices_5_dram, lS_indices_5_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_offset_5 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_offset_5_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_offset_5", typed_data, lS_offset_5_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_offset_5_dram, lS_offset_5_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_5_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_5_embbag_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_5_embbag_weight", typed_data, emb_5_embbag_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_5_embbag_weight_dram, emb_5_embbag_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_indices_6 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_indices_6_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_indices_6", typed_data, lS_indices_6_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_indices_6_dram, lS_indices_6_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_offset_6 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_offset_6_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_offset_6", typed_data, lS_offset_6_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_offset_6_dram, lS_offset_6_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_6_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_6_embbag_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_6_embbag_weight", typed_data, emb_6_embbag_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_6_embbag_weight_dram, emb_6_embbag_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_indices_7 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_indices_7_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_indices_7", typed_data, lS_indices_7_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_indices_7_dram, lS_indices_7_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_offset_7 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_offset_7_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_offset_7", typed_data, lS_offset_7_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_offset_7_dram, lS_offset_7_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_7_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_7_embbag_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_7_embbag_weight", typed_data, emb_7_embbag_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_7_embbag_weight_dram, emb_7_embbag_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_indices_8 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_indices_8_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_indices_8", typed_data, lS_indices_8_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_indices_8_dram, lS_indices_8_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_offset_8 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_offset_8_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_offset_8", typed_data, lS_offset_8_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_offset_8_dram, lS_offset_8_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_8_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_8_embbag_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_8_embbag_weight", typed_data, emb_8_embbag_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_8_embbag_weight_dram, emb_8_embbag_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_indices_9 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_indices_9_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_indices_9", typed_data, lS_indices_9_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_indices_9_dram, lS_indices_9_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_offset_9 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_offset_9_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_offset_9", typed_data, lS_offset_9_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_offset_9_dram, lS_offset_9_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_9_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_9_embbag_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_9_embbag_weight", typed_data, emb_9_embbag_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_9_embbag_weight_dram, emb_9_embbag_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_indices_10 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_indices_10_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_indices_10", typed_data, lS_indices_10_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_indices_10_dram, lS_indices_10_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_offset_10 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_offset_10_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_offset_10", typed_data, lS_offset_10_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_offset_10_dram, lS_offset_10_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_10_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_10_embbag_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_10_embbag_weight", typed_data, emb_10_embbag_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_10_embbag_weight_dram, emb_10_embbag_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_indices_11 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_indices_11_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_indices_11", typed_data, lS_indices_11_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_indices_11_dram, lS_indices_11_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_offset_11 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_offset_11_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_offset_11", typed_data, lS_offset_11_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_offset_11_dram, lS_offset_11_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_11_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_11_embbag_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_11_embbag_weight", typed_data, emb_11_embbag_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_11_embbag_weight_dram, emb_11_embbag_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_indices_12 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_indices_12_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_indices_12", typed_data, lS_indices_12_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_indices_12_dram, lS_indices_12_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_offset_12 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_offset_12_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_offset_12", typed_data, lS_offset_12_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_offset_12_dram, lS_offset_12_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_12_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_12_embbag_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_12_embbag_weight", typed_data, emb_12_embbag_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_12_embbag_weight_dram, emb_12_embbag_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_indices_13 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_indices_13_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_indices_13", typed_data, lS_indices_13_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_indices_13_dram, lS_indices_13_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_offset_13 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_offset_13_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_offset_13", typed_data, lS_offset_13_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_offset_13_dram, lS_offset_13_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_13_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_13_embbag_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_13_embbag_weight", typed_data, emb_13_embbag_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_13_embbag_weight_dram, emb_13_embbag_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_indices_14 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_indices_14_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_indices_14", typed_data, lS_indices_14_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_indices_14_dram, lS_indices_14_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_offset_14 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_offset_14_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_offset_14", typed_data, lS_offset_14_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_offset_14_dram, lS_offset_14_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_14_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_14_embbag_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_14_embbag_weight", typed_data, emb_14_embbag_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_14_embbag_weight_dram, emb_14_embbag_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_indices_15 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_indices_15_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_indices_15", typed_data, lS_indices_15_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_indices_15_dram, lS_indices_15_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_offset_15 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_offset_15_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_offset_15", typed_data, lS_offset_15_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_offset_15_dram, lS_offset_15_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_15_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_15_embbag_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_15_embbag_weight", typed_data, emb_15_embbag_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_15_embbag_weight_dram, emb_15_embbag_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_indices_16 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_indices_16_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_indices_16", typed_data, lS_indices_16_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_indices_16_dram, lS_indices_16_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_offset_16 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_offset_16_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_offset_16", typed_data, lS_offset_16_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_offset_16_dram, lS_offset_16_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_16_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_16_embbag_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_16_embbag_weight", typed_data, emb_16_embbag_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_16_embbag_weight_dram, emb_16_embbag_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_indices_17 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_indices_17_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_indices_17", typed_data, lS_indices_17_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_indices_17_dram, lS_indices_17_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_offset_17 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_offset_17_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_offset_17", typed_data, lS_offset_17_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_offset_17_dram, lS_offset_17_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_17_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_17_embbag_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_17_embbag_weight", typed_data, emb_17_embbag_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_17_embbag_weight_dram, emb_17_embbag_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_indices_18 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_indices_18_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_indices_18", typed_data, lS_indices_18_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_indices_18_dram, lS_indices_18_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_offset_18 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_offset_18_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_offset_18", typed_data, lS_offset_18_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_offset_18_dram, lS_offset_18_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_18_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_18_embbag_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_18_embbag_weight", typed_data, emb_18_embbag_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_18_embbag_weight_dram, emb_18_embbag_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_indices_19 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_indices_19_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_indices_19", typed_data, lS_indices_19_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_indices_19_dram, lS_indices_19_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_offset_19 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_offset_19_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_offset_19", typed_data, lS_offset_19_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_offset_19_dram, lS_offset_19_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_19_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_19_embbag_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_19_embbag_weight", typed_data, emb_19_embbag_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_19_embbag_weight_dram, emb_19_embbag_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_indices_20 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_indices_20_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_indices_20", typed_data, lS_indices_20_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_indices_20_dram, lS_indices_20_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_offset_20 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_offset_20_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_offset_20", typed_data, lS_offset_20_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_offset_20_dram, lS_offset_20_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_20_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_20_embbag_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_20_embbag_weight", typed_data, emb_20_embbag_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_20_embbag_weight_dram, emb_20_embbag_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_indices_21 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_indices_21_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_indices_21", typed_data, lS_indices_21_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_indices_21_dram, lS_indices_21_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_offset_21 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_offset_21_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_offset_21", typed_data, lS_offset_21_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_offset_21_dram, lS_offset_21_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_21_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_21_embbag_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_21_embbag_weight", typed_data, emb_21_embbag_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_21_embbag_weight_dram, emb_21_embbag_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_indices_22 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_indices_22_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_indices_22", typed_data, lS_indices_22_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_indices_22_dram, lS_indices_22_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_offset_22 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_offset_22_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_offset_22", typed_data, lS_offset_22_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_offset_22_dram, lS_offset_22_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_22_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_22_embbag_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_22_embbag_weight", typed_data, emb_22_embbag_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_22_embbag_weight_dram, emb_22_embbag_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_indices_23 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_indices_23_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_indices_23", typed_data, lS_indices_23_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_indices_23_dram, lS_indices_23_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_offset_23 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_offset_23_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_offset_23", typed_data, lS_offset_23_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_offset_23_dram, lS_offset_23_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_23_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_23_embbag_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_23_embbag_weight", typed_data, emb_23_embbag_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_23_embbag_weight_dram, emb_23_embbag_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_indices_24 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_indices_24_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_indices_24", typed_data, lS_indices_24_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_indices_24_dram, lS_indices_24_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_offset_24 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_offset_24_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_offset_24", typed_data, lS_offset_24_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_offset_24_dram, lS_offset_24_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_24_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_24_embbag_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_24_embbag_weight", typed_data, emb_24_embbag_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_24_embbag_weight_dram, emb_24_embbag_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_indices_25 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_indices_25_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_indices_25", typed_data, lS_indices_25_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_indices_25_dram, lS_indices_25_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor lS_offset_25 from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, lS_offset_25_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/lS_offset_25", typed_data, lS_offset_25_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, lS_offset_25_dram, lS_offset_25_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_25_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_25_embbag_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_25_embbag_weight", typed_data, emb_25_embbag_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_25_embbag_weight_dram, emb_25_embbag_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor tril_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, tril_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/tril_indices", typed_data, tril_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, tril_indices_dram, tril_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor top_l_0_linear_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, top_l_0_linear_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_0_linear_weight", typed_data, top_l_0_linear_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, top_l_0_linear_weight_dram, top_l_0_linear_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor top_l_0_linear_bias from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, top_l_0_linear_bias_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_0_linear_bias", typed_data, top_l_0_linear_bias_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, top_l_0_linear_bias_dram, top_l_0_linear_bias_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor top_l_2_linear_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, top_l_2_linear_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_2_linear_weight", typed_data, top_l_2_linear_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, top_l_2_linear_weight_dram, top_l_2_linear_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor top_l_2_linear_bias from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, top_l_2_linear_bias_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_2_linear_bias", typed_data, top_l_2_linear_bias_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, top_l_2_linear_bias_dram, top_l_2_linear_bias_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor top_l_4_linear_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, top_l_4_linear_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_4_linear_weight", typed_data, top_l_4_linear_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, top_l_4_linear_weight_dram, top_l_4_linear_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor top_l_4_linear_bias from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, top_l_4_linear_bias_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_4_linear_bias", typed_data, top_l_4_linear_bias_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, top_l_4_linear_bias_dram, top_l_4_linear_bias_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor top_l_6_linear_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, top_l_6_linear_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_6_linear_weight", typed_data, top_l_6_linear_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, top_l_6_linear_weight_dram, top_l_6_linear_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor top_l_6_linear_bias from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, top_l_6_linear_bias_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_6_linear_bias", typed_data, top_l_6_linear_bias_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, top_l_6_linear_bias_dram, top_l_6_linear_bias_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor top_l_8_linear_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, top_l_8_linear_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_8_linear_weight", typed_data, top_l_8_linear_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, top_l_8_linear_weight_dram, top_l_8_linear_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor top_l_8_linear_bias from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, top_l_8_linear_bias_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_8_linear_bias", typed_data, top_l_8_linear_bias_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, top_l_8_linear_bias_dram, top_l_8_linear_bias_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor top_l_10_linear_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, top_l_10_linear_weight_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_10_linear_weight", typed_data, top_l_10_linear_weight_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, top_l_10_linear_weight_dram, top_l_10_linear_weight_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor top_l_10_linear_bias from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, top_l_10_linear_bias_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_10_linear_bias", typed_data, top_l_10_linear_bias_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, top_l_10_linear_bias_dram, top_l_10_linear_bias_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor target from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, target_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        bfloat16* typed_data = static_cast<bfloat16*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/target", typed_data, target_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, target_dram, target_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor tril_grad_buffer from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, tril_grad_buffer_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        memset(data, 0, tril_grad_buffer_size_in_bytes);
        downloadTensorData(data, tril_grad_buffer_dram, tril_grad_buffer_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor tril_indices_broadcast from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, tril_indices_broadcast_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/tril_indices_broadcast", typed_data, tril_indices_broadcast_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, tril_indices_broadcast_dram, tril_indices_broadcast_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_0_embbag_dedw_grad_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_0_embbag_dedw_grad_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_0_embbag_dedw_grad_indices", typed_data, emb_0_embbag_dedw_grad_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_0_embbag_dedw_grad_indices_dram, emb_0_embbag_dedw_grad_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_0_embbag_dedw_lengths from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_0_embbag_dedw_lengths_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_0_embbag_dedw_lengths", typed_data, emb_0_embbag_dedw_lengths_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_0_embbag_dedw_lengths_dram, emb_0_embbag_dedw_lengths_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_0_embbag_valid_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_0_embbag_valid_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_0_embbag_valid_indices", typed_data, emb_0_embbag_valid_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_0_embbag_valid_indices_dram, emb_0_embbag_valid_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_0_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_0_embbag_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_0_embbag_weight", typed_data, emb_0_embbag_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_0_embbag_weight_golden_dram, emb_0_embbag_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_0_embbag_momentum from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_0_embbag_momentum_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_0_embbag_momentum", typed_data, emb_0_embbag_momentum_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_0_embbag_momentum_dram, emb_0_embbag_momentum_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_0_embbag_dedw_param_table_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_0_embbag_dedw_param_table_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_0_embbag_dedw_param_table_indices", typed_data, emb_0_embbag_dedw_param_table_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_0_embbag_dedw_param_table_indices_dram, emb_0_embbag_dedw_param_table_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_0_offset_shape from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_0_offset_shape_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_0_offset_shape", typed_data, emb_0_offset_shape_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_0_offset_shape_dram, emb_0_offset_shape_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_0_embbag_timestamp from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_0_embbag_timestamp_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_0_embbag_timestamp", typed_data, emb_0_embbag_timestamp_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_0_embbag_timestamp_dram, emb_0_embbag_timestamp_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_0_embbag_rate from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_0_embbag_rate_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_0_embbag_rate", typed_data, emb_0_embbag_rate_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_0_embbag_rate_dram, emb_0_embbag_rate_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_1_embbag_dedw_grad_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_1_embbag_dedw_grad_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_1_embbag_dedw_grad_indices", typed_data, emb_1_embbag_dedw_grad_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_1_embbag_dedw_grad_indices_dram, emb_1_embbag_dedw_grad_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_1_embbag_dedw_lengths from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_1_embbag_dedw_lengths_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_1_embbag_dedw_lengths", typed_data, emb_1_embbag_dedw_lengths_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_1_embbag_dedw_lengths_dram, emb_1_embbag_dedw_lengths_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_1_embbag_valid_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_1_embbag_valid_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_1_embbag_valid_indices", typed_data, emb_1_embbag_valid_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_1_embbag_valid_indices_dram, emb_1_embbag_valid_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_1_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_1_embbag_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_1_embbag_weight", typed_data, emb_1_embbag_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_1_embbag_weight_golden_dram, emb_1_embbag_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_1_embbag_momentum from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_1_embbag_momentum_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_1_embbag_momentum", typed_data, emb_1_embbag_momentum_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_1_embbag_momentum_dram, emb_1_embbag_momentum_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_1_embbag_dedw_param_table_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_1_embbag_dedw_param_table_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_1_embbag_dedw_param_table_indices", typed_data, emb_1_embbag_dedw_param_table_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_1_embbag_dedw_param_table_indices_dram, emb_1_embbag_dedw_param_table_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_1_offset_shape from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_1_offset_shape_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_1_offset_shape", typed_data, emb_1_offset_shape_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_1_offset_shape_dram, emb_1_offset_shape_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_2_embbag_dedw_grad_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_2_embbag_dedw_grad_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_2_embbag_dedw_grad_indices", typed_data, emb_2_embbag_dedw_grad_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_2_embbag_dedw_grad_indices_dram, emb_2_embbag_dedw_grad_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_2_embbag_dedw_lengths from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_2_embbag_dedw_lengths_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_2_embbag_dedw_lengths", typed_data, emb_2_embbag_dedw_lengths_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_2_embbag_dedw_lengths_dram, emb_2_embbag_dedw_lengths_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_2_embbag_valid_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_2_embbag_valid_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_2_embbag_valid_indices", typed_data, emb_2_embbag_valid_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_2_embbag_valid_indices_dram, emb_2_embbag_valid_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_2_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_2_embbag_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_2_embbag_weight", typed_data, emb_2_embbag_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_2_embbag_weight_golden_dram, emb_2_embbag_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_2_embbag_momentum from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_2_embbag_momentum_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_2_embbag_momentum", typed_data, emb_2_embbag_momentum_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_2_embbag_momentum_dram, emb_2_embbag_momentum_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_2_embbag_dedw_param_table_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_2_embbag_dedw_param_table_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_2_embbag_dedw_param_table_indices", typed_data, emb_2_embbag_dedw_param_table_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_2_embbag_dedw_param_table_indices_dram, emb_2_embbag_dedw_param_table_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_2_offset_shape from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_2_offset_shape_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_2_offset_shape", typed_data, emb_2_offset_shape_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_2_offset_shape_dram, emb_2_offset_shape_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_3_embbag_dedw_grad_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_3_embbag_dedw_grad_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_3_embbag_dedw_grad_indices", typed_data, emb_3_embbag_dedw_grad_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_3_embbag_dedw_grad_indices_dram, emb_3_embbag_dedw_grad_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_3_embbag_dedw_lengths from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_3_embbag_dedw_lengths_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_3_embbag_dedw_lengths", typed_data, emb_3_embbag_dedw_lengths_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_3_embbag_dedw_lengths_dram, emb_3_embbag_dedw_lengths_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_3_embbag_valid_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_3_embbag_valid_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_3_embbag_valid_indices", typed_data, emb_3_embbag_valid_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_3_embbag_valid_indices_dram, emb_3_embbag_valid_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_3_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_3_embbag_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_3_embbag_weight", typed_data, emb_3_embbag_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_3_embbag_weight_golden_dram, emb_3_embbag_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_3_embbag_momentum from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_3_embbag_momentum_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_3_embbag_momentum", typed_data, emb_3_embbag_momentum_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_3_embbag_momentum_dram, emb_3_embbag_momentum_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_3_embbag_dedw_param_table_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_3_embbag_dedw_param_table_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_3_embbag_dedw_param_table_indices", typed_data, emb_3_embbag_dedw_param_table_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_3_embbag_dedw_param_table_indices_dram, emb_3_embbag_dedw_param_table_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_3_offset_shape from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_3_offset_shape_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_3_offset_shape", typed_data, emb_3_offset_shape_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_3_offset_shape_dram, emb_3_offset_shape_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_4_embbag_dedw_grad_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_4_embbag_dedw_grad_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_4_embbag_dedw_grad_indices", typed_data, emb_4_embbag_dedw_grad_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_4_embbag_dedw_grad_indices_dram, emb_4_embbag_dedw_grad_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_4_embbag_dedw_lengths from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_4_embbag_dedw_lengths_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_4_embbag_dedw_lengths", typed_data, emb_4_embbag_dedw_lengths_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_4_embbag_dedw_lengths_dram, emb_4_embbag_dedw_lengths_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_4_embbag_valid_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_4_embbag_valid_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_4_embbag_valid_indices", typed_data, emb_4_embbag_valid_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_4_embbag_valid_indices_dram, emb_4_embbag_valid_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_4_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_4_embbag_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_4_embbag_weight", typed_data, emb_4_embbag_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_4_embbag_weight_golden_dram, emb_4_embbag_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_4_embbag_momentum from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_4_embbag_momentum_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_4_embbag_momentum", typed_data, emb_4_embbag_momentum_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_4_embbag_momentum_dram, emb_4_embbag_momentum_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_4_embbag_dedw_param_table_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_4_embbag_dedw_param_table_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_4_embbag_dedw_param_table_indices", typed_data, emb_4_embbag_dedw_param_table_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_4_embbag_dedw_param_table_indices_dram, emb_4_embbag_dedw_param_table_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_4_offset_shape from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_4_offset_shape_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_4_offset_shape", typed_data, emb_4_offset_shape_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_4_offset_shape_dram, emb_4_offset_shape_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_5_embbag_dedw_grad_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_5_embbag_dedw_grad_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_5_embbag_dedw_grad_indices", typed_data, emb_5_embbag_dedw_grad_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_5_embbag_dedw_grad_indices_dram, emb_5_embbag_dedw_grad_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_5_embbag_dedw_lengths from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_5_embbag_dedw_lengths_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_5_embbag_dedw_lengths", typed_data, emb_5_embbag_dedw_lengths_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_5_embbag_dedw_lengths_dram, emb_5_embbag_dedw_lengths_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_5_embbag_valid_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_5_embbag_valid_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_5_embbag_valid_indices", typed_data, emb_5_embbag_valid_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_5_embbag_valid_indices_dram, emb_5_embbag_valid_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_5_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_5_embbag_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_5_embbag_weight", typed_data, emb_5_embbag_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_5_embbag_weight_golden_dram, emb_5_embbag_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_5_embbag_momentum from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_5_embbag_momentum_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_5_embbag_momentum", typed_data, emb_5_embbag_momentum_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_5_embbag_momentum_dram, emb_5_embbag_momentum_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_5_embbag_dedw_param_table_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_5_embbag_dedw_param_table_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_5_embbag_dedw_param_table_indices", typed_data, emb_5_embbag_dedw_param_table_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_5_embbag_dedw_param_table_indices_dram, emb_5_embbag_dedw_param_table_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_5_offset_shape from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_5_offset_shape_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_5_offset_shape", typed_data, emb_5_offset_shape_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_5_offset_shape_dram, emb_5_offset_shape_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_6_embbag_dedw_grad_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_6_embbag_dedw_grad_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_6_embbag_dedw_grad_indices", typed_data, emb_6_embbag_dedw_grad_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_6_embbag_dedw_grad_indices_dram, emb_6_embbag_dedw_grad_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_6_embbag_dedw_lengths from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_6_embbag_dedw_lengths_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_6_embbag_dedw_lengths", typed_data, emb_6_embbag_dedw_lengths_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_6_embbag_dedw_lengths_dram, emb_6_embbag_dedw_lengths_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_6_embbag_valid_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_6_embbag_valid_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_6_embbag_valid_indices", typed_data, emb_6_embbag_valid_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_6_embbag_valid_indices_dram, emb_6_embbag_valid_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_6_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_6_embbag_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_6_embbag_weight", typed_data, emb_6_embbag_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_6_embbag_weight_golden_dram, emb_6_embbag_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_6_embbag_momentum from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_6_embbag_momentum_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_6_embbag_momentum", typed_data, emb_6_embbag_momentum_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_6_embbag_momentum_dram, emb_6_embbag_momentum_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_6_embbag_dedw_param_table_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_6_embbag_dedw_param_table_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_6_embbag_dedw_param_table_indices", typed_data, emb_6_embbag_dedw_param_table_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_6_embbag_dedw_param_table_indices_dram, emb_6_embbag_dedw_param_table_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_6_offset_shape from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_6_offset_shape_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_6_offset_shape", typed_data, emb_6_offset_shape_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_6_offset_shape_dram, emb_6_offset_shape_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_7_embbag_dedw_grad_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_7_embbag_dedw_grad_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_7_embbag_dedw_grad_indices", typed_data, emb_7_embbag_dedw_grad_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_7_embbag_dedw_grad_indices_dram, emb_7_embbag_dedw_grad_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_7_embbag_dedw_lengths from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_7_embbag_dedw_lengths_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_7_embbag_dedw_lengths", typed_data, emb_7_embbag_dedw_lengths_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_7_embbag_dedw_lengths_dram, emb_7_embbag_dedw_lengths_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_7_embbag_valid_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_7_embbag_valid_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_7_embbag_valid_indices", typed_data, emb_7_embbag_valid_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_7_embbag_valid_indices_dram, emb_7_embbag_valid_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_7_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_7_embbag_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_7_embbag_weight", typed_data, emb_7_embbag_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_7_embbag_weight_golden_dram, emb_7_embbag_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_7_embbag_momentum from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_7_embbag_momentum_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_7_embbag_momentum", typed_data, emb_7_embbag_momentum_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_7_embbag_momentum_dram, emb_7_embbag_momentum_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_7_embbag_dedw_param_table_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_7_embbag_dedw_param_table_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_7_embbag_dedw_param_table_indices", typed_data, emb_7_embbag_dedw_param_table_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_7_embbag_dedw_param_table_indices_dram, emb_7_embbag_dedw_param_table_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_7_offset_shape from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_7_offset_shape_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_7_offset_shape", typed_data, emb_7_offset_shape_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_7_offset_shape_dram, emb_7_offset_shape_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_8_embbag_dedw_grad_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_8_embbag_dedw_grad_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_8_embbag_dedw_grad_indices", typed_data, emb_8_embbag_dedw_grad_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_8_embbag_dedw_grad_indices_dram, emb_8_embbag_dedw_grad_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_8_embbag_dedw_lengths from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_8_embbag_dedw_lengths_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_8_embbag_dedw_lengths", typed_data, emb_8_embbag_dedw_lengths_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_8_embbag_dedw_lengths_dram, emb_8_embbag_dedw_lengths_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_8_embbag_valid_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_8_embbag_valid_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_8_embbag_valid_indices", typed_data, emb_8_embbag_valid_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_8_embbag_valid_indices_dram, emb_8_embbag_valid_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_8_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_8_embbag_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_8_embbag_weight", typed_data, emb_8_embbag_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_8_embbag_weight_golden_dram, emb_8_embbag_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_8_embbag_momentum from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_8_embbag_momentum_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_8_embbag_momentum", typed_data, emb_8_embbag_momentum_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_8_embbag_momentum_dram, emb_8_embbag_momentum_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_8_embbag_dedw_param_table_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_8_embbag_dedw_param_table_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_8_embbag_dedw_param_table_indices", typed_data, emb_8_embbag_dedw_param_table_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_8_embbag_dedw_param_table_indices_dram, emb_8_embbag_dedw_param_table_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_8_offset_shape from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_8_offset_shape_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_8_offset_shape", typed_data, emb_8_offset_shape_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_8_offset_shape_dram, emb_8_offset_shape_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_9_embbag_dedw_grad_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_9_embbag_dedw_grad_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_9_embbag_dedw_grad_indices", typed_data, emb_9_embbag_dedw_grad_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_9_embbag_dedw_grad_indices_dram, emb_9_embbag_dedw_grad_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_9_embbag_dedw_lengths from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_9_embbag_dedw_lengths_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_9_embbag_dedw_lengths", typed_data, emb_9_embbag_dedw_lengths_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_9_embbag_dedw_lengths_dram, emb_9_embbag_dedw_lengths_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_9_embbag_valid_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_9_embbag_valid_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_9_embbag_valid_indices", typed_data, emb_9_embbag_valid_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_9_embbag_valid_indices_dram, emb_9_embbag_valid_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_9_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_9_embbag_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_9_embbag_weight", typed_data, emb_9_embbag_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_9_embbag_weight_golden_dram, emb_9_embbag_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_9_embbag_momentum from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_9_embbag_momentum_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_9_embbag_momentum", typed_data, emb_9_embbag_momentum_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_9_embbag_momentum_dram, emb_9_embbag_momentum_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_9_embbag_dedw_param_table_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_9_embbag_dedw_param_table_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_9_embbag_dedw_param_table_indices", typed_data, emb_9_embbag_dedw_param_table_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_9_embbag_dedw_param_table_indices_dram, emb_9_embbag_dedw_param_table_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_9_offset_shape from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_9_offset_shape_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_9_offset_shape", typed_data, emb_9_offset_shape_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_9_offset_shape_dram, emb_9_offset_shape_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_10_embbag_dedw_grad_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_10_embbag_dedw_grad_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_10_embbag_dedw_grad_indices", typed_data, emb_10_embbag_dedw_grad_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_10_embbag_dedw_grad_indices_dram, emb_10_embbag_dedw_grad_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_10_embbag_dedw_lengths from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_10_embbag_dedw_lengths_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_10_embbag_dedw_lengths", typed_data, emb_10_embbag_dedw_lengths_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_10_embbag_dedw_lengths_dram, emb_10_embbag_dedw_lengths_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_10_embbag_valid_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_10_embbag_valid_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_10_embbag_valid_indices", typed_data, emb_10_embbag_valid_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_10_embbag_valid_indices_dram, emb_10_embbag_valid_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_10_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_10_embbag_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_10_embbag_weight", typed_data, emb_10_embbag_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_10_embbag_weight_golden_dram, emb_10_embbag_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_10_embbag_momentum from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_10_embbag_momentum_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_10_embbag_momentum", typed_data, emb_10_embbag_momentum_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_10_embbag_momentum_dram, emb_10_embbag_momentum_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_10_embbag_dedw_param_table_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_10_embbag_dedw_param_table_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_10_embbag_dedw_param_table_indices", typed_data, emb_10_embbag_dedw_param_table_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_10_embbag_dedw_param_table_indices_dram, emb_10_embbag_dedw_param_table_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_10_offset_shape from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_10_offset_shape_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_10_offset_shape", typed_data, emb_10_offset_shape_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_10_offset_shape_dram, emb_10_offset_shape_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_11_embbag_dedw_grad_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_11_embbag_dedw_grad_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_11_embbag_dedw_grad_indices", typed_data, emb_11_embbag_dedw_grad_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_11_embbag_dedw_grad_indices_dram, emb_11_embbag_dedw_grad_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_11_embbag_dedw_lengths from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_11_embbag_dedw_lengths_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_11_embbag_dedw_lengths", typed_data, emb_11_embbag_dedw_lengths_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_11_embbag_dedw_lengths_dram, emb_11_embbag_dedw_lengths_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_11_embbag_valid_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_11_embbag_valid_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_11_embbag_valid_indices", typed_data, emb_11_embbag_valid_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_11_embbag_valid_indices_dram, emb_11_embbag_valid_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_11_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_11_embbag_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_11_embbag_weight", typed_data, emb_11_embbag_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_11_embbag_weight_golden_dram, emb_11_embbag_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_11_embbag_momentum from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_11_embbag_momentum_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_11_embbag_momentum", typed_data, emb_11_embbag_momentum_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_11_embbag_momentum_dram, emb_11_embbag_momentum_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_11_embbag_dedw_param_table_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_11_embbag_dedw_param_table_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_11_embbag_dedw_param_table_indices", typed_data, emb_11_embbag_dedw_param_table_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_11_embbag_dedw_param_table_indices_dram, emb_11_embbag_dedw_param_table_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_11_offset_shape from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_11_offset_shape_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_11_offset_shape", typed_data, emb_11_offset_shape_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_11_offset_shape_dram, emb_11_offset_shape_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_12_embbag_dedw_grad_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_12_embbag_dedw_grad_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_12_embbag_dedw_grad_indices", typed_data, emb_12_embbag_dedw_grad_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_12_embbag_dedw_grad_indices_dram, emb_12_embbag_dedw_grad_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_12_embbag_dedw_lengths from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_12_embbag_dedw_lengths_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_12_embbag_dedw_lengths", typed_data, emb_12_embbag_dedw_lengths_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_12_embbag_dedw_lengths_dram, emb_12_embbag_dedw_lengths_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_12_embbag_valid_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_12_embbag_valid_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_12_embbag_valid_indices", typed_data, emb_12_embbag_valid_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_12_embbag_valid_indices_dram, emb_12_embbag_valid_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_12_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_12_embbag_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_12_embbag_weight", typed_data, emb_12_embbag_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_12_embbag_weight_golden_dram, emb_12_embbag_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_12_embbag_momentum from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_12_embbag_momentum_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_12_embbag_momentum", typed_data, emb_12_embbag_momentum_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_12_embbag_momentum_dram, emb_12_embbag_momentum_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_12_embbag_dedw_param_table_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_12_embbag_dedw_param_table_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_12_embbag_dedw_param_table_indices", typed_data, emb_12_embbag_dedw_param_table_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_12_embbag_dedw_param_table_indices_dram, emb_12_embbag_dedw_param_table_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_12_offset_shape from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_12_offset_shape_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_12_offset_shape", typed_data, emb_12_offset_shape_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_12_offset_shape_dram, emb_12_offset_shape_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_13_embbag_dedw_grad_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_13_embbag_dedw_grad_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_13_embbag_dedw_grad_indices", typed_data, emb_13_embbag_dedw_grad_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_13_embbag_dedw_grad_indices_dram, emb_13_embbag_dedw_grad_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_13_embbag_dedw_lengths from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_13_embbag_dedw_lengths_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_13_embbag_dedw_lengths", typed_data, emb_13_embbag_dedw_lengths_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_13_embbag_dedw_lengths_dram, emb_13_embbag_dedw_lengths_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_13_embbag_valid_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_13_embbag_valid_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_13_embbag_valid_indices", typed_data, emb_13_embbag_valid_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_13_embbag_valid_indices_dram, emb_13_embbag_valid_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_13_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_13_embbag_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_13_embbag_weight", typed_data, emb_13_embbag_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_13_embbag_weight_golden_dram, emb_13_embbag_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_13_embbag_momentum from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_13_embbag_momentum_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_13_embbag_momentum", typed_data, emb_13_embbag_momentum_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_13_embbag_momentum_dram, emb_13_embbag_momentum_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_13_embbag_dedw_param_table_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_13_embbag_dedw_param_table_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_13_embbag_dedw_param_table_indices", typed_data, emb_13_embbag_dedw_param_table_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_13_embbag_dedw_param_table_indices_dram, emb_13_embbag_dedw_param_table_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_13_offset_shape from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_13_offset_shape_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_13_offset_shape", typed_data, emb_13_offset_shape_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_13_offset_shape_dram, emb_13_offset_shape_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_14_embbag_dedw_grad_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_14_embbag_dedw_grad_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_14_embbag_dedw_grad_indices", typed_data, emb_14_embbag_dedw_grad_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_14_embbag_dedw_grad_indices_dram, emb_14_embbag_dedw_grad_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_14_embbag_dedw_lengths from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_14_embbag_dedw_lengths_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_14_embbag_dedw_lengths", typed_data, emb_14_embbag_dedw_lengths_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_14_embbag_dedw_lengths_dram, emb_14_embbag_dedw_lengths_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_14_embbag_valid_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_14_embbag_valid_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_14_embbag_valid_indices", typed_data, emb_14_embbag_valid_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_14_embbag_valid_indices_dram, emb_14_embbag_valid_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_14_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_14_embbag_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_14_embbag_weight", typed_data, emb_14_embbag_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_14_embbag_weight_golden_dram, emb_14_embbag_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_14_embbag_momentum from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_14_embbag_momentum_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_14_embbag_momentum", typed_data, emb_14_embbag_momentum_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_14_embbag_momentum_dram, emb_14_embbag_momentum_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_14_embbag_dedw_param_table_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_14_embbag_dedw_param_table_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_14_embbag_dedw_param_table_indices", typed_data, emb_14_embbag_dedw_param_table_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_14_embbag_dedw_param_table_indices_dram, emb_14_embbag_dedw_param_table_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_14_offset_shape from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_14_offset_shape_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_14_offset_shape", typed_data, emb_14_offset_shape_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_14_offset_shape_dram, emb_14_offset_shape_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_15_embbag_dedw_grad_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_15_embbag_dedw_grad_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_15_embbag_dedw_grad_indices", typed_data, emb_15_embbag_dedw_grad_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_15_embbag_dedw_grad_indices_dram, emb_15_embbag_dedw_grad_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_15_embbag_dedw_lengths from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_15_embbag_dedw_lengths_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_15_embbag_dedw_lengths", typed_data, emb_15_embbag_dedw_lengths_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_15_embbag_dedw_lengths_dram, emb_15_embbag_dedw_lengths_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_15_embbag_valid_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_15_embbag_valid_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_15_embbag_valid_indices", typed_data, emb_15_embbag_valid_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_15_embbag_valid_indices_dram, emb_15_embbag_valid_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_15_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_15_embbag_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_15_embbag_weight", typed_data, emb_15_embbag_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_15_embbag_weight_golden_dram, emb_15_embbag_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_15_embbag_momentum from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_15_embbag_momentum_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_15_embbag_momentum", typed_data, emb_15_embbag_momentum_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_15_embbag_momentum_dram, emb_15_embbag_momentum_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_15_embbag_dedw_param_table_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_15_embbag_dedw_param_table_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_15_embbag_dedw_param_table_indices", typed_data, emb_15_embbag_dedw_param_table_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_15_embbag_dedw_param_table_indices_dram, emb_15_embbag_dedw_param_table_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_15_offset_shape from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_15_offset_shape_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_15_offset_shape", typed_data, emb_15_offset_shape_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_15_offset_shape_dram, emb_15_offset_shape_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_16_embbag_dedw_grad_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_16_embbag_dedw_grad_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_16_embbag_dedw_grad_indices", typed_data, emb_16_embbag_dedw_grad_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_16_embbag_dedw_grad_indices_dram, emb_16_embbag_dedw_grad_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_16_embbag_dedw_lengths from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_16_embbag_dedw_lengths_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_16_embbag_dedw_lengths", typed_data, emb_16_embbag_dedw_lengths_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_16_embbag_dedw_lengths_dram, emb_16_embbag_dedw_lengths_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_16_embbag_valid_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_16_embbag_valid_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_16_embbag_valid_indices", typed_data, emb_16_embbag_valid_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_16_embbag_valid_indices_dram, emb_16_embbag_valid_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_16_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_16_embbag_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_16_embbag_weight", typed_data, emb_16_embbag_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_16_embbag_weight_golden_dram, emb_16_embbag_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_16_embbag_momentum from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_16_embbag_momentum_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_16_embbag_momentum", typed_data, emb_16_embbag_momentum_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_16_embbag_momentum_dram, emb_16_embbag_momentum_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_16_embbag_dedw_param_table_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_16_embbag_dedw_param_table_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_16_embbag_dedw_param_table_indices", typed_data, emb_16_embbag_dedw_param_table_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_16_embbag_dedw_param_table_indices_dram, emb_16_embbag_dedw_param_table_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_16_offset_shape from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_16_offset_shape_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_16_offset_shape", typed_data, emb_16_offset_shape_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_16_offset_shape_dram, emb_16_offset_shape_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_17_embbag_dedw_grad_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_17_embbag_dedw_grad_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_17_embbag_dedw_grad_indices", typed_data, emb_17_embbag_dedw_grad_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_17_embbag_dedw_grad_indices_dram, emb_17_embbag_dedw_grad_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_17_embbag_dedw_lengths from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_17_embbag_dedw_lengths_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_17_embbag_dedw_lengths", typed_data, emb_17_embbag_dedw_lengths_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_17_embbag_dedw_lengths_dram, emb_17_embbag_dedw_lengths_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_17_embbag_valid_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_17_embbag_valid_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_17_embbag_valid_indices", typed_data, emb_17_embbag_valid_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_17_embbag_valid_indices_dram, emb_17_embbag_valid_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_17_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_17_embbag_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_17_embbag_weight", typed_data, emb_17_embbag_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_17_embbag_weight_golden_dram, emb_17_embbag_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_17_embbag_momentum from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_17_embbag_momentum_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_17_embbag_momentum", typed_data, emb_17_embbag_momentum_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_17_embbag_momentum_dram, emb_17_embbag_momentum_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_17_embbag_dedw_param_table_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_17_embbag_dedw_param_table_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_17_embbag_dedw_param_table_indices", typed_data, emb_17_embbag_dedw_param_table_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_17_embbag_dedw_param_table_indices_dram, emb_17_embbag_dedw_param_table_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_17_offset_shape from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_17_offset_shape_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_17_offset_shape", typed_data, emb_17_offset_shape_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_17_offset_shape_dram, emb_17_offset_shape_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_18_embbag_dedw_grad_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_18_embbag_dedw_grad_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_18_embbag_dedw_grad_indices", typed_data, emb_18_embbag_dedw_grad_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_18_embbag_dedw_grad_indices_dram, emb_18_embbag_dedw_grad_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_18_embbag_dedw_lengths from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_18_embbag_dedw_lengths_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_18_embbag_dedw_lengths", typed_data, emb_18_embbag_dedw_lengths_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_18_embbag_dedw_lengths_dram, emb_18_embbag_dedw_lengths_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_18_embbag_valid_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_18_embbag_valid_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_18_embbag_valid_indices", typed_data, emb_18_embbag_valid_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_18_embbag_valid_indices_dram, emb_18_embbag_valid_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_18_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_18_embbag_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_18_embbag_weight", typed_data, emb_18_embbag_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_18_embbag_weight_golden_dram, emb_18_embbag_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_18_embbag_momentum from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_18_embbag_momentum_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_18_embbag_momentum", typed_data, emb_18_embbag_momentum_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_18_embbag_momentum_dram, emb_18_embbag_momentum_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_18_embbag_dedw_param_table_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_18_embbag_dedw_param_table_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_18_embbag_dedw_param_table_indices", typed_data, emb_18_embbag_dedw_param_table_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_18_embbag_dedw_param_table_indices_dram, emb_18_embbag_dedw_param_table_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_18_offset_shape from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_18_offset_shape_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_18_offset_shape", typed_data, emb_18_offset_shape_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_18_offset_shape_dram, emb_18_offset_shape_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_19_embbag_dedw_grad_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_19_embbag_dedw_grad_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_19_embbag_dedw_grad_indices", typed_data, emb_19_embbag_dedw_grad_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_19_embbag_dedw_grad_indices_dram, emb_19_embbag_dedw_grad_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_19_embbag_dedw_lengths from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_19_embbag_dedw_lengths_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_19_embbag_dedw_lengths", typed_data, emb_19_embbag_dedw_lengths_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_19_embbag_dedw_lengths_dram, emb_19_embbag_dedw_lengths_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_19_embbag_valid_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_19_embbag_valid_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_19_embbag_valid_indices", typed_data, emb_19_embbag_valid_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_19_embbag_valid_indices_dram, emb_19_embbag_valid_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_19_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_19_embbag_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_19_embbag_weight", typed_data, emb_19_embbag_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_19_embbag_weight_golden_dram, emb_19_embbag_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_19_embbag_momentum from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_19_embbag_momentum_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_19_embbag_momentum", typed_data, emb_19_embbag_momentum_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_19_embbag_momentum_dram, emb_19_embbag_momentum_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_19_embbag_dedw_param_table_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_19_embbag_dedw_param_table_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_19_embbag_dedw_param_table_indices", typed_data, emb_19_embbag_dedw_param_table_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_19_embbag_dedw_param_table_indices_dram, emb_19_embbag_dedw_param_table_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_19_offset_shape from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_19_offset_shape_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_19_offset_shape", typed_data, emb_19_offset_shape_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_19_offset_shape_dram, emb_19_offset_shape_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_20_embbag_dedw_grad_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_20_embbag_dedw_grad_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_20_embbag_dedw_grad_indices", typed_data, emb_20_embbag_dedw_grad_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_20_embbag_dedw_grad_indices_dram, emb_20_embbag_dedw_grad_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_20_embbag_dedw_lengths from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_20_embbag_dedw_lengths_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_20_embbag_dedw_lengths", typed_data, emb_20_embbag_dedw_lengths_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_20_embbag_dedw_lengths_dram, emb_20_embbag_dedw_lengths_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_20_embbag_valid_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_20_embbag_valid_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_20_embbag_valid_indices", typed_data, emb_20_embbag_valid_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_20_embbag_valid_indices_dram, emb_20_embbag_valid_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_20_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_20_embbag_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_20_embbag_weight", typed_data, emb_20_embbag_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_20_embbag_weight_golden_dram, emb_20_embbag_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_20_embbag_momentum from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_20_embbag_momentum_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_20_embbag_momentum", typed_data, emb_20_embbag_momentum_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_20_embbag_momentum_dram, emb_20_embbag_momentum_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_20_embbag_dedw_param_table_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_20_embbag_dedw_param_table_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_20_embbag_dedw_param_table_indices", typed_data, emb_20_embbag_dedw_param_table_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_20_embbag_dedw_param_table_indices_dram, emb_20_embbag_dedw_param_table_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_20_offset_shape from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_20_offset_shape_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_20_offset_shape", typed_data, emb_20_offset_shape_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_20_offset_shape_dram, emb_20_offset_shape_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_21_embbag_dedw_grad_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_21_embbag_dedw_grad_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_21_embbag_dedw_grad_indices", typed_data, emb_21_embbag_dedw_grad_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_21_embbag_dedw_grad_indices_dram, emb_21_embbag_dedw_grad_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_21_embbag_dedw_lengths from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_21_embbag_dedw_lengths_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_21_embbag_dedw_lengths", typed_data, emb_21_embbag_dedw_lengths_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_21_embbag_dedw_lengths_dram, emb_21_embbag_dedw_lengths_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_21_embbag_valid_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_21_embbag_valid_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_21_embbag_valid_indices", typed_data, emb_21_embbag_valid_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_21_embbag_valid_indices_dram, emb_21_embbag_valid_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_21_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_21_embbag_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_21_embbag_weight", typed_data, emb_21_embbag_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_21_embbag_weight_golden_dram, emb_21_embbag_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_21_embbag_momentum from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_21_embbag_momentum_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_21_embbag_momentum", typed_data, emb_21_embbag_momentum_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_21_embbag_momentum_dram, emb_21_embbag_momentum_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_21_embbag_dedw_param_table_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_21_embbag_dedw_param_table_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_21_embbag_dedw_param_table_indices", typed_data, emb_21_embbag_dedw_param_table_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_21_embbag_dedw_param_table_indices_dram, emb_21_embbag_dedw_param_table_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_21_offset_shape from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_21_offset_shape_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_21_offset_shape", typed_data, emb_21_offset_shape_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_21_offset_shape_dram, emb_21_offset_shape_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_22_embbag_dedw_grad_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_22_embbag_dedw_grad_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_22_embbag_dedw_grad_indices", typed_data, emb_22_embbag_dedw_grad_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_22_embbag_dedw_grad_indices_dram, emb_22_embbag_dedw_grad_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_22_embbag_dedw_lengths from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_22_embbag_dedw_lengths_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_22_embbag_dedw_lengths", typed_data, emb_22_embbag_dedw_lengths_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_22_embbag_dedw_lengths_dram, emb_22_embbag_dedw_lengths_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_22_embbag_valid_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_22_embbag_valid_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_22_embbag_valid_indices", typed_data, emb_22_embbag_valid_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_22_embbag_valid_indices_dram, emb_22_embbag_valid_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_22_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_22_embbag_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_22_embbag_weight", typed_data, emb_22_embbag_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_22_embbag_weight_golden_dram, emb_22_embbag_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_22_embbag_momentum from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_22_embbag_momentum_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_22_embbag_momentum", typed_data, emb_22_embbag_momentum_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_22_embbag_momentum_dram, emb_22_embbag_momentum_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_22_embbag_dedw_param_table_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_22_embbag_dedw_param_table_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_22_embbag_dedw_param_table_indices", typed_data, emb_22_embbag_dedw_param_table_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_22_embbag_dedw_param_table_indices_dram, emb_22_embbag_dedw_param_table_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_22_offset_shape from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_22_offset_shape_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_22_offset_shape", typed_data, emb_22_offset_shape_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_22_offset_shape_dram, emb_22_offset_shape_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_23_embbag_dedw_grad_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_23_embbag_dedw_grad_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_23_embbag_dedw_grad_indices", typed_data, emb_23_embbag_dedw_grad_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_23_embbag_dedw_grad_indices_dram, emb_23_embbag_dedw_grad_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_23_embbag_dedw_lengths from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_23_embbag_dedw_lengths_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_23_embbag_dedw_lengths", typed_data, emb_23_embbag_dedw_lengths_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_23_embbag_dedw_lengths_dram, emb_23_embbag_dedw_lengths_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_23_embbag_valid_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_23_embbag_valid_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_23_embbag_valid_indices", typed_data, emb_23_embbag_valid_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_23_embbag_valid_indices_dram, emb_23_embbag_valid_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_23_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_23_embbag_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_23_embbag_weight", typed_data, emb_23_embbag_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_23_embbag_weight_golden_dram, emb_23_embbag_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_23_embbag_momentum from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_23_embbag_momentum_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_23_embbag_momentum", typed_data, emb_23_embbag_momentum_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_23_embbag_momentum_dram, emb_23_embbag_momentum_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_23_embbag_dedw_param_table_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_23_embbag_dedw_param_table_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_23_embbag_dedw_param_table_indices", typed_data, emb_23_embbag_dedw_param_table_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_23_embbag_dedw_param_table_indices_dram, emb_23_embbag_dedw_param_table_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_23_offset_shape from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_23_offset_shape_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_23_offset_shape", typed_data, emb_23_offset_shape_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_23_offset_shape_dram, emb_23_offset_shape_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_24_embbag_dedw_grad_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_24_embbag_dedw_grad_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_24_embbag_dedw_grad_indices", typed_data, emb_24_embbag_dedw_grad_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_24_embbag_dedw_grad_indices_dram, emb_24_embbag_dedw_grad_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_24_embbag_dedw_lengths from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_24_embbag_dedw_lengths_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_24_embbag_dedw_lengths", typed_data, emb_24_embbag_dedw_lengths_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_24_embbag_dedw_lengths_dram, emb_24_embbag_dedw_lengths_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_24_embbag_valid_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_24_embbag_valid_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_24_embbag_valid_indices", typed_data, emb_24_embbag_valid_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_24_embbag_valid_indices_dram, emb_24_embbag_valid_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_24_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_24_embbag_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_24_embbag_weight", typed_data, emb_24_embbag_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_24_embbag_weight_golden_dram, emb_24_embbag_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_24_embbag_momentum from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_24_embbag_momentum_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_24_embbag_momentum", typed_data, emb_24_embbag_momentum_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_24_embbag_momentum_dram, emb_24_embbag_momentum_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_24_embbag_dedw_param_table_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_24_embbag_dedw_param_table_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_24_embbag_dedw_param_table_indices", typed_data, emb_24_embbag_dedw_param_table_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_24_embbag_dedw_param_table_indices_dram, emb_24_embbag_dedw_param_table_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_24_offset_shape from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_24_offset_shape_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_24_offset_shape", typed_data, emb_24_offset_shape_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_24_offset_shape_dram, emb_24_offset_shape_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_25_embbag_dedw_grad_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_25_embbag_dedw_grad_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_25_embbag_dedw_grad_indices", typed_data, emb_25_embbag_dedw_grad_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_25_embbag_dedw_grad_indices_dram, emb_25_embbag_dedw_grad_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_25_embbag_dedw_lengths from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_25_embbag_dedw_lengths_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_25_embbag_dedw_lengths", typed_data, emb_25_embbag_dedw_lengths_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_25_embbag_dedw_lengths_dram, emb_25_embbag_dedw_lengths_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_25_embbag_valid_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_25_embbag_valid_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_25_embbag_valid_indices", typed_data, emb_25_embbag_valid_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_25_embbag_valid_indices_dram, emb_25_embbag_valid_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_25_embbag_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_25_embbag_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_25_embbag_weight", typed_data, emb_25_embbag_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_25_embbag_weight_golden_dram, emb_25_embbag_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_25_embbag_momentum from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_25_embbag_momentum_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_25_embbag_momentum", typed_data, emb_25_embbag_momentum_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_25_embbag_momentum_dram, emb_25_embbag_momentum_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_25_embbag_dedw_param_table_indices from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_25_embbag_dedw_param_table_indices_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_25_embbag_dedw_param_table_indices", typed_data, emb_25_embbag_dedw_param_table_indices_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_25_embbag_dedw_param_table_indices_dram, emb_25_embbag_dedw_param_table_indices_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor emb_25_offset_shape from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, emb_25_offset_shape_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        int32_t* typed_data = static_cast<int32_t*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_25_offset_shape", typed_data, emb_25_offset_shape_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, emb_25_offset_shape_dram, emb_25_offset_shape_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }

    // Collect all inputs and outputs for dlrm enqueue
    TensorInfoList rnInputs;
    TensorInfoList rnOutputs;

    rnInputs.push_back(X_int_tr_info);
    rnInputs.push_back(bot_l_0_linear_weight_tr_info);
    rnInputs.push_back(bot_l_0_linear_bias_tr_info);
    rnInputs.push_back(bot_l_2_linear_weight_tr_info);
    rnInputs.push_back(bot_l_2_linear_bias_tr_info);
    rnInputs.push_back(bot_l_4_linear_weight_tr_info);
    rnInputs.push_back(bot_l_4_linear_bias_tr_info);
    rnInputs.push_back(lS_indices_0_tr_info);
    rnInputs.push_back(lS_offset_0_tr_info);
    rnInputs.push_back(emb_0_embbag_weight_tr_info);
    rnInputs.push_back(lS_indices_1_tr_info);
    rnInputs.push_back(lS_offset_1_tr_info);
    rnInputs.push_back(emb_1_embbag_weight_tr_info);
    rnInputs.push_back(lS_indices_2_tr_info);
    rnInputs.push_back(lS_offset_2_tr_info);
    rnInputs.push_back(emb_2_embbag_weight_tr_info);
    rnInputs.push_back(lS_indices_3_tr_info);
    rnInputs.push_back(lS_offset_3_tr_info);
    rnInputs.push_back(emb_3_embbag_weight_tr_info);
    rnInputs.push_back(lS_indices_4_tr_info);
    rnInputs.push_back(lS_offset_4_tr_info);
    rnInputs.push_back(emb_4_embbag_weight_tr_info);
    rnInputs.push_back(lS_indices_5_tr_info);
    rnInputs.push_back(lS_offset_5_tr_info);
    rnInputs.push_back(emb_5_embbag_weight_tr_info);
    rnInputs.push_back(lS_indices_6_tr_info);
    rnInputs.push_back(lS_offset_6_tr_info);
    rnInputs.push_back(emb_6_embbag_weight_tr_info);
    rnInputs.push_back(lS_indices_7_tr_info);
    rnInputs.push_back(lS_offset_7_tr_info);
    rnInputs.push_back(emb_7_embbag_weight_tr_info);
    rnInputs.push_back(lS_indices_8_tr_info);
    rnInputs.push_back(lS_offset_8_tr_info);
    rnInputs.push_back(emb_8_embbag_weight_tr_info);
    rnInputs.push_back(lS_indices_9_tr_info);
    rnInputs.push_back(lS_offset_9_tr_info);
    rnInputs.push_back(emb_9_embbag_weight_tr_info);
    rnInputs.push_back(lS_indices_10_tr_info);
    rnInputs.push_back(lS_offset_10_tr_info);
    rnInputs.push_back(emb_10_embbag_weight_tr_info);
    rnInputs.push_back(lS_indices_11_tr_info);
    rnInputs.push_back(lS_offset_11_tr_info);
    rnInputs.push_back(emb_11_embbag_weight_tr_info);
    rnInputs.push_back(lS_indices_12_tr_info);
    rnInputs.push_back(lS_offset_12_tr_info);
    rnInputs.push_back(emb_12_embbag_weight_tr_info);
    rnInputs.push_back(lS_indices_13_tr_info);
    rnInputs.push_back(lS_offset_13_tr_info);
    rnInputs.push_back(emb_13_embbag_weight_tr_info);
    rnInputs.push_back(lS_indices_14_tr_info);
    rnInputs.push_back(lS_offset_14_tr_info);
    rnInputs.push_back(emb_14_embbag_weight_tr_info);
    rnInputs.push_back(lS_indices_15_tr_info);
    rnInputs.push_back(lS_offset_15_tr_info);
    rnInputs.push_back(emb_15_embbag_weight_tr_info);
    rnInputs.push_back(lS_indices_16_tr_info);
    rnInputs.push_back(lS_offset_16_tr_info);
    rnInputs.push_back(emb_16_embbag_weight_tr_info);
    rnInputs.push_back(lS_indices_17_tr_info);
    rnInputs.push_back(lS_offset_17_tr_info);
    rnInputs.push_back(emb_17_embbag_weight_tr_info);
    rnInputs.push_back(lS_indices_18_tr_info);
    rnInputs.push_back(lS_offset_18_tr_info);
    rnInputs.push_back(emb_18_embbag_weight_tr_info);
    rnInputs.push_back(lS_indices_19_tr_info);
    rnInputs.push_back(lS_offset_19_tr_info);
    rnInputs.push_back(emb_19_embbag_weight_tr_info);
    rnInputs.push_back(lS_indices_20_tr_info);
    rnInputs.push_back(lS_offset_20_tr_info);
    rnInputs.push_back(emb_20_embbag_weight_tr_info);
    rnInputs.push_back(lS_indices_21_tr_info);
    rnInputs.push_back(lS_offset_21_tr_info);
    rnInputs.push_back(emb_21_embbag_weight_tr_info);
    rnInputs.push_back(lS_indices_22_tr_info);
    rnInputs.push_back(lS_offset_22_tr_info);
    rnInputs.push_back(emb_22_embbag_weight_tr_info);
    rnInputs.push_back(lS_indices_23_tr_info);
    rnInputs.push_back(lS_offset_23_tr_info);
    rnInputs.push_back(emb_23_embbag_weight_tr_info);
    rnInputs.push_back(lS_indices_24_tr_info);
    rnInputs.push_back(lS_offset_24_tr_info);
    rnInputs.push_back(emb_24_embbag_weight_tr_info);
    rnInputs.push_back(lS_indices_25_tr_info);
    rnInputs.push_back(lS_offset_25_tr_info);
    rnInputs.push_back(emb_25_embbag_weight_tr_info);
    rnInputs.push_back(tril_indices_tr_info);
    rnInputs.push_back(top_l_0_linear_weight_tr_info);
    rnInputs.push_back(top_l_0_linear_bias_tr_info);
    rnInputs.push_back(top_l_2_linear_weight_tr_info);
    rnInputs.push_back(top_l_2_linear_bias_tr_info);
    rnInputs.push_back(top_l_4_linear_weight_tr_info);
    rnInputs.push_back(top_l_4_linear_bias_tr_info);
    rnInputs.push_back(top_l_6_linear_weight_tr_info);
    rnInputs.push_back(top_l_6_linear_bias_tr_info);
    rnInputs.push_back(top_l_8_linear_weight_tr_info);
    rnInputs.push_back(top_l_8_linear_bias_tr_info);
    rnInputs.push_back(top_l_10_linear_weight_tr_info);
    rnInputs.push_back(top_l_10_linear_bias_tr_info);
    rnInputs.push_back(target_tr_info);
    rnInputs.push_back(tril_grad_buffer_tr_info);
    rnInputs.push_back(tril_indices_broadcast_tr_info);
    rnInputs.push_back(emb_0_embbag_dedw_grad_indices_tr_info);
    rnInputs.push_back(emb_0_embbag_dedw_lengths_tr_info);
    rnInputs.push_back(emb_0_embbag_valid_indices_tr_info);
    rnInputs.push_back(emb_0_embbag_weight_golden_tr_info);
    rnInputs.push_back(emb_0_embbag_momentum_tr_info);
    rnInputs.push_back(emb_0_embbag_dedw_param_table_indices_tr_info);
    rnInputs.push_back(emb_0_offset_shape_tr_info);
    rnInputs.push_back(emb_0_embbag_timestamp_tr_info);
    rnInputs.push_back(emb_0_embbag_rate_tr_info);
    rnInputs.push_back(emb_1_embbag_dedw_grad_indices_tr_info);
    rnInputs.push_back(emb_1_embbag_dedw_lengths_tr_info);
    rnInputs.push_back(emb_1_embbag_valid_indices_tr_info);
    rnInputs.push_back(emb_1_embbag_weight_golden_tr_info);
    rnInputs.push_back(emb_1_embbag_momentum_tr_info);
    rnInputs.push_back(emb_1_embbag_dedw_param_table_indices_tr_info);
    rnInputs.push_back(emb_1_offset_shape_tr_info);
    rnInputs.push_back(emb_2_embbag_dedw_grad_indices_tr_info);
    rnInputs.push_back(emb_2_embbag_dedw_lengths_tr_info);
    rnInputs.push_back(emb_2_embbag_valid_indices_tr_info);
    rnInputs.push_back(emb_2_embbag_weight_golden_tr_info);
    rnInputs.push_back(emb_2_embbag_momentum_tr_info);
    rnInputs.push_back(emb_2_embbag_dedw_param_table_indices_tr_info);
    rnInputs.push_back(emb_2_offset_shape_tr_info);
    rnInputs.push_back(emb_3_embbag_dedw_grad_indices_tr_info);
    rnInputs.push_back(emb_3_embbag_dedw_lengths_tr_info);
    rnInputs.push_back(emb_3_embbag_valid_indices_tr_info);
    rnInputs.push_back(emb_3_embbag_weight_golden_tr_info);
    rnInputs.push_back(emb_3_embbag_momentum_tr_info);
    rnInputs.push_back(emb_3_embbag_dedw_param_table_indices_tr_info);
    rnInputs.push_back(emb_3_offset_shape_tr_info);
    rnInputs.push_back(emb_4_embbag_dedw_grad_indices_tr_info);
    rnInputs.push_back(emb_4_embbag_dedw_lengths_tr_info);
    rnInputs.push_back(emb_4_embbag_valid_indices_tr_info);
    rnInputs.push_back(emb_4_embbag_weight_golden_tr_info);
    rnInputs.push_back(emb_4_embbag_momentum_tr_info);
    rnInputs.push_back(emb_4_embbag_dedw_param_table_indices_tr_info);
    rnInputs.push_back(emb_4_offset_shape_tr_info);
    rnInputs.push_back(emb_5_embbag_dedw_grad_indices_tr_info);
    rnInputs.push_back(emb_5_embbag_dedw_lengths_tr_info);
    rnInputs.push_back(emb_5_embbag_valid_indices_tr_info);
    rnInputs.push_back(emb_5_embbag_weight_golden_tr_info);
    rnInputs.push_back(emb_5_embbag_momentum_tr_info);
    rnInputs.push_back(emb_5_embbag_dedw_param_table_indices_tr_info);
    rnInputs.push_back(emb_5_offset_shape_tr_info);
    rnInputs.push_back(emb_6_embbag_dedw_grad_indices_tr_info);
    rnInputs.push_back(emb_6_embbag_dedw_lengths_tr_info);
    rnInputs.push_back(emb_6_embbag_valid_indices_tr_info);
    rnInputs.push_back(emb_6_embbag_weight_golden_tr_info);
    rnInputs.push_back(emb_6_embbag_momentum_tr_info);
    rnInputs.push_back(emb_6_embbag_dedw_param_table_indices_tr_info);
    rnInputs.push_back(emb_6_offset_shape_tr_info);
    rnInputs.push_back(emb_7_embbag_dedw_grad_indices_tr_info);
    rnInputs.push_back(emb_7_embbag_dedw_lengths_tr_info);
    rnInputs.push_back(emb_7_embbag_valid_indices_tr_info);
    rnInputs.push_back(emb_7_embbag_weight_golden_tr_info);
    rnInputs.push_back(emb_7_embbag_momentum_tr_info);
    rnInputs.push_back(emb_7_embbag_dedw_param_table_indices_tr_info);
    rnInputs.push_back(emb_7_offset_shape_tr_info);
    rnInputs.push_back(emb_8_embbag_dedw_grad_indices_tr_info);
    rnInputs.push_back(emb_8_embbag_dedw_lengths_tr_info);
    rnInputs.push_back(emb_8_embbag_valid_indices_tr_info);
    rnInputs.push_back(emb_8_embbag_weight_golden_tr_info);
    rnInputs.push_back(emb_8_embbag_momentum_tr_info);
    rnInputs.push_back(emb_8_embbag_dedw_param_table_indices_tr_info);
    rnInputs.push_back(emb_8_offset_shape_tr_info);
    rnInputs.push_back(emb_9_embbag_dedw_grad_indices_tr_info);
    rnInputs.push_back(emb_9_embbag_dedw_lengths_tr_info);
    rnInputs.push_back(emb_9_embbag_valid_indices_tr_info);
    rnInputs.push_back(emb_9_embbag_weight_golden_tr_info);
    rnInputs.push_back(emb_9_embbag_momentum_tr_info);
    rnInputs.push_back(emb_9_embbag_dedw_param_table_indices_tr_info);
    rnInputs.push_back(emb_9_offset_shape_tr_info);
    rnInputs.push_back(emb_10_embbag_dedw_grad_indices_tr_info);
    rnInputs.push_back(emb_10_embbag_dedw_lengths_tr_info);
    rnInputs.push_back(emb_10_embbag_valid_indices_tr_info);
    rnInputs.push_back(emb_10_embbag_weight_golden_tr_info);
    rnInputs.push_back(emb_10_embbag_momentum_tr_info);
    rnInputs.push_back(emb_10_embbag_dedw_param_table_indices_tr_info);
    rnInputs.push_back(emb_10_offset_shape_tr_info);
    rnInputs.push_back(emb_11_embbag_dedw_grad_indices_tr_info);
    rnInputs.push_back(emb_11_embbag_dedw_lengths_tr_info);
    rnInputs.push_back(emb_11_embbag_valid_indices_tr_info);
    rnInputs.push_back(emb_11_embbag_weight_golden_tr_info);
    rnInputs.push_back(emb_11_embbag_momentum_tr_info);
    rnInputs.push_back(emb_11_embbag_dedw_param_table_indices_tr_info);
    rnInputs.push_back(emb_11_offset_shape_tr_info);
    rnInputs.push_back(emb_12_embbag_dedw_grad_indices_tr_info);
    rnInputs.push_back(emb_12_embbag_dedw_lengths_tr_info);
    rnInputs.push_back(emb_12_embbag_valid_indices_tr_info);
    rnInputs.push_back(emb_12_embbag_weight_golden_tr_info);
    rnInputs.push_back(emb_12_embbag_momentum_tr_info);
    rnInputs.push_back(emb_12_embbag_dedw_param_table_indices_tr_info);
    rnInputs.push_back(emb_12_offset_shape_tr_info);
    rnInputs.push_back(emb_13_embbag_dedw_grad_indices_tr_info);
    rnInputs.push_back(emb_13_embbag_dedw_lengths_tr_info);
    rnInputs.push_back(emb_13_embbag_valid_indices_tr_info);
    rnInputs.push_back(emb_13_embbag_weight_golden_tr_info);
    rnInputs.push_back(emb_13_embbag_momentum_tr_info);
    rnInputs.push_back(emb_13_embbag_dedw_param_table_indices_tr_info);
    rnInputs.push_back(emb_13_offset_shape_tr_info);
    rnInputs.push_back(emb_14_embbag_dedw_grad_indices_tr_info);
    rnInputs.push_back(emb_14_embbag_dedw_lengths_tr_info);
    rnInputs.push_back(emb_14_embbag_valid_indices_tr_info);
    rnInputs.push_back(emb_14_embbag_weight_golden_tr_info);
    rnInputs.push_back(emb_14_embbag_momentum_tr_info);
    rnInputs.push_back(emb_14_embbag_dedw_param_table_indices_tr_info);
    rnInputs.push_back(emb_14_offset_shape_tr_info);
    rnInputs.push_back(emb_15_embbag_dedw_grad_indices_tr_info);
    rnInputs.push_back(emb_15_embbag_dedw_lengths_tr_info);
    rnInputs.push_back(emb_15_embbag_valid_indices_tr_info);
    rnInputs.push_back(emb_15_embbag_weight_golden_tr_info);
    rnInputs.push_back(emb_15_embbag_momentum_tr_info);
    rnInputs.push_back(emb_15_embbag_dedw_param_table_indices_tr_info);
    rnInputs.push_back(emb_15_offset_shape_tr_info);
    rnInputs.push_back(emb_16_embbag_dedw_grad_indices_tr_info);
    rnInputs.push_back(emb_16_embbag_dedw_lengths_tr_info);
    rnInputs.push_back(emb_16_embbag_valid_indices_tr_info);
    rnInputs.push_back(emb_16_embbag_weight_golden_tr_info);
    rnInputs.push_back(emb_16_embbag_momentum_tr_info);
    rnInputs.push_back(emb_16_embbag_dedw_param_table_indices_tr_info);
    rnInputs.push_back(emb_16_offset_shape_tr_info);
    rnInputs.push_back(emb_17_embbag_dedw_grad_indices_tr_info);
    rnInputs.push_back(emb_17_embbag_dedw_lengths_tr_info);
    rnInputs.push_back(emb_17_embbag_valid_indices_tr_info);
    rnInputs.push_back(emb_17_embbag_weight_golden_tr_info);
    rnInputs.push_back(emb_17_embbag_momentum_tr_info);
    rnInputs.push_back(emb_17_embbag_dedw_param_table_indices_tr_info);
    rnInputs.push_back(emb_17_offset_shape_tr_info);
    rnInputs.push_back(emb_18_embbag_dedw_grad_indices_tr_info);
    rnInputs.push_back(emb_18_embbag_dedw_lengths_tr_info);
    rnInputs.push_back(emb_18_embbag_valid_indices_tr_info);
    rnInputs.push_back(emb_18_embbag_weight_golden_tr_info);
    rnInputs.push_back(emb_18_embbag_momentum_tr_info);
    rnInputs.push_back(emb_18_embbag_dedw_param_table_indices_tr_info);
    rnInputs.push_back(emb_18_offset_shape_tr_info);
    rnInputs.push_back(emb_19_embbag_dedw_grad_indices_tr_info);
    rnInputs.push_back(emb_19_embbag_dedw_lengths_tr_info);
    rnInputs.push_back(emb_19_embbag_valid_indices_tr_info);
    rnInputs.push_back(emb_19_embbag_weight_golden_tr_info);
    rnInputs.push_back(emb_19_embbag_momentum_tr_info);
    rnInputs.push_back(emb_19_embbag_dedw_param_table_indices_tr_info);
    rnInputs.push_back(emb_19_offset_shape_tr_info);
    rnInputs.push_back(emb_20_embbag_dedw_grad_indices_tr_info);
    rnInputs.push_back(emb_20_embbag_dedw_lengths_tr_info);
    rnInputs.push_back(emb_20_embbag_valid_indices_tr_info);
    rnInputs.push_back(emb_20_embbag_weight_golden_tr_info);
    rnInputs.push_back(emb_20_embbag_momentum_tr_info);
    rnInputs.push_back(emb_20_embbag_dedw_param_table_indices_tr_info);
    rnInputs.push_back(emb_20_offset_shape_tr_info);
    rnInputs.push_back(emb_21_embbag_dedw_grad_indices_tr_info);
    rnInputs.push_back(emb_21_embbag_dedw_lengths_tr_info);
    rnInputs.push_back(emb_21_embbag_valid_indices_tr_info);
    rnInputs.push_back(emb_21_embbag_weight_golden_tr_info);
    rnInputs.push_back(emb_21_embbag_momentum_tr_info);
    rnInputs.push_back(emb_21_embbag_dedw_param_table_indices_tr_info);
    rnInputs.push_back(emb_21_offset_shape_tr_info);
    rnInputs.push_back(emb_22_embbag_dedw_grad_indices_tr_info);
    rnInputs.push_back(emb_22_embbag_dedw_lengths_tr_info);
    rnInputs.push_back(emb_22_embbag_valid_indices_tr_info);
    rnInputs.push_back(emb_22_embbag_weight_golden_tr_info);
    rnInputs.push_back(emb_22_embbag_momentum_tr_info);
    rnInputs.push_back(emb_22_embbag_dedw_param_table_indices_tr_info);
    rnInputs.push_back(emb_22_offset_shape_tr_info);
    rnInputs.push_back(emb_23_embbag_dedw_grad_indices_tr_info);
    rnInputs.push_back(emb_23_embbag_dedw_lengths_tr_info);
    rnInputs.push_back(emb_23_embbag_valid_indices_tr_info);
    rnInputs.push_back(emb_23_embbag_weight_golden_tr_info);
    rnInputs.push_back(emb_23_embbag_momentum_tr_info);
    rnInputs.push_back(emb_23_embbag_dedw_param_table_indices_tr_info);
    rnInputs.push_back(emb_23_offset_shape_tr_info);
    rnInputs.push_back(emb_24_embbag_dedw_grad_indices_tr_info);
    rnInputs.push_back(emb_24_embbag_dedw_lengths_tr_info);
    rnInputs.push_back(emb_24_embbag_valid_indices_tr_info);
    rnInputs.push_back(emb_24_embbag_weight_golden_tr_info);
    rnInputs.push_back(emb_24_embbag_momentum_tr_info);
    rnInputs.push_back(emb_24_embbag_dedw_param_table_indices_tr_info);
    rnInputs.push_back(emb_24_offset_shape_tr_info);
    rnInputs.push_back(emb_25_embbag_dedw_grad_indices_tr_info);
    rnInputs.push_back(emb_25_embbag_dedw_lengths_tr_info);
    rnInputs.push_back(emb_25_embbag_valid_indices_tr_info);
    rnInputs.push_back(emb_25_embbag_weight_golden_tr_info);
    rnInputs.push_back(emb_25_embbag_momentum_tr_info);
    rnInputs.push_back(emb_25_embbag_dedw_param_table_indices_tr_info);
    rnInputs.push_back(emb_25_offset_shape_tr_info);

    rnOutputs.push_back(binary_cross_entropy_loss_output_tr_info);
    rnOutputs.push_back(binary_cross_entropy_loss_saved_sigmoid_tr_info);
    rnOutputs.push_back(top_l_10_linear_weight_grad_tr_info);
    rnOutputs.push_back(top_l_10_linear_bias_grad_tr_info);
    rnOutputs.push_back(top_l_8_linear_weight_grad_tr_info);
    rnOutputs.push_back(top_l_8_linear_bias_grad_tr_info);
    rnOutputs.push_back(top_l_6_linear_weight_grad_tr_info);
    rnOutputs.push_back(top_l_6_linear_bias_grad_tr_info);
    rnOutputs.push_back(top_l_4_linear_weight_grad_tr_info);
    rnOutputs.push_back(top_l_4_linear_bias_grad_tr_info);
    rnOutputs.push_back(top_l_2_linear_weight_grad_tr_info);
    rnOutputs.push_back(top_l_2_linear_bias_grad_tr_info);
    rnOutputs.push_back(top_l_0_linear_weight_grad_tr_info);
    rnOutputs.push_back(top_l_0_linear_bias_grad_tr_info);
    rnOutputs.push_back(emb_0_embbag_dedw_weight_output_golden_tr_info);
    rnOutputs.push_back(emb_0_embbag_dedw_momentum_output_tr_info);
    rnOutputs.push_back(emb_0_embbag_dedw_weight_output_tr_info);
    rnOutputs.push_back(emb_1_embbag_dedw_weight_output_golden_tr_info);
    rnOutputs.push_back(emb_1_embbag_dedw_momentum_output_tr_info);
    rnOutputs.push_back(emb_1_embbag_dedw_weight_output_tr_info);
    rnOutputs.push_back(emb_2_embbag_dedw_weight_output_golden_tr_info);
    rnOutputs.push_back(emb_2_embbag_dedw_momentum_output_tr_info);
    rnOutputs.push_back(emb_2_embbag_dedw_weight_output_tr_info);
    rnOutputs.push_back(emb_3_embbag_dedw_weight_output_golden_tr_info);
    rnOutputs.push_back(emb_3_embbag_dedw_momentum_output_tr_info);
    rnOutputs.push_back(emb_3_embbag_dedw_weight_output_tr_info);
    rnOutputs.push_back(emb_4_embbag_dedw_weight_output_golden_tr_info);
    rnOutputs.push_back(emb_4_embbag_dedw_momentum_output_tr_info);
    rnOutputs.push_back(emb_4_embbag_dedw_weight_output_tr_info);
    rnOutputs.push_back(emb_5_embbag_dedw_weight_output_golden_tr_info);
    rnOutputs.push_back(emb_5_embbag_dedw_momentum_output_tr_info);
    rnOutputs.push_back(emb_5_embbag_dedw_weight_output_tr_info);
    rnOutputs.push_back(emb_6_embbag_dedw_weight_output_golden_tr_info);
    rnOutputs.push_back(emb_6_embbag_dedw_momentum_output_tr_info);
    rnOutputs.push_back(emb_6_embbag_dedw_weight_output_tr_info);
    rnOutputs.push_back(emb_7_embbag_dedw_weight_output_golden_tr_info);
    rnOutputs.push_back(emb_7_embbag_dedw_momentum_output_tr_info);
    rnOutputs.push_back(emb_7_embbag_dedw_weight_output_tr_info);
    rnOutputs.push_back(emb_8_embbag_dedw_weight_output_golden_tr_info);
    rnOutputs.push_back(emb_8_embbag_dedw_momentum_output_tr_info);
    rnOutputs.push_back(emb_8_embbag_dedw_weight_output_tr_info);
    rnOutputs.push_back(emb_9_embbag_dedw_weight_output_golden_tr_info);
    rnOutputs.push_back(emb_9_embbag_dedw_momentum_output_tr_info);
    rnOutputs.push_back(emb_9_embbag_dedw_weight_output_tr_info);
    rnOutputs.push_back(emb_10_embbag_dedw_weight_output_golden_tr_info);
    rnOutputs.push_back(emb_10_embbag_dedw_momentum_output_tr_info);
    rnOutputs.push_back(emb_10_embbag_dedw_weight_output_tr_info);
    rnOutputs.push_back(emb_11_embbag_dedw_weight_output_golden_tr_info);
    rnOutputs.push_back(emb_11_embbag_dedw_momentum_output_tr_info);
    rnOutputs.push_back(emb_11_embbag_dedw_weight_output_tr_info);
    rnOutputs.push_back(emb_12_embbag_dedw_weight_output_golden_tr_info);
    rnOutputs.push_back(emb_12_embbag_dedw_momentum_output_tr_info);
    rnOutputs.push_back(emb_12_embbag_dedw_weight_output_tr_info);
    rnOutputs.push_back(emb_13_embbag_dedw_weight_output_golden_tr_info);
    rnOutputs.push_back(emb_13_embbag_dedw_momentum_output_tr_info);
    rnOutputs.push_back(emb_13_embbag_dedw_weight_output_tr_info);
    rnOutputs.push_back(emb_14_embbag_dedw_weight_output_golden_tr_info);
    rnOutputs.push_back(emb_14_embbag_dedw_momentum_output_tr_info);
    rnOutputs.push_back(emb_14_embbag_dedw_weight_output_tr_info);
    rnOutputs.push_back(emb_15_embbag_dedw_weight_output_golden_tr_info);
    rnOutputs.push_back(emb_15_embbag_dedw_momentum_output_tr_info);
    rnOutputs.push_back(emb_15_embbag_dedw_weight_output_tr_info);
    rnOutputs.push_back(emb_16_embbag_dedw_weight_output_golden_tr_info);
    rnOutputs.push_back(emb_16_embbag_dedw_momentum_output_tr_info);
    rnOutputs.push_back(emb_16_embbag_dedw_weight_output_tr_info);
    rnOutputs.push_back(emb_17_embbag_dedw_weight_output_golden_tr_info);
    rnOutputs.push_back(emb_17_embbag_dedw_momentum_output_tr_info);
    rnOutputs.push_back(emb_17_embbag_dedw_weight_output_tr_info);
    rnOutputs.push_back(emb_18_embbag_dedw_weight_output_golden_tr_info);
    rnOutputs.push_back(emb_18_embbag_dedw_momentum_output_tr_info);
    rnOutputs.push_back(emb_18_embbag_dedw_weight_output_tr_info);
    rnOutputs.push_back(emb_19_embbag_dedw_weight_output_golden_tr_info);
    rnOutputs.push_back(emb_19_embbag_dedw_momentum_output_tr_info);
    rnOutputs.push_back(emb_19_embbag_dedw_weight_output_tr_info);
    rnOutputs.push_back(emb_20_embbag_dedw_weight_output_golden_tr_info);
    rnOutputs.push_back(emb_20_embbag_dedw_momentum_output_tr_info);
    rnOutputs.push_back(emb_20_embbag_dedw_weight_output_tr_info);
    rnOutputs.push_back(emb_21_embbag_dedw_weight_output_golden_tr_info);
    rnOutputs.push_back(emb_21_embbag_dedw_momentum_output_tr_info);
    rnOutputs.push_back(emb_21_embbag_dedw_weight_output_tr_info);
    rnOutputs.push_back(emb_22_embbag_dedw_weight_output_golden_tr_info);
    rnOutputs.push_back(emb_22_embbag_dedw_momentum_output_tr_info);
    rnOutputs.push_back(emb_22_embbag_dedw_weight_output_tr_info);
    rnOutputs.push_back(emb_23_embbag_dedw_weight_output_golden_tr_info);
    rnOutputs.push_back(emb_23_embbag_dedw_momentum_output_tr_info);
    rnOutputs.push_back(emb_23_embbag_dedw_weight_output_tr_info);
    rnOutputs.push_back(emb_24_embbag_dedw_weight_output_golden_tr_info);
    rnOutputs.push_back(emb_24_embbag_dedw_momentum_output_tr_info);
    rnOutputs.push_back(emb_24_embbag_dedw_weight_output_tr_info);
    rnOutputs.push_back(emb_25_embbag_dedw_weight_output_golden_tr_info);
    rnOutputs.push_back(emb_25_embbag_dedw_momentum_output_tr_info);
    rnOutputs.push_back(emb_25_embbag_dedw_weight_output_tr_info);
    rnOutputs.push_back(bot_l_4_linear_weight_grad_tr_info);
    rnOutputs.push_back(bot_l_4_linear_bias_grad_tr_info);
    rnOutputs.push_back(bot_l_2_linear_weight_grad_tr_info);
    rnOutputs.push_back(bot_l_2_linear_bias_grad_tr_info);
    rnOutputs.push_back(bot_l_0_linear_grad_input_tr_info);
    rnOutputs.push_back(bot_l_0_linear_weight_grad_tr_info);
    rnOutputs.push_back(bot_l_0_linear_bias_grad_tr_info);
    rnOutputs.push_back(reshape_bmm_output_tr_info);
    rnOutputs.push_back(add_grads_bmm_output_tr_info);
    rnOutputs.push_back(top_l_8_linear_grad_input_tr_info);
    rnOutputs.push_back(top_l_6_linear_grad_input_tr_info);
    rnOutputs.push_back(add_grads_concat_output_tr_info);
    rnOutputs.push_back(top_l_4_linear_grad_input_tr_info);
    rnOutputs.push_back(top_l_2_linear_grad_input_tr_info);
    rnOutputs.push_back(top_l_0_linear_grad_input_tr_info);
    rnOutputs.push_back(bot_l_4_linear_grad_input_tr_info);
    rnOutputs.push_back(top_l_10_linear_output_tr_info);
    rnOutputs.push_back(concat_interact1_dedx_top_l_0_linear_grad_input_tensor_reshape_tr_info);
    rnOutputs.push_back(bot_l_2_linear_grad_input_tr_info);
    rnOutputs.push_back(tril_indices_grad_input_tr_info);
    rnOutputs.push_back(top_l_10_linear_grad_input_tr_info);
    rnOutputs.push_back(reshape_tril_grad_input_tr_info);
    rnOutputs.push_back(bmm_interact_grad_input0_tr_info);

    synGraphHandle wuGraphHandle;
    status = synGraphCreate(&wuGraphHandle, synDeviceGaudi);
    /*************
     * bot_l_0_linear_weight_update_node node
     * inputs: [bot_l_0_linear_weight_grad_wu[512, 13](dtype=float32), bot_l_0_linear_weight_golden[512, 13](dtype=float32), learning_rate[1](dtype=float32)]
     * output: [bot_l_0_linear_weight_golden_wu_out(512, 13)(dtype=float32), bot_l_0_linear_weight_wu_out(512, 13)(dtype=bf16)]
     *************/
    ns_OptimizerSGD::Params bot_l_0_linear_weight_update_node_kernel_params;
    bot_l_0_linear_weight_update_node_kernel_params.wd = 0;
    bot_l_0_linear_weight_update_node_kernel_params.mom = 0;
    bot_l_0_linear_weight_update_node_kernel_params.damp = 0;
    bot_l_0_linear_weight_update_node_kernel_params.nesterov = false;

    // create bot_l_0_linear_weight_grad_wu tensor
    const unsigned bot_l_0_linear_weight_grad_wu_sizes[] = {512, 13};
    uint64_t bot_l_0_linear_weight_grad_wu_dram;
    unsigned bot_l_0_linear_weight_grad_wu_size = 512*13;
    unsigned bot_l_0_linear_weight_grad_wu_size_in_bytes = bot_l_0_linear_weight_grad_wu_size * sizeof(float) ;
    status = hbmAlloc(bot_l_0_linear_weight_grad_wu_size_in_bytes, &bot_l_0_linear_weight_grad_wu_dram, "bot_l_0_linear_weight_grad_wu");
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_weight_grad_wu dram malloc failed!");
    synLaunchTensorInfo bot_l_0_linear_weight_grad_wu_tr_info = {"bot_l_0_linear_weight_grad_wu",
                                                                 bot_l_0_linear_weight_grad_wu_dram};
    UNUSED(bot_l_0_linear_weight_grad_wu_tr_info); // For single op tests
    synTensor bot_l_0_linear_weight_grad_wu = createTensor(2U, syn_type_single, bot_l_0_linear_weight_grad_wu_sizes, true, "bot_l_0_linear_weight_grad_wu");
    UNUSED(bot_l_0_linear_weight_grad_wu); // For single op tests

    // create bot_l_0_linear_weight_golden tensor
    const unsigned bot_l_0_linear_weight_golden_sizes[] = {512, 13};
    uint64_t bot_l_0_linear_weight_golden_dram;
    unsigned bot_l_0_linear_weight_golden_size = 512*13;
    unsigned bot_l_0_linear_weight_golden_size_in_bytes = bot_l_0_linear_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(bot_l_0_linear_weight_golden_size_in_bytes, &bot_l_0_linear_weight_golden_dram, "bot_l_0_linear_weight_golden");
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_weight_golden dram malloc failed!");
    synLaunchTensorInfo bot_l_0_linear_weight_golden_tr_info = {"bot_l_0_linear_weight_golden",
                                                                bot_l_0_linear_weight_golden_dram};
    UNUSED(bot_l_0_linear_weight_golden_tr_info); // For single op tests
    synTensor bot_l_0_linear_weight_golden = createTensor(2U, syn_type_single, bot_l_0_linear_weight_golden_sizes, true, "bot_l_0_linear_weight_golden");
    UNUSED(bot_l_0_linear_weight_golden); // For single op tests

    // create learning_rate tensor
    const unsigned learning_rate_sizes[] = {1,};
    uint64_t learning_rate_dram;
    unsigned learning_rate_size = 1;
    unsigned learning_rate_size_in_bytes = learning_rate_size * sizeof(float) ;
    status = hbmAlloc(learning_rate_size_in_bytes, &learning_rate_dram, "learning_rate");
    ASSERT_TRUE(status == synSuccess && "learning_rate dram malloc failed!");
    synLaunchTensorInfo learning_rate_tr_info = {"learning_rate", learning_rate_dram};
    UNUSED(learning_rate_tr_info); // For single op tests
    synTensor learning_rate = createTensor(1U, syn_type_single, learning_rate_sizes, true, "learning_rate");
    UNUSED(learning_rate); // For single op tests

    synTensor bot_l_0_linear_weight_update_node_in_vec[3] = {bot_l_0_linear_weight_grad_wu, bot_l_0_linear_weight_golden, learning_rate};


    // create bot_l_0_linear_weight_golden_wu_out tensor
    const unsigned bot_l_0_linear_weight_golden_wu_out_sizes[] = {512, 13};
    uint64_t bot_l_0_linear_weight_golden_wu_out_dram;
    unsigned bot_l_0_linear_weight_golden_wu_out_size = 512*13;
    unsigned bot_l_0_linear_weight_golden_wu_out_size_in_bytes = bot_l_0_linear_weight_golden_wu_out_size * sizeof(float) ;
    status = hbmAlloc(bot_l_0_linear_weight_golden_wu_out_size_in_bytes, &bot_l_0_linear_weight_golden_wu_out_dram, "bot_l_0_linear_weight_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_weight_golden_wu_out dram malloc failed!");
    synLaunchTensorInfo bot_l_0_linear_weight_golden_wu_out_tr_info = {"bot_l_0_linear_weight_golden_wu_out",
                                                                       bot_l_0_linear_weight_golden_wu_out_dram};
    UNUSED(bot_l_0_linear_weight_golden_wu_out_tr_info); // For single op tests
    synTensor bot_l_0_linear_weight_golden_wu_out = createTensor(2U, syn_type_single, bot_l_0_linear_weight_golden_wu_out_sizes, true, "bot_l_0_linear_weight_golden_wu_out");
    UNUSED(bot_l_0_linear_weight_golden_wu_out); // For single op tests

    // create bot_l_0_linear_weight_wu_out tensor
    const unsigned bot_l_0_linear_weight_wu_out_sizes[] = {512, 13};
    uint64_t bot_l_0_linear_weight_wu_out_dram;
    unsigned bot_l_0_linear_weight_wu_out_size = 512*13;
    unsigned bot_l_0_linear_weight_wu_out_size_in_bytes = bot_l_0_linear_weight_wu_out_size * sizeof(bfloat16) ;
    status = hbmAlloc(bot_l_0_linear_weight_wu_out_size_in_bytes, &bot_l_0_linear_weight_wu_out_dram, "bot_l_0_linear_weight_wu_out");
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_weight_wu_out dram malloc failed!");
    synLaunchTensorInfo bot_l_0_linear_weight_wu_out_tr_info = {"bot_l_0_linear_weight_wu_out",
                                                                bot_l_0_linear_weight_wu_out_dram};
    UNUSED(bot_l_0_linear_weight_wu_out_tr_info); // For single op tests
    synTensor bot_l_0_linear_weight_wu_out = createTensor(2U, syn_type_bf16, bot_l_0_linear_weight_wu_out_sizes, true, "bot_l_0_linear_weight_wu_out");
    UNUSED(bot_l_0_linear_weight_wu_out); // For single op tests

    synTensor bot_l_0_linear_weight_update_node_out_vec[2] = {bot_l_0_linear_weight_golden_wu_out, bot_l_0_linear_weight_wu_out};


    status = synNodeCreate(wuGraphHandle, bot_l_0_linear_weight_update_node_in_vec, bot_l_0_linear_weight_update_node_out_vec, 3, 2, (void *)&bot_l_0_linear_weight_update_node_kernel_params, sizeof(bot_l_0_linear_weight_update_node_kernel_params), "optimizer_sgd_bwd_f32", "bot_l_0_linear_weight_update_node", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bot_l_0_linear_weight_update_node failed!");

    /*************
     * bot_l_2_linear_weight_update_node node
     * inputs: [bot_l_2_linear_weight_grad_wu[512, 512](dtype=float32), bot_l_2_linear_weight_golden[512, 512](dtype=float32), learning_rate[1](dtype=float32)]
     * output: [bot_l_2_linear_weight_golden_wu_out(512, 512)(dtype=float32), bot_l_2_linear_weight_wu_out(512, 512)(dtype=bf16)]
     *************/
    ns_OptimizerSGD::Params bot_l_2_linear_weight_update_node_kernel_params;
    bot_l_2_linear_weight_update_node_kernel_params.wd = 0;
    bot_l_2_linear_weight_update_node_kernel_params.mom = 0;
    bot_l_2_linear_weight_update_node_kernel_params.damp = 0;
    bot_l_2_linear_weight_update_node_kernel_params.nesterov = false;

    // create bot_l_2_linear_weight_grad_wu tensor
    const unsigned bot_l_2_linear_weight_grad_wu_sizes[] = {512, 512};
    uint64_t bot_l_2_linear_weight_grad_wu_dram;
    unsigned bot_l_2_linear_weight_grad_wu_size = 512*512;
    unsigned bot_l_2_linear_weight_grad_wu_size_in_bytes = bot_l_2_linear_weight_grad_wu_size * sizeof(float) ;
    status = hbmAlloc(bot_l_2_linear_weight_grad_wu_size_in_bytes, &bot_l_2_linear_weight_grad_wu_dram, "bot_l_2_linear_weight_grad_wu");
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_weight_grad_wu dram malloc failed!");
    synLaunchTensorInfo bot_l_2_linear_weight_grad_wu_tr_info = {"bot_l_2_linear_weight_grad_wu",
                                                                 bot_l_2_linear_weight_grad_wu_dram};
    UNUSED(bot_l_2_linear_weight_grad_wu_tr_info); // For single op tests
    synTensor bot_l_2_linear_weight_grad_wu = createTensor(2U, syn_type_single, bot_l_2_linear_weight_grad_wu_sizes, true, "bot_l_2_linear_weight_grad_wu");
    UNUSED(bot_l_2_linear_weight_grad_wu); // For single op tests

    // create bot_l_2_linear_weight_golden tensor
    const unsigned bot_l_2_linear_weight_golden_sizes[] = {512, 512};
    uint64_t bot_l_2_linear_weight_golden_dram;
    unsigned bot_l_2_linear_weight_golden_size = 512*512;
    unsigned bot_l_2_linear_weight_golden_size_in_bytes = bot_l_2_linear_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(bot_l_2_linear_weight_golden_size_in_bytes, &bot_l_2_linear_weight_golden_dram, "bot_l_2_linear_weight_golden");
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_weight_golden dram malloc failed!");
    synLaunchTensorInfo bot_l_2_linear_weight_golden_tr_info = {"bot_l_2_linear_weight_golden",
                                                                bot_l_2_linear_weight_golden_dram};
    UNUSED(bot_l_2_linear_weight_golden_tr_info); // For single op tests
    synTensor bot_l_2_linear_weight_golden = createTensor(2U, syn_type_single, bot_l_2_linear_weight_golden_sizes, true, "bot_l_2_linear_weight_golden");
    UNUSED(bot_l_2_linear_weight_golden); // For single op tests

    synTensor bot_l_2_linear_weight_update_node_in_vec[3] = {bot_l_2_linear_weight_grad_wu, bot_l_2_linear_weight_golden, learning_rate};


    // create bot_l_2_linear_weight_golden_wu_out tensor
    const unsigned bot_l_2_linear_weight_golden_wu_out_sizes[] = {512, 512};
    uint64_t bot_l_2_linear_weight_golden_wu_out_dram;
    unsigned bot_l_2_linear_weight_golden_wu_out_size = 512*512;
    unsigned bot_l_2_linear_weight_golden_wu_out_size_in_bytes = bot_l_2_linear_weight_golden_wu_out_size * sizeof(float) ;
    status = hbmAlloc(bot_l_2_linear_weight_golden_wu_out_size_in_bytes, &bot_l_2_linear_weight_golden_wu_out_dram, "bot_l_2_linear_weight_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_weight_golden_wu_out dram malloc failed!");
    synLaunchTensorInfo bot_l_2_linear_weight_golden_wu_out_tr_info = {"bot_l_2_linear_weight_golden_wu_out",
                                                                       bot_l_2_linear_weight_golden_wu_out_dram};
    UNUSED(bot_l_2_linear_weight_golden_wu_out_tr_info); // For single op tests
    synTensor bot_l_2_linear_weight_golden_wu_out = createTensor(2U, syn_type_single, bot_l_2_linear_weight_golden_wu_out_sizes, true, "bot_l_2_linear_weight_golden_wu_out");
    UNUSED(bot_l_2_linear_weight_golden_wu_out); // For single op tests

    // create bot_l_2_linear_weight_wu_out tensor
    const unsigned bot_l_2_linear_weight_wu_out_sizes[] = {512, 512};
    uint64_t bot_l_2_linear_weight_wu_out_dram;
    unsigned bot_l_2_linear_weight_wu_out_size = 512*512;
    unsigned bot_l_2_linear_weight_wu_out_size_in_bytes = bot_l_2_linear_weight_wu_out_size * sizeof(bfloat16) ;
    status = hbmAlloc(bot_l_2_linear_weight_wu_out_size_in_bytes, &bot_l_2_linear_weight_wu_out_dram, "bot_l_2_linear_weight_wu_out");
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_weight_wu_out dram malloc failed!");
    synLaunchTensorInfo bot_l_2_linear_weight_wu_out_tr_info = {"bot_l_2_linear_weight_wu_out",
                                                                bot_l_2_linear_weight_wu_out_dram};
    UNUSED(bot_l_2_linear_weight_wu_out_tr_info); // For single op tests
    synTensor bot_l_2_linear_weight_wu_out = createTensor(2U, syn_type_bf16, bot_l_2_linear_weight_wu_out_sizes, true, "bot_l_2_linear_weight_wu_out");
    UNUSED(bot_l_2_linear_weight_wu_out); // For single op tests

    synTensor bot_l_2_linear_weight_update_node_out_vec[2] = {bot_l_2_linear_weight_golden_wu_out, bot_l_2_linear_weight_wu_out};


    status = synNodeCreate(wuGraphHandle, bot_l_2_linear_weight_update_node_in_vec, bot_l_2_linear_weight_update_node_out_vec, 3, 2, (void *)&bot_l_2_linear_weight_update_node_kernel_params, sizeof(bot_l_2_linear_weight_update_node_kernel_params), "optimizer_sgd_bwd_f32", "bot_l_2_linear_weight_update_node", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bot_l_2_linear_weight_update_node failed!");

    /*************
     * bot_l_4_linear_weight_update_node node
     * inputs: [bot_l_4_linear_weight_grad_wu[32, 512](dtype=float32), bot_l_4_linear_weight_golden[32, 512](dtype=float32), learning_rate[1](dtype=float32)]
     * output: [bot_l_4_linear_weight_golden_wu_out(32, 512)(dtype=float32), bot_l_4_linear_weight_wu_out(32, 512)(dtype=bf16)]
     *************/
    ns_OptimizerSGD::Params bot_l_4_linear_weight_update_node_kernel_params;
    bot_l_4_linear_weight_update_node_kernel_params.wd = 0;
    bot_l_4_linear_weight_update_node_kernel_params.mom = 0;
    bot_l_4_linear_weight_update_node_kernel_params.damp = 0;
    bot_l_4_linear_weight_update_node_kernel_params.nesterov = false;

    // create bot_l_4_linear_weight_grad_wu tensor
    const unsigned bot_l_4_linear_weight_grad_wu_sizes[] = {32, 512};
    uint64_t bot_l_4_linear_weight_grad_wu_dram;
    unsigned bot_l_4_linear_weight_grad_wu_size = 32*512;
    unsigned bot_l_4_linear_weight_grad_wu_size_in_bytes = bot_l_4_linear_weight_grad_wu_size * sizeof(float) ;
    status = hbmAlloc(bot_l_4_linear_weight_grad_wu_size_in_bytes, &bot_l_4_linear_weight_grad_wu_dram, "bot_l_4_linear_weight_grad_wu");
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_weight_grad_wu dram malloc failed!");
    synLaunchTensorInfo bot_l_4_linear_weight_grad_wu_tr_info = {"bot_l_4_linear_weight_grad_wu",
                                                                 bot_l_4_linear_weight_grad_wu_dram};
    UNUSED(bot_l_4_linear_weight_grad_wu_tr_info); // For single op tests
    synTensor bot_l_4_linear_weight_grad_wu = createTensor(2U, syn_type_single, bot_l_4_linear_weight_grad_wu_sizes, true, "bot_l_4_linear_weight_grad_wu");
    UNUSED(bot_l_4_linear_weight_grad_wu); // For single op tests

    // create bot_l_4_linear_weight_golden tensor
    const unsigned bot_l_4_linear_weight_golden_sizes[] = {32, 512};
    uint64_t bot_l_4_linear_weight_golden_dram;
    unsigned bot_l_4_linear_weight_golden_size = 32*512;
    unsigned bot_l_4_linear_weight_golden_size_in_bytes = bot_l_4_linear_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(bot_l_4_linear_weight_golden_size_in_bytes, &bot_l_4_linear_weight_golden_dram, "bot_l_4_linear_weight_golden");
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_weight_golden dram malloc failed!");
    synLaunchTensorInfo bot_l_4_linear_weight_golden_tr_info = {"bot_l_4_linear_weight_golden",
                                                                bot_l_4_linear_weight_golden_dram};
    UNUSED(bot_l_4_linear_weight_golden_tr_info); // For single op tests
    synTensor bot_l_4_linear_weight_golden = createTensor(2U, syn_type_single, bot_l_4_linear_weight_golden_sizes, true, "bot_l_4_linear_weight_golden");
    UNUSED(bot_l_4_linear_weight_golden); // For single op tests

    synTensor bot_l_4_linear_weight_update_node_in_vec[3] = {bot_l_4_linear_weight_grad_wu, bot_l_4_linear_weight_golden, learning_rate};


    // create bot_l_4_linear_weight_golden_wu_out tensor
    const unsigned bot_l_4_linear_weight_golden_wu_out_sizes[] = {32, 512};
    uint64_t bot_l_4_linear_weight_golden_wu_out_dram;
    unsigned bot_l_4_linear_weight_golden_wu_out_size = 32*512;
    unsigned bot_l_4_linear_weight_golden_wu_out_size_in_bytes = bot_l_4_linear_weight_golden_wu_out_size * sizeof(float) ;
    status = hbmAlloc(bot_l_4_linear_weight_golden_wu_out_size_in_bytes, &bot_l_4_linear_weight_golden_wu_out_dram, "bot_l_4_linear_weight_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_weight_golden_wu_out dram malloc failed!");
    synLaunchTensorInfo bot_l_4_linear_weight_golden_wu_out_tr_info = {"bot_l_4_linear_weight_golden_wu_out",
                                                                       bot_l_4_linear_weight_golden_wu_out_dram};
    UNUSED(bot_l_4_linear_weight_golden_wu_out_tr_info); // For single op tests
    synTensor bot_l_4_linear_weight_golden_wu_out = createTensor(2U, syn_type_single, bot_l_4_linear_weight_golden_wu_out_sizes, true, "bot_l_4_linear_weight_golden_wu_out");
    UNUSED(bot_l_4_linear_weight_golden_wu_out); // For single op tests

    // create bot_l_4_linear_weight_wu_out tensor
    const unsigned bot_l_4_linear_weight_wu_out_sizes[] = {32, 512};
    uint64_t bot_l_4_linear_weight_wu_out_dram;
    unsigned bot_l_4_linear_weight_wu_out_size = 32*512;
    unsigned bot_l_4_linear_weight_wu_out_size_in_bytes = bot_l_4_linear_weight_wu_out_size * sizeof(bfloat16) ;
    status = hbmAlloc(bot_l_4_linear_weight_wu_out_size_in_bytes, &bot_l_4_linear_weight_wu_out_dram, "bot_l_4_linear_weight_wu_out");
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_weight_wu_out dram malloc failed!");
    synLaunchTensorInfo bot_l_4_linear_weight_wu_out_tr_info = {"bot_l_4_linear_weight_wu_out",
                                                                bot_l_4_linear_weight_wu_out_dram};
    UNUSED(bot_l_4_linear_weight_wu_out_tr_info); // For single op tests
    synTensor bot_l_4_linear_weight_wu_out = createTensor(2U, syn_type_bf16, bot_l_4_linear_weight_wu_out_sizes, true, "bot_l_4_linear_weight_wu_out");
    UNUSED(bot_l_4_linear_weight_wu_out); // For single op tests

    synTensor bot_l_4_linear_weight_update_node_out_vec[2] = {bot_l_4_linear_weight_golden_wu_out, bot_l_4_linear_weight_wu_out};


    status = synNodeCreate(wuGraphHandle, bot_l_4_linear_weight_update_node_in_vec, bot_l_4_linear_weight_update_node_out_vec, 3, 2, (void *)&bot_l_4_linear_weight_update_node_kernel_params, sizeof(bot_l_4_linear_weight_update_node_kernel_params), "optimizer_sgd_bwd_f32", "bot_l_4_linear_weight_update_node", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bot_l_4_linear_weight_update_node failed!");

    /*************
     * top_l_0_linear_weight_update_node node
     * inputs: [top_l_0_linear_weight_grad_wu[1024, 383](dtype=float32), top_l_0_linear_weight_golden[1024, 383](dtype=float32), learning_rate[1](dtype=float32)]
     * output: [top_l_0_linear_weight_golden_wu_out(1024, 383)(dtype=float32), top_l_0_linear_weight_wu_out(1024, 383)(dtype=bf16)]
     *************/
    ns_OptimizerSGD::Params top_l_0_linear_weight_update_node_kernel_params;
    top_l_0_linear_weight_update_node_kernel_params.wd = 0;
    top_l_0_linear_weight_update_node_kernel_params.mom = 0;
    top_l_0_linear_weight_update_node_kernel_params.damp = 0;
    top_l_0_linear_weight_update_node_kernel_params.nesterov = false;

    // create top_l_0_linear_weight_grad_wu tensor
    const unsigned top_l_0_linear_weight_grad_wu_sizes[] = {1024, 383};
    uint64_t top_l_0_linear_weight_grad_wu_dram;
    unsigned top_l_0_linear_weight_grad_wu_size = 1024*383;
    unsigned top_l_0_linear_weight_grad_wu_size_in_bytes = top_l_0_linear_weight_grad_wu_size * sizeof(float) ;
    status = hbmAlloc(top_l_0_linear_weight_grad_wu_size_in_bytes, &top_l_0_linear_weight_grad_wu_dram, "top_l_0_linear_weight_grad_wu");
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_weight_grad_wu dram malloc failed!");
    synLaunchTensorInfo top_l_0_linear_weight_grad_wu_tr_info = {"top_l_0_linear_weight_grad_wu",
                                                                 top_l_0_linear_weight_grad_wu_dram};
    UNUSED(top_l_0_linear_weight_grad_wu_tr_info); // For single op tests
    synTensor top_l_0_linear_weight_grad_wu = createTensor(2U, syn_type_single, top_l_0_linear_weight_grad_wu_sizes, true, "top_l_0_linear_weight_grad_wu");
    UNUSED(top_l_0_linear_weight_grad_wu); // For single op tests

    // create top_l_0_linear_weight_golden tensor
    const unsigned top_l_0_linear_weight_golden_sizes[] = {1024, 383};
    uint64_t top_l_0_linear_weight_golden_dram;
    unsigned top_l_0_linear_weight_golden_size = 1024*383;
    unsigned top_l_0_linear_weight_golden_size_in_bytes = top_l_0_linear_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(top_l_0_linear_weight_golden_size_in_bytes, &top_l_0_linear_weight_golden_dram, "top_l_0_linear_weight_golden");
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_weight_golden dram malloc failed!");
    synLaunchTensorInfo top_l_0_linear_weight_golden_tr_info = {"top_l_0_linear_weight_golden",
                                                                top_l_0_linear_weight_golden_dram};
    UNUSED(top_l_0_linear_weight_golden_tr_info); // For single op tests
    synTensor top_l_0_linear_weight_golden = createTensor(2U, syn_type_single, top_l_0_linear_weight_golden_sizes, true, "top_l_0_linear_weight_golden");
    UNUSED(top_l_0_linear_weight_golden); // For single op tests

    synTensor top_l_0_linear_weight_update_node_in_vec[3] = {top_l_0_linear_weight_grad_wu, top_l_0_linear_weight_golden, learning_rate};


    // create top_l_0_linear_weight_golden_wu_out tensor
    const unsigned top_l_0_linear_weight_golden_wu_out_sizes[] = {1024, 383};
    uint64_t top_l_0_linear_weight_golden_wu_out_dram;
    unsigned top_l_0_linear_weight_golden_wu_out_size = 1024*383;
    unsigned top_l_0_linear_weight_golden_wu_out_size_in_bytes = top_l_0_linear_weight_golden_wu_out_size * sizeof(float) ;
    status = hbmAlloc(top_l_0_linear_weight_golden_wu_out_size_in_bytes, &top_l_0_linear_weight_golden_wu_out_dram, "top_l_0_linear_weight_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_weight_golden_wu_out dram malloc failed!");
    synLaunchTensorInfo top_l_0_linear_weight_golden_wu_out_tr_info = {"top_l_0_linear_weight_golden_wu_out",
                                                                       top_l_0_linear_weight_golden_wu_out_dram};
    UNUSED(top_l_0_linear_weight_golden_wu_out_tr_info); // For single op tests
    synTensor top_l_0_linear_weight_golden_wu_out = createTensor(2U, syn_type_single, top_l_0_linear_weight_golden_wu_out_sizes, true, "top_l_0_linear_weight_golden_wu_out");
    UNUSED(top_l_0_linear_weight_golden_wu_out); // For single op tests

    // create top_l_0_linear_weight_wu_out tensor
    const unsigned top_l_0_linear_weight_wu_out_sizes[] = {1024, 383};
    uint64_t top_l_0_linear_weight_wu_out_dram;
    unsigned top_l_0_linear_weight_wu_out_size = 1024*383;
    unsigned top_l_0_linear_weight_wu_out_size_in_bytes = top_l_0_linear_weight_wu_out_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_0_linear_weight_wu_out_size_in_bytes, &top_l_0_linear_weight_wu_out_dram, "top_l_0_linear_weight_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_weight_wu_out dram malloc failed!");
    synLaunchTensorInfo top_l_0_linear_weight_wu_out_tr_info = {"top_l_0_linear_weight_wu_out",
                                                                top_l_0_linear_weight_wu_out_dram};
    UNUSED(top_l_0_linear_weight_wu_out_tr_info); // For single op tests
    synTensor top_l_0_linear_weight_wu_out = createTensor(2U, syn_type_bf16, top_l_0_linear_weight_wu_out_sizes, true, "top_l_0_linear_weight_wu_out");
    UNUSED(top_l_0_linear_weight_wu_out); // For single op tests

    synTensor top_l_0_linear_weight_update_node_out_vec[2] = {top_l_0_linear_weight_golden_wu_out, top_l_0_linear_weight_wu_out};


    status = synNodeCreate(wuGraphHandle, top_l_0_linear_weight_update_node_in_vec, top_l_0_linear_weight_update_node_out_vec, 3, 2, (void *)&top_l_0_linear_weight_update_node_kernel_params, sizeof(top_l_0_linear_weight_update_node_kernel_params), "optimizer_sgd_bwd_f32", "top_l_0_linear_weight_update_node", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_0_linear_weight_update_node failed!");

    /*************
     * top_l_2_linear_weight_update_node node
     * inputs: [top_l_2_linear_weight_grad_wu[1024, 1024](dtype=float32), top_l_2_linear_weight_golden[1024, 1024](dtype=float32), learning_rate[1](dtype=float32)]
     * output: [top_l_2_linear_weight_golden_wu_out(1024, 1024)(dtype=float32), top_l_2_linear_weight_wu_out(1024, 1024)(dtype=bf16)]
     *************/
    ns_OptimizerSGD::Params top_l_2_linear_weight_update_node_kernel_params;
    top_l_2_linear_weight_update_node_kernel_params.wd = 0;
    top_l_2_linear_weight_update_node_kernel_params.mom = 0;
    top_l_2_linear_weight_update_node_kernel_params.damp = 0;
    top_l_2_linear_weight_update_node_kernel_params.nesterov = false;

    // create top_l_2_linear_weight_grad_wu tensor
    const unsigned top_l_2_linear_weight_grad_wu_sizes[] = {1024, 1024};
    uint64_t top_l_2_linear_weight_grad_wu_dram;
    unsigned top_l_2_linear_weight_grad_wu_size = 1024*1024;
    unsigned top_l_2_linear_weight_grad_wu_size_in_bytes = top_l_2_linear_weight_grad_wu_size * sizeof(float) ;
    status = hbmAlloc(top_l_2_linear_weight_grad_wu_size_in_bytes, &top_l_2_linear_weight_grad_wu_dram, "top_l_2_linear_weight_grad_wu");
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_weight_grad_wu dram malloc failed!");
    synLaunchTensorInfo top_l_2_linear_weight_grad_wu_tr_info = {"top_l_2_linear_weight_grad_wu",
                                                                 top_l_2_linear_weight_grad_wu_dram};
    UNUSED(top_l_2_linear_weight_grad_wu_tr_info); // For single op tests
    synTensor top_l_2_linear_weight_grad_wu = createTensor(2U, syn_type_single, top_l_2_linear_weight_grad_wu_sizes, true, "top_l_2_linear_weight_grad_wu");
    UNUSED(top_l_2_linear_weight_grad_wu); // For single op tests

    // create top_l_2_linear_weight_golden tensor
    const unsigned top_l_2_linear_weight_golden_sizes[] = {1024, 1024};
    uint64_t top_l_2_linear_weight_golden_dram;
    unsigned top_l_2_linear_weight_golden_size = 1024*1024;
    unsigned top_l_2_linear_weight_golden_size_in_bytes = top_l_2_linear_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(top_l_2_linear_weight_golden_size_in_bytes, &top_l_2_linear_weight_golden_dram, "top_l_2_linear_weight_golden");
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_weight_golden dram malloc failed!");
    synLaunchTensorInfo top_l_2_linear_weight_golden_tr_info = {"top_l_2_linear_weight_golden",
                                                                top_l_2_linear_weight_golden_dram};
    UNUSED(top_l_2_linear_weight_golden_tr_info); // For single op tests
    synTensor top_l_2_linear_weight_golden = createTensor(2U, syn_type_single, top_l_2_linear_weight_golden_sizes, true, "top_l_2_linear_weight_golden");
    UNUSED(top_l_2_linear_weight_golden); // For single op tests

    synTensor top_l_2_linear_weight_update_node_in_vec[3] = {top_l_2_linear_weight_grad_wu, top_l_2_linear_weight_golden, learning_rate};


    // create top_l_2_linear_weight_golden_wu_out tensor
    const unsigned top_l_2_linear_weight_golden_wu_out_sizes[] = {1024, 1024};
    uint64_t top_l_2_linear_weight_golden_wu_out_dram;
    unsigned top_l_2_linear_weight_golden_wu_out_size = 1024*1024;
    unsigned top_l_2_linear_weight_golden_wu_out_size_in_bytes = top_l_2_linear_weight_golden_wu_out_size * sizeof(float) ;
    status = hbmAlloc(top_l_2_linear_weight_golden_wu_out_size_in_bytes, &top_l_2_linear_weight_golden_wu_out_dram, "top_l_2_linear_weight_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_weight_golden_wu_out dram malloc failed!");
    synLaunchTensorInfo top_l_2_linear_weight_golden_wu_out_tr_info = {"top_l_2_linear_weight_golden_wu_out",
                                                                       top_l_2_linear_weight_golden_wu_out_dram};
    UNUSED(top_l_2_linear_weight_golden_wu_out_tr_info); // For single op tests
    synTensor top_l_2_linear_weight_golden_wu_out = createTensor(2U, syn_type_single, top_l_2_linear_weight_golden_wu_out_sizes, true, "top_l_2_linear_weight_golden_wu_out");
    UNUSED(top_l_2_linear_weight_golden_wu_out); // For single op tests

    // create top_l_2_linear_weight_wu_out tensor
    const unsigned top_l_2_linear_weight_wu_out_sizes[] = {1024, 1024};
    uint64_t top_l_2_linear_weight_wu_out_dram;
    unsigned top_l_2_linear_weight_wu_out_size = 1024*1024;
    unsigned top_l_2_linear_weight_wu_out_size_in_bytes = top_l_2_linear_weight_wu_out_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_2_linear_weight_wu_out_size_in_bytes, &top_l_2_linear_weight_wu_out_dram, "top_l_2_linear_weight_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_weight_wu_out dram malloc failed!");
    synLaunchTensorInfo top_l_2_linear_weight_wu_out_tr_info = {"top_l_2_linear_weight_wu_out",
                                                                top_l_2_linear_weight_wu_out_dram};
    UNUSED(top_l_2_linear_weight_wu_out_tr_info); // For single op tests
    synTensor top_l_2_linear_weight_wu_out = createTensor(2U, syn_type_bf16, top_l_2_linear_weight_wu_out_sizes, true, "top_l_2_linear_weight_wu_out");
    UNUSED(top_l_2_linear_weight_wu_out); // For single op tests

    synTensor top_l_2_linear_weight_update_node_out_vec[2] = {top_l_2_linear_weight_golden_wu_out, top_l_2_linear_weight_wu_out};


    status = synNodeCreate(wuGraphHandle, top_l_2_linear_weight_update_node_in_vec, top_l_2_linear_weight_update_node_out_vec, 3, 2, (void *)&top_l_2_linear_weight_update_node_kernel_params, sizeof(top_l_2_linear_weight_update_node_kernel_params), "optimizer_sgd_bwd_f32", "top_l_2_linear_weight_update_node", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_2_linear_weight_update_node failed!");

    /*************
     * top_l_4_linear_weight_update_node node
     * inputs: [top_l_4_linear_weight_grad_wu[1024, 1024](dtype=float32), top_l_4_linear_weight_golden[1024, 1024](dtype=float32), learning_rate[1](dtype=float32)]
     * output: [top_l_4_linear_weight_golden_wu_out(1024, 1024)(dtype=float32), top_l_4_linear_weight_wu_out(1024, 1024)(dtype=bf16)]
     *************/
    ns_OptimizerSGD::Params top_l_4_linear_weight_update_node_kernel_params;
    top_l_4_linear_weight_update_node_kernel_params.wd = 0;
    top_l_4_linear_weight_update_node_kernel_params.mom = 0;
    top_l_4_linear_weight_update_node_kernel_params.damp = 0;
    top_l_4_linear_weight_update_node_kernel_params.nesterov = false;

    // create top_l_4_linear_weight_grad_wu tensor
    const unsigned top_l_4_linear_weight_grad_wu_sizes[] = {1024, 1024};
    uint64_t top_l_4_linear_weight_grad_wu_dram;
    unsigned top_l_4_linear_weight_grad_wu_size = 1024*1024;
    unsigned top_l_4_linear_weight_grad_wu_size_in_bytes = top_l_4_linear_weight_grad_wu_size * sizeof(float) ;
    status = hbmAlloc(top_l_4_linear_weight_grad_wu_size_in_bytes, &top_l_4_linear_weight_grad_wu_dram, "top_l_4_linear_weight_grad_wu");
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_weight_grad_wu dram malloc failed!");
    synLaunchTensorInfo top_l_4_linear_weight_grad_wu_tr_info = {"top_l_4_linear_weight_grad_wu",
                                                                 top_l_4_linear_weight_grad_wu_dram};
    UNUSED(top_l_4_linear_weight_grad_wu_tr_info); // For single op tests
    synTensor top_l_4_linear_weight_grad_wu = createTensor(2U, syn_type_single, top_l_4_linear_weight_grad_wu_sizes, true, "top_l_4_linear_weight_grad_wu");
    UNUSED(top_l_4_linear_weight_grad_wu); // For single op tests

    // create top_l_4_linear_weight_golden tensor
    const unsigned top_l_4_linear_weight_golden_sizes[] = {1024, 1024};
    uint64_t top_l_4_linear_weight_golden_dram;
    unsigned top_l_4_linear_weight_golden_size = 1024*1024;
    unsigned top_l_4_linear_weight_golden_size_in_bytes = top_l_4_linear_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(top_l_4_linear_weight_golden_size_in_bytes, &top_l_4_linear_weight_golden_dram, "top_l_4_linear_weight_golden");
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_weight_golden dram malloc failed!");
    synLaunchTensorInfo top_l_4_linear_weight_golden_tr_info = {"top_l_4_linear_weight_golden",
                                                                top_l_4_linear_weight_golden_dram};
    UNUSED(top_l_4_linear_weight_golden_tr_info); // For single op tests
    synTensor top_l_4_linear_weight_golden = createTensor(2U, syn_type_single, top_l_4_linear_weight_golden_sizes, true, "top_l_4_linear_weight_golden");
    UNUSED(top_l_4_linear_weight_golden); // For single op tests

    synTensor top_l_4_linear_weight_update_node_in_vec[3] = {top_l_4_linear_weight_grad_wu, top_l_4_linear_weight_golden, learning_rate};


    // create top_l_4_linear_weight_golden_wu_out tensor
    const unsigned top_l_4_linear_weight_golden_wu_out_sizes[] = {1024, 1024};
    uint64_t top_l_4_linear_weight_golden_wu_out_dram;
    unsigned top_l_4_linear_weight_golden_wu_out_size = 1024*1024;
    unsigned top_l_4_linear_weight_golden_wu_out_size_in_bytes = top_l_4_linear_weight_golden_wu_out_size * sizeof(float) ;
    status = hbmAlloc(top_l_4_linear_weight_golden_wu_out_size_in_bytes, &top_l_4_linear_weight_golden_wu_out_dram, "top_l_4_linear_weight_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_weight_golden_wu_out dram malloc failed!");
    synLaunchTensorInfo top_l_4_linear_weight_golden_wu_out_tr_info = {"top_l_4_linear_weight_golden_wu_out",
                                                                       top_l_4_linear_weight_golden_wu_out_dram};
    UNUSED(top_l_4_linear_weight_golden_wu_out_tr_info); // For single op tests
    synTensor top_l_4_linear_weight_golden_wu_out = createTensor(2U, syn_type_single, top_l_4_linear_weight_golden_wu_out_sizes, true, "top_l_4_linear_weight_golden_wu_out");
    UNUSED(top_l_4_linear_weight_golden_wu_out); // For single op tests

    // create top_l_4_linear_weight_wu_out tensor
    const unsigned top_l_4_linear_weight_wu_out_sizes[] = {1024, 1024};
    uint64_t top_l_4_linear_weight_wu_out_dram;
    unsigned top_l_4_linear_weight_wu_out_size = 1024*1024;
    unsigned top_l_4_linear_weight_wu_out_size_in_bytes = top_l_4_linear_weight_wu_out_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_4_linear_weight_wu_out_size_in_bytes, &top_l_4_linear_weight_wu_out_dram, "top_l_4_linear_weight_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_weight_wu_out dram malloc failed!");
    synLaunchTensorInfo top_l_4_linear_weight_wu_out_tr_info = {"top_l_4_linear_weight_wu_out",
                                                                top_l_4_linear_weight_wu_out_dram};
    UNUSED(top_l_4_linear_weight_wu_out_tr_info); // For single op tests
    synTensor top_l_4_linear_weight_wu_out = createTensor(2U, syn_type_bf16, top_l_4_linear_weight_wu_out_sizes, true, "top_l_4_linear_weight_wu_out");
    UNUSED(top_l_4_linear_weight_wu_out); // For single op tests

    synTensor top_l_4_linear_weight_update_node_out_vec[2] = {top_l_4_linear_weight_golden_wu_out, top_l_4_linear_weight_wu_out};


    status = synNodeCreate(wuGraphHandle, top_l_4_linear_weight_update_node_in_vec, top_l_4_linear_weight_update_node_out_vec, 3, 2, (void *)&top_l_4_linear_weight_update_node_kernel_params, sizeof(top_l_4_linear_weight_update_node_kernel_params), "optimizer_sgd_bwd_f32", "top_l_4_linear_weight_update_node", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_4_linear_weight_update_node failed!");

    /*************
     * top_l_6_linear_weight_update_node node
     * inputs: [top_l_6_linear_weight_grad_wu[1024, 1024](dtype=float32), top_l_6_linear_weight_golden[1024, 1024](dtype=float32), learning_rate[1](dtype=float32)]
     * output: [top_l_6_linear_weight_golden_wu_out(1024, 1024)(dtype=float32), top_l_6_linear_weight_wu_out(1024, 1024)(dtype=bf16)]
     *************/
    ns_OptimizerSGD::Params top_l_6_linear_weight_update_node_kernel_params;
    top_l_6_linear_weight_update_node_kernel_params.wd = 0;
    top_l_6_linear_weight_update_node_kernel_params.mom = 0;
    top_l_6_linear_weight_update_node_kernel_params.damp = 0;
    top_l_6_linear_weight_update_node_kernel_params.nesterov = false;

    // create top_l_6_linear_weight_grad_wu tensor
    const unsigned top_l_6_linear_weight_grad_wu_sizes[] = {1024, 1024};
    uint64_t top_l_6_linear_weight_grad_wu_dram;
    unsigned top_l_6_linear_weight_grad_wu_size = 1024*1024;
    unsigned top_l_6_linear_weight_grad_wu_size_in_bytes = top_l_6_linear_weight_grad_wu_size * sizeof(float) ;
    status = hbmAlloc(top_l_6_linear_weight_grad_wu_size_in_bytes, &top_l_6_linear_weight_grad_wu_dram, "top_l_6_linear_weight_grad_wu");
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_weight_grad_wu dram malloc failed!");
    synLaunchTensorInfo top_l_6_linear_weight_grad_wu_tr_info = {"top_l_6_linear_weight_grad_wu",
                                                                 top_l_6_linear_weight_grad_wu_dram};
    UNUSED(top_l_6_linear_weight_grad_wu_tr_info); // For single op tests
    synTensor top_l_6_linear_weight_grad_wu = createTensor(2U, syn_type_single, top_l_6_linear_weight_grad_wu_sizes, true, "top_l_6_linear_weight_grad_wu");
    UNUSED(top_l_6_linear_weight_grad_wu); // For single op tests

    // create top_l_6_linear_weight_golden tensor
    const unsigned top_l_6_linear_weight_golden_sizes[] = {1024, 1024};
    uint64_t top_l_6_linear_weight_golden_dram;
    unsigned top_l_6_linear_weight_golden_size = 1024*1024;
    unsigned top_l_6_linear_weight_golden_size_in_bytes = top_l_6_linear_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(top_l_6_linear_weight_golden_size_in_bytes, &top_l_6_linear_weight_golden_dram, "top_l_6_linear_weight_golden");
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_weight_golden dram malloc failed!");
    synLaunchTensorInfo top_l_6_linear_weight_golden_tr_info = {"top_l_6_linear_weight_golden",
                                                                top_l_6_linear_weight_golden_dram};
    UNUSED(top_l_6_linear_weight_golden_tr_info); // For single op tests
    synTensor top_l_6_linear_weight_golden = createTensor(2U, syn_type_single, top_l_6_linear_weight_golden_sizes, true, "top_l_6_linear_weight_golden");
    UNUSED(top_l_6_linear_weight_golden); // For single op tests

    synTensor top_l_6_linear_weight_update_node_in_vec[3] = {top_l_6_linear_weight_grad_wu, top_l_6_linear_weight_golden, learning_rate};


    // create top_l_6_linear_weight_golden_wu_out tensor
    const unsigned top_l_6_linear_weight_golden_wu_out_sizes[] = {1024, 1024};
    uint64_t top_l_6_linear_weight_golden_wu_out_dram;
    unsigned top_l_6_linear_weight_golden_wu_out_size = 1024*1024;
    unsigned top_l_6_linear_weight_golden_wu_out_size_in_bytes = top_l_6_linear_weight_golden_wu_out_size * sizeof(float) ;
    status = hbmAlloc(top_l_6_linear_weight_golden_wu_out_size_in_bytes, &top_l_6_linear_weight_golden_wu_out_dram, "top_l_6_linear_weight_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_weight_golden_wu_out dram malloc failed!");
    synLaunchTensorInfo top_l_6_linear_weight_golden_wu_out_tr_info = {"top_l_6_linear_weight_golden_wu_out",
                                                                       top_l_6_linear_weight_golden_wu_out_dram};
    UNUSED(top_l_6_linear_weight_golden_wu_out_tr_info); // For single op tests
    synTensor top_l_6_linear_weight_golden_wu_out = createTensor(2U, syn_type_single, top_l_6_linear_weight_golden_wu_out_sizes, true, "top_l_6_linear_weight_golden_wu_out");
    UNUSED(top_l_6_linear_weight_golden_wu_out); // For single op tests

    // create top_l_6_linear_weight_wu_out tensor
    const unsigned top_l_6_linear_weight_wu_out_sizes[] = {1024, 1024};
    uint64_t top_l_6_linear_weight_wu_out_dram;
    unsigned top_l_6_linear_weight_wu_out_size = 1024*1024;
    unsigned top_l_6_linear_weight_wu_out_size_in_bytes = top_l_6_linear_weight_wu_out_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_6_linear_weight_wu_out_size_in_bytes, &top_l_6_linear_weight_wu_out_dram, "top_l_6_linear_weight_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_weight_wu_out dram malloc failed!");
    synLaunchTensorInfo top_l_6_linear_weight_wu_out_tr_info = {"top_l_6_linear_weight_wu_out",
                                                                top_l_6_linear_weight_wu_out_dram};
    UNUSED(top_l_6_linear_weight_wu_out_tr_info); // For single op tests
    synTensor top_l_6_linear_weight_wu_out = createTensor(2U, syn_type_bf16, top_l_6_linear_weight_wu_out_sizes, true, "top_l_6_linear_weight_wu_out");
    UNUSED(top_l_6_linear_weight_wu_out); // For single op tests

    synTensor top_l_6_linear_weight_update_node_out_vec[2] = {top_l_6_linear_weight_golden_wu_out, top_l_6_linear_weight_wu_out};


    status = synNodeCreate(wuGraphHandle, top_l_6_linear_weight_update_node_in_vec, top_l_6_linear_weight_update_node_out_vec, 3, 2, (void *)&top_l_6_linear_weight_update_node_kernel_params, sizeof(top_l_6_linear_weight_update_node_kernel_params), "optimizer_sgd_bwd_f32", "top_l_6_linear_weight_update_node", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_6_linear_weight_update_node failed!");

    /*************
     * top_l_8_linear_weight_update_node node
     * inputs: [top_l_8_linear_weight_grad_wu[1024, 1024](dtype=float32), top_l_8_linear_weight_golden[1024, 1024](dtype=float32), learning_rate[1](dtype=float32)]
     * output: [top_l_8_linear_weight_golden_wu_out(1024, 1024)(dtype=float32), top_l_8_linear_weight_wu_out(1024, 1024)(dtype=bf16)]
     *************/
    ns_OptimizerSGD::Params top_l_8_linear_weight_update_node_kernel_params;
    top_l_8_linear_weight_update_node_kernel_params.wd = 0;
    top_l_8_linear_weight_update_node_kernel_params.mom = 0;
    top_l_8_linear_weight_update_node_kernel_params.damp = 0;
    top_l_8_linear_weight_update_node_kernel_params.nesterov = false;

    // create top_l_8_linear_weight_grad_wu tensor
    const unsigned top_l_8_linear_weight_grad_wu_sizes[] = {1024, 1024};
    uint64_t top_l_8_linear_weight_grad_wu_dram;
    unsigned top_l_8_linear_weight_grad_wu_size = 1024*1024;
    unsigned top_l_8_linear_weight_grad_wu_size_in_bytes = top_l_8_linear_weight_grad_wu_size * sizeof(float) ;
    status = hbmAlloc(top_l_8_linear_weight_grad_wu_size_in_bytes, &top_l_8_linear_weight_grad_wu_dram, "top_l_8_linear_weight_grad_wu");
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_weight_grad_wu dram malloc failed!");
    synLaunchTensorInfo top_l_8_linear_weight_grad_wu_tr_info = {"top_l_8_linear_weight_grad_wu",
                                                                 top_l_8_linear_weight_grad_wu_dram};
    UNUSED(top_l_8_linear_weight_grad_wu_tr_info); // For single op tests
    synTensor top_l_8_linear_weight_grad_wu = createTensor(2U, syn_type_single, top_l_8_linear_weight_grad_wu_sizes, true, "top_l_8_linear_weight_grad_wu");
    UNUSED(top_l_8_linear_weight_grad_wu); // For single op tests

    // create top_l_8_linear_weight_golden tensor
    const unsigned top_l_8_linear_weight_golden_sizes[] = {1024, 1024};
    uint64_t top_l_8_linear_weight_golden_dram;
    unsigned top_l_8_linear_weight_golden_size = 1024*1024;
    unsigned top_l_8_linear_weight_golden_size_in_bytes = top_l_8_linear_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(top_l_8_linear_weight_golden_size_in_bytes, &top_l_8_linear_weight_golden_dram, "top_l_8_linear_weight_golden");
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_weight_golden dram malloc failed!");
    synLaunchTensorInfo top_l_8_linear_weight_golden_tr_info = {"top_l_8_linear_weight_golden",
                                                                top_l_8_linear_weight_golden_dram};
    UNUSED(top_l_8_linear_weight_golden_tr_info); // For single op tests
    synTensor top_l_8_linear_weight_golden = createTensor(2U, syn_type_single, top_l_8_linear_weight_golden_sizes, true, "top_l_8_linear_weight_golden");
    UNUSED(top_l_8_linear_weight_golden); // For single op tests

    synTensor top_l_8_linear_weight_update_node_in_vec[3] = {top_l_8_linear_weight_grad_wu, top_l_8_linear_weight_golden, learning_rate};


    // create top_l_8_linear_weight_golden_wu_out tensor
    const unsigned top_l_8_linear_weight_golden_wu_out_sizes[] = {1024, 1024};
    uint64_t top_l_8_linear_weight_golden_wu_out_dram;
    unsigned top_l_8_linear_weight_golden_wu_out_size = 1024*1024;
    unsigned top_l_8_linear_weight_golden_wu_out_size_in_bytes = top_l_8_linear_weight_golden_wu_out_size * sizeof(float) ;
    status = hbmAlloc(top_l_8_linear_weight_golden_wu_out_size_in_bytes, &top_l_8_linear_weight_golden_wu_out_dram, "top_l_8_linear_weight_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_weight_golden_wu_out dram malloc failed!");
    synLaunchTensorInfo top_l_8_linear_weight_golden_wu_out_tr_info = {"top_l_8_linear_weight_golden_wu_out",
                                                                       top_l_8_linear_weight_golden_wu_out_dram};
    UNUSED(top_l_8_linear_weight_golden_wu_out_tr_info); // For single op tests
    synTensor top_l_8_linear_weight_golden_wu_out = createTensor(2U, syn_type_single, top_l_8_linear_weight_golden_wu_out_sizes, true, "top_l_8_linear_weight_golden_wu_out");
    UNUSED(top_l_8_linear_weight_golden_wu_out); // For single op tests

    // create top_l_8_linear_weight_wu_out tensor
    const unsigned top_l_8_linear_weight_wu_out_sizes[] = {1024, 1024};
    uint64_t top_l_8_linear_weight_wu_out_dram;
    unsigned top_l_8_linear_weight_wu_out_size = 1024*1024;
    unsigned top_l_8_linear_weight_wu_out_size_in_bytes = top_l_8_linear_weight_wu_out_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_8_linear_weight_wu_out_size_in_bytes, &top_l_8_linear_weight_wu_out_dram, "top_l_8_linear_weight_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_weight_wu_out dram malloc failed!");
    synLaunchTensorInfo top_l_8_linear_weight_wu_out_tr_info = {"top_l_8_linear_weight_wu_out",
                                                                top_l_8_linear_weight_wu_out_dram};
    UNUSED(top_l_8_linear_weight_wu_out_tr_info); // For single op tests
    synTensor top_l_8_linear_weight_wu_out = createTensor(2U, syn_type_bf16, top_l_8_linear_weight_wu_out_sizes, true, "top_l_8_linear_weight_wu_out");
    UNUSED(top_l_8_linear_weight_wu_out); // For single op tests

    synTensor top_l_8_linear_weight_update_node_out_vec[2] = {top_l_8_linear_weight_golden_wu_out, top_l_8_linear_weight_wu_out};


    status = synNodeCreate(wuGraphHandle, top_l_8_linear_weight_update_node_in_vec, top_l_8_linear_weight_update_node_out_vec, 3, 2, (void *)&top_l_8_linear_weight_update_node_kernel_params, sizeof(top_l_8_linear_weight_update_node_kernel_params), "optimizer_sgd_bwd_f32", "top_l_8_linear_weight_update_node", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_8_linear_weight_update_node failed!");

    /*************
     * top_l_10_linear_weight_update_node node
     * inputs: [top_l_10_linear_weight_grad_wu[1, 1024](dtype=float32), top_l_10_linear_weight_golden[1, 1024](dtype=float32), learning_rate[1](dtype=float32)]
     * output: [top_l_10_linear_weight_golden_wu_out(1, 1024)(dtype=float32), top_l_10_linear_weight_wu_out(1, 1024)(dtype=bf16)]
     *************/
    ns_OptimizerSGD::Params top_l_10_linear_weight_update_node_kernel_params;
    top_l_10_linear_weight_update_node_kernel_params.wd = 0;
    top_l_10_linear_weight_update_node_kernel_params.mom = 0;
    top_l_10_linear_weight_update_node_kernel_params.damp = 0;
    top_l_10_linear_weight_update_node_kernel_params.nesterov = false;

    // create top_l_10_linear_weight_grad_wu tensor
    const unsigned top_l_10_linear_weight_grad_wu_sizes[] = {1, 1024};
    uint64_t top_l_10_linear_weight_grad_wu_dram;
    unsigned top_l_10_linear_weight_grad_wu_size = 1*1024;
    unsigned top_l_10_linear_weight_grad_wu_size_in_bytes = top_l_10_linear_weight_grad_wu_size * sizeof(float) ;
    status = hbmAlloc(top_l_10_linear_weight_grad_wu_size_in_bytes, &top_l_10_linear_weight_grad_wu_dram, "top_l_10_linear_weight_grad_wu");
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_weight_grad_wu dram malloc failed!");
    synLaunchTensorInfo top_l_10_linear_weight_grad_wu_tr_info = {"top_l_10_linear_weight_grad_wu",
                                                                  top_l_10_linear_weight_grad_wu_dram};
    UNUSED(top_l_10_linear_weight_grad_wu_tr_info); // For single op tests
    synTensor top_l_10_linear_weight_grad_wu = createTensor(2U, syn_type_single, top_l_10_linear_weight_grad_wu_sizes, true, "top_l_10_linear_weight_grad_wu");
    UNUSED(top_l_10_linear_weight_grad_wu); // For single op tests

    // create top_l_10_linear_weight_golden tensor
    const unsigned top_l_10_linear_weight_golden_sizes[] = {1, 1024};
    uint64_t top_l_10_linear_weight_golden_dram;
    unsigned top_l_10_linear_weight_golden_size = 1*1024;
    unsigned top_l_10_linear_weight_golden_size_in_bytes = top_l_10_linear_weight_golden_size * sizeof(float) ;
    status = hbmAlloc(top_l_10_linear_weight_golden_size_in_bytes, &top_l_10_linear_weight_golden_dram, "top_l_10_linear_weight_golden");
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_weight_golden dram malloc failed!");
    synLaunchTensorInfo top_l_10_linear_weight_golden_tr_info = {"top_l_10_linear_weight_golden",
                                                                 top_l_10_linear_weight_golden_dram};
    UNUSED(top_l_10_linear_weight_golden_tr_info); // For single op tests
    synTensor top_l_10_linear_weight_golden = createTensor(2U, syn_type_single, top_l_10_linear_weight_golden_sizes, true, "top_l_10_linear_weight_golden");
    UNUSED(top_l_10_linear_weight_golden); // For single op tests

    synTensor top_l_10_linear_weight_update_node_in_vec[3] = {top_l_10_linear_weight_grad_wu, top_l_10_linear_weight_golden, learning_rate};


    // create top_l_10_linear_weight_golden_wu_out tensor
    const unsigned top_l_10_linear_weight_golden_wu_out_sizes[] = {1, 1024};
    uint64_t top_l_10_linear_weight_golden_wu_out_dram;
    unsigned top_l_10_linear_weight_golden_wu_out_size = 1*1024;
    unsigned top_l_10_linear_weight_golden_wu_out_size_in_bytes = top_l_10_linear_weight_golden_wu_out_size * sizeof(float) ;
    status = hbmAlloc(top_l_10_linear_weight_golden_wu_out_size_in_bytes, &top_l_10_linear_weight_golden_wu_out_dram, "top_l_10_linear_weight_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_weight_golden_wu_out dram malloc failed!");
    synLaunchTensorInfo top_l_10_linear_weight_golden_wu_out_tr_info = {"top_l_10_linear_weight_golden_wu_out",
                                                                        top_l_10_linear_weight_golden_wu_out_dram};
    UNUSED(top_l_10_linear_weight_golden_wu_out_tr_info); // For single op tests
    synTensor top_l_10_linear_weight_golden_wu_out = createTensor(2U, syn_type_single, top_l_10_linear_weight_golden_wu_out_sizes, true, "top_l_10_linear_weight_golden_wu_out");
    UNUSED(top_l_10_linear_weight_golden_wu_out); // For single op tests

    // create top_l_10_linear_weight_wu_out tensor
    const unsigned top_l_10_linear_weight_wu_out_sizes[] = {1, 1024};
    uint64_t top_l_10_linear_weight_wu_out_dram;
    unsigned top_l_10_linear_weight_wu_out_size = 1*1024;
    unsigned top_l_10_linear_weight_wu_out_size_in_bytes = top_l_10_linear_weight_wu_out_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_10_linear_weight_wu_out_size_in_bytes, &top_l_10_linear_weight_wu_out_dram, "top_l_10_linear_weight_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_weight_wu_out dram malloc failed!");
    synLaunchTensorInfo top_l_10_linear_weight_wu_out_tr_info = {"top_l_10_linear_weight_wu_out",
                                                                 top_l_10_linear_weight_wu_out_dram};
    UNUSED(top_l_10_linear_weight_wu_out_tr_info); // For single op tests
    synTensor top_l_10_linear_weight_wu_out = createTensor(2U, syn_type_bf16, top_l_10_linear_weight_wu_out_sizes, true, "top_l_10_linear_weight_wu_out");
    UNUSED(top_l_10_linear_weight_wu_out); // For single op tests

    synTensor top_l_10_linear_weight_update_node_out_vec[2] = {top_l_10_linear_weight_golden_wu_out, top_l_10_linear_weight_wu_out};


    status = synNodeCreate(wuGraphHandle, top_l_10_linear_weight_update_node_in_vec, top_l_10_linear_weight_update_node_out_vec, 3, 2, (void *)&top_l_10_linear_weight_update_node_kernel_params, sizeof(top_l_10_linear_weight_update_node_kernel_params), "optimizer_sgd_bwd_f32", "top_l_10_linear_weight_update_node", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_10_linear_weight_update_node failed!");

    /*************
     * bot_l_0_linear_bias_update_node node
     * inputs: [bot_l_0_linear_bias_grad_wu[512](dtype=float32), bot_l_0_linear_bias_golden[512](dtype=float32), learning_rate[1](dtype=float32)]
     * output: [bot_l_0_linear_bias_golden_wu_out(512,)(dtype=float32), bot_l_0_linear_bias_wu_out(512,)(dtype=bf16)]
     *************/
    ns_OptimizerSGD::Params bot_l_0_linear_bias_update_node_kernel_params;
    bot_l_0_linear_bias_update_node_kernel_params.wd = 0;
    bot_l_0_linear_bias_update_node_kernel_params.mom = 0;
    bot_l_0_linear_bias_update_node_kernel_params.damp = 0;
    bot_l_0_linear_bias_update_node_kernel_params.nesterov = false;

    // create bot_l_0_linear_bias_grad_wu tensor
    const unsigned bot_l_0_linear_bias_grad_wu_sizes[] = {512,};
    uint64_t bot_l_0_linear_bias_grad_wu_dram;
    unsigned bot_l_0_linear_bias_grad_wu_size = 512;
    unsigned bot_l_0_linear_bias_grad_wu_size_in_bytes = bot_l_0_linear_bias_grad_wu_size * sizeof(float) ;
    status = hbmAlloc(bot_l_0_linear_bias_grad_wu_size_in_bytes, &bot_l_0_linear_bias_grad_wu_dram, "bot_l_0_linear_bias_grad_wu");
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_bias_grad_wu dram malloc failed!");
    synLaunchTensorInfo bot_l_0_linear_bias_grad_wu_tr_info = {"bot_l_0_linear_bias_grad_wu",
                                                               bot_l_0_linear_bias_grad_wu_dram};
    UNUSED(bot_l_0_linear_bias_grad_wu_tr_info); // For single op tests
    synTensor bot_l_0_linear_bias_grad_wu = createTensor(1U, syn_type_single, bot_l_0_linear_bias_grad_wu_sizes, true, "bot_l_0_linear_bias_grad_wu");
    UNUSED(bot_l_0_linear_bias_grad_wu); // For single op tests

    // create bot_l_0_linear_bias_golden tensor
    const unsigned bot_l_0_linear_bias_golden_sizes[] = {512,};
    uint64_t bot_l_0_linear_bias_golden_dram;
    unsigned bot_l_0_linear_bias_golden_size = 512;
    unsigned bot_l_0_linear_bias_golden_size_in_bytes = bot_l_0_linear_bias_golden_size * sizeof(float) ;
    status = hbmAlloc(bot_l_0_linear_bias_golden_size_in_bytes, &bot_l_0_linear_bias_golden_dram, "bot_l_0_linear_bias_golden");
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_bias_golden dram malloc failed!");
    synLaunchTensorInfo bot_l_0_linear_bias_golden_tr_info = {"bot_l_0_linear_bias_golden",
                                                              bot_l_0_linear_bias_golden_dram};
    UNUSED(bot_l_0_linear_bias_golden_tr_info); // For single op tests
    synTensor bot_l_0_linear_bias_golden = createTensor(1U, syn_type_single, bot_l_0_linear_bias_golden_sizes, true, "bot_l_0_linear_bias_golden");
    UNUSED(bot_l_0_linear_bias_golden); // For single op tests

    synTensor bot_l_0_linear_bias_update_node_in_vec[3] = {bot_l_0_linear_bias_grad_wu, bot_l_0_linear_bias_golden, learning_rate};


    // create bot_l_0_linear_bias_golden_wu_out tensor
    const unsigned bot_l_0_linear_bias_golden_wu_out_sizes[] = {512,};
    uint64_t bot_l_0_linear_bias_golden_wu_out_dram;
    unsigned bot_l_0_linear_bias_golden_wu_out_size = 512;
    unsigned bot_l_0_linear_bias_golden_wu_out_size_in_bytes = bot_l_0_linear_bias_golden_wu_out_size * sizeof(float) ;
    status = hbmAlloc(bot_l_0_linear_bias_golden_wu_out_size_in_bytes, &bot_l_0_linear_bias_golden_wu_out_dram, "bot_l_0_linear_bias_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_bias_golden_wu_out dram malloc failed!");
    synLaunchTensorInfo bot_l_0_linear_bias_golden_wu_out_tr_info = {"bot_l_0_linear_bias_golden_wu_out",
                                                                     bot_l_0_linear_bias_golden_wu_out_dram};
    UNUSED(bot_l_0_linear_bias_golden_wu_out_tr_info); // For single op tests
    synTensor bot_l_0_linear_bias_golden_wu_out = createTensor(1U, syn_type_single, bot_l_0_linear_bias_golden_wu_out_sizes, true, "bot_l_0_linear_bias_golden_wu_out");
    UNUSED(bot_l_0_linear_bias_golden_wu_out); // For single op tests

    // create bot_l_0_linear_bias_wu_out tensor
    const unsigned bot_l_0_linear_bias_wu_out_sizes[] = {512,};
    uint64_t bot_l_0_linear_bias_wu_out_dram;
    unsigned bot_l_0_linear_bias_wu_out_size = 512;
    unsigned bot_l_0_linear_bias_wu_out_size_in_bytes = bot_l_0_linear_bias_wu_out_size * sizeof(bfloat16) ;
    status = hbmAlloc(bot_l_0_linear_bias_wu_out_size_in_bytes, &bot_l_0_linear_bias_wu_out_dram, "bot_l_0_linear_bias_wu_out");
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_bias_wu_out dram malloc failed!");
    synLaunchTensorInfo bot_l_0_linear_bias_wu_out_tr_info = {"bot_l_0_linear_bias_wu_out",
                                                              bot_l_0_linear_bias_wu_out_dram};
    UNUSED(bot_l_0_linear_bias_wu_out_tr_info); // For single op tests
    synTensor bot_l_0_linear_bias_wu_out = createTensor(1U, syn_type_bf16, bot_l_0_linear_bias_wu_out_sizes, true, "bot_l_0_linear_bias_wu_out");
    UNUSED(bot_l_0_linear_bias_wu_out); // For single op tests

    synTensor bot_l_0_linear_bias_update_node_out_vec[2] = {bot_l_0_linear_bias_golden_wu_out, bot_l_0_linear_bias_wu_out};


    status = synNodeCreate(wuGraphHandle, bot_l_0_linear_bias_update_node_in_vec, bot_l_0_linear_bias_update_node_out_vec, 3, 2, (void *)&bot_l_0_linear_bias_update_node_kernel_params, sizeof(bot_l_0_linear_bias_update_node_kernel_params), "optimizer_sgd_bwd_f32", "bot_l_0_linear_bias_update_node", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bot_l_0_linear_bias_update_node failed!");

    /*************
     * bot_l_2_linear_bias_update_node node
     * inputs: [bot_l_2_linear_bias_grad_wu[512](dtype=float32), bot_l_2_linear_bias_golden[512](dtype=float32), learning_rate[1](dtype=float32)]
     * output: [bot_l_2_linear_bias_golden_wu_out(512,)(dtype=float32), bot_l_2_linear_bias_wu_out(512,)(dtype=bf16)]
     *************/
    ns_OptimizerSGD::Params bot_l_2_linear_bias_update_node_kernel_params;
    bot_l_2_linear_bias_update_node_kernel_params.wd = 0;
    bot_l_2_linear_bias_update_node_kernel_params.mom = 0;
    bot_l_2_linear_bias_update_node_kernel_params.damp = 0;
    bot_l_2_linear_bias_update_node_kernel_params.nesterov = false;

    // create bot_l_2_linear_bias_grad_wu tensor
    const unsigned bot_l_2_linear_bias_grad_wu_sizes[] = {512,};
    uint64_t bot_l_2_linear_bias_grad_wu_dram;
    unsigned bot_l_2_linear_bias_grad_wu_size = 512;
    unsigned bot_l_2_linear_bias_grad_wu_size_in_bytes = bot_l_2_linear_bias_grad_wu_size * sizeof(float) ;
    status = hbmAlloc(bot_l_2_linear_bias_grad_wu_size_in_bytes, &bot_l_2_linear_bias_grad_wu_dram, "bot_l_2_linear_bias_grad_wu");
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_bias_grad_wu dram malloc failed!");
    synLaunchTensorInfo bot_l_2_linear_bias_grad_wu_tr_info = {"bot_l_2_linear_bias_grad_wu",
                                                               bot_l_2_linear_bias_grad_wu_dram};
    UNUSED(bot_l_2_linear_bias_grad_wu_tr_info); // For single op tests
    synTensor bot_l_2_linear_bias_grad_wu = createTensor(1U, syn_type_single, bot_l_2_linear_bias_grad_wu_sizes, true, "bot_l_2_linear_bias_grad_wu");
    UNUSED(bot_l_2_linear_bias_grad_wu); // For single op tests

    // create bot_l_2_linear_bias_golden tensor
    const unsigned bot_l_2_linear_bias_golden_sizes[] = {512,};
    uint64_t bot_l_2_linear_bias_golden_dram;
    unsigned bot_l_2_linear_bias_golden_size = 512;
    unsigned bot_l_2_linear_bias_golden_size_in_bytes = bot_l_2_linear_bias_golden_size * sizeof(float) ;
    status = hbmAlloc(bot_l_2_linear_bias_golden_size_in_bytes, &bot_l_2_linear_bias_golden_dram, "bot_l_2_linear_bias_golden");
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_bias_golden dram malloc failed!");
    synLaunchTensorInfo bot_l_2_linear_bias_golden_tr_info = {"bot_l_2_linear_bias_golden",
                                                              bot_l_2_linear_bias_golden_dram};
    UNUSED(bot_l_2_linear_bias_golden_tr_info); // For single op tests
    synTensor bot_l_2_linear_bias_golden = createTensor(1U, syn_type_single, bot_l_2_linear_bias_golden_sizes, true, "bot_l_2_linear_bias_golden");
    UNUSED(bot_l_2_linear_bias_golden); // For single op tests

    synTensor bot_l_2_linear_bias_update_node_in_vec[3] = {bot_l_2_linear_bias_grad_wu, bot_l_2_linear_bias_golden, learning_rate};


    // create bot_l_2_linear_bias_golden_wu_out tensor
    const unsigned bot_l_2_linear_bias_golden_wu_out_sizes[] = {512,};
    uint64_t bot_l_2_linear_bias_golden_wu_out_dram;
    unsigned bot_l_2_linear_bias_golden_wu_out_size = 512;
    unsigned bot_l_2_linear_bias_golden_wu_out_size_in_bytes = bot_l_2_linear_bias_golden_wu_out_size * sizeof(float) ;
    status = hbmAlloc(bot_l_2_linear_bias_golden_wu_out_size_in_bytes, &bot_l_2_linear_bias_golden_wu_out_dram, "bot_l_2_linear_bias_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_bias_golden_wu_out dram malloc failed!");
    synLaunchTensorInfo bot_l_2_linear_bias_golden_wu_out_tr_info = {"bot_l_2_linear_bias_golden_wu_out",
                                                                     bot_l_2_linear_bias_golden_wu_out_dram};
    UNUSED(bot_l_2_linear_bias_golden_wu_out_tr_info); // For single op tests
    synTensor bot_l_2_linear_bias_golden_wu_out = createTensor(1U, syn_type_single, bot_l_2_linear_bias_golden_wu_out_sizes, true, "bot_l_2_linear_bias_golden_wu_out");
    UNUSED(bot_l_2_linear_bias_golden_wu_out); // For single op tests

    // create bot_l_2_linear_bias_wu_out tensor
    const unsigned bot_l_2_linear_bias_wu_out_sizes[] = {512,};
    uint64_t bot_l_2_linear_bias_wu_out_dram;
    unsigned bot_l_2_linear_bias_wu_out_size = 512;
    unsigned bot_l_2_linear_bias_wu_out_size_in_bytes = bot_l_2_linear_bias_wu_out_size * sizeof(bfloat16) ;
    status = hbmAlloc(bot_l_2_linear_bias_wu_out_size_in_bytes, &bot_l_2_linear_bias_wu_out_dram, "bot_l_2_linear_bias_wu_out");
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_bias_wu_out dram malloc failed!");
    synLaunchTensorInfo bot_l_2_linear_bias_wu_out_tr_info = {"bot_l_2_linear_bias_wu_out",
                                                              bot_l_2_linear_bias_wu_out_dram};
    UNUSED(bot_l_2_linear_bias_wu_out_tr_info); // For single op tests
    synTensor bot_l_2_linear_bias_wu_out = createTensor(1U, syn_type_bf16, bot_l_2_linear_bias_wu_out_sizes, true, "bot_l_2_linear_bias_wu_out");
    UNUSED(bot_l_2_linear_bias_wu_out); // For single op tests

    synTensor bot_l_2_linear_bias_update_node_out_vec[2] = {bot_l_2_linear_bias_golden_wu_out, bot_l_2_linear_bias_wu_out};


    status = synNodeCreate(wuGraphHandle, bot_l_2_linear_bias_update_node_in_vec, bot_l_2_linear_bias_update_node_out_vec, 3, 2, (void *)&bot_l_2_linear_bias_update_node_kernel_params, sizeof(bot_l_2_linear_bias_update_node_kernel_params), "optimizer_sgd_bwd_f32", "bot_l_2_linear_bias_update_node", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bot_l_2_linear_bias_update_node failed!");

    /*************
     * bot_l_4_linear_bias_update_node node
     * inputs: [bot_l_4_linear_bias_grad_wu[32](dtype=float32), bot_l_4_linear_bias_golden[32](dtype=float32), learning_rate[1](dtype=float32)]
     * output: [bot_l_4_linear_bias_golden_wu_out(32,)(dtype=float32), bot_l_4_linear_bias_wu_out(32,)(dtype=bf16)]
     *************/
    ns_OptimizerSGD::Params bot_l_4_linear_bias_update_node_kernel_params;
    bot_l_4_linear_bias_update_node_kernel_params.wd = 0;
    bot_l_4_linear_bias_update_node_kernel_params.mom = 0;
    bot_l_4_linear_bias_update_node_kernel_params.damp = 0;
    bot_l_4_linear_bias_update_node_kernel_params.nesterov = false;

    // create bot_l_4_linear_bias_grad_wu tensor
    const unsigned bot_l_4_linear_bias_grad_wu_sizes[] = {32,};
    uint64_t bot_l_4_linear_bias_grad_wu_dram;
    unsigned bot_l_4_linear_bias_grad_wu_size = 32;
    unsigned bot_l_4_linear_bias_grad_wu_size_in_bytes = bot_l_4_linear_bias_grad_wu_size * sizeof(float) ;
    status = hbmAlloc(bot_l_4_linear_bias_grad_wu_size_in_bytes, &bot_l_4_linear_bias_grad_wu_dram, "bot_l_4_linear_bias_grad_wu");
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_bias_grad_wu dram malloc failed!");
    synLaunchTensorInfo bot_l_4_linear_bias_grad_wu_tr_info = {"bot_l_4_linear_bias_grad_wu",
                                                               bot_l_4_linear_bias_grad_wu_dram};
    UNUSED(bot_l_4_linear_bias_grad_wu_tr_info); // For single op tests
    synTensor bot_l_4_linear_bias_grad_wu = createTensor(1U, syn_type_single, bot_l_4_linear_bias_grad_wu_sizes, true, "bot_l_4_linear_bias_grad_wu");
    UNUSED(bot_l_4_linear_bias_grad_wu); // For single op tests

    // create bot_l_4_linear_bias_golden tensor
    const unsigned bot_l_4_linear_bias_golden_sizes[] = {32,};
    uint64_t bot_l_4_linear_bias_golden_dram;
    unsigned bot_l_4_linear_bias_golden_size = 32;
    unsigned bot_l_4_linear_bias_golden_size_in_bytes = bot_l_4_linear_bias_golden_size * sizeof(float) ;
    status = hbmAlloc(bot_l_4_linear_bias_golden_size_in_bytes, &bot_l_4_linear_bias_golden_dram, "bot_l_4_linear_bias_golden");
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_bias_golden dram malloc failed!");
    synLaunchTensorInfo bot_l_4_linear_bias_golden_tr_info = {"bot_l_4_linear_bias_golden",
                                                              bot_l_4_linear_bias_golden_dram};
    UNUSED(bot_l_4_linear_bias_golden_tr_info); // For single op tests
    synTensor bot_l_4_linear_bias_golden = createTensor(1U, syn_type_single, bot_l_4_linear_bias_golden_sizes, true, "bot_l_4_linear_bias_golden");
    UNUSED(bot_l_4_linear_bias_golden); // For single op tests

    synTensor bot_l_4_linear_bias_update_node_in_vec[3] = {bot_l_4_linear_bias_grad_wu, bot_l_4_linear_bias_golden, learning_rate};


    // create bot_l_4_linear_bias_golden_wu_out tensor
    const unsigned bot_l_4_linear_bias_golden_wu_out_sizes[] = {32,};
    uint64_t bot_l_4_linear_bias_golden_wu_out_dram;
    unsigned bot_l_4_linear_bias_golden_wu_out_size = 32;
    unsigned bot_l_4_linear_bias_golden_wu_out_size_in_bytes = bot_l_4_linear_bias_golden_wu_out_size * sizeof(float) ;
    status = hbmAlloc(bot_l_4_linear_bias_golden_wu_out_size_in_bytes, &bot_l_4_linear_bias_golden_wu_out_dram, "bot_l_4_linear_bias_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_bias_golden_wu_out dram malloc failed!");
    synLaunchTensorInfo bot_l_4_linear_bias_golden_wu_out_tr_info = {"bot_l_4_linear_bias_golden_wu_out",
                                                                     bot_l_4_linear_bias_golden_wu_out_dram};
    UNUSED(bot_l_4_linear_bias_golden_wu_out_tr_info); // For single op tests
    synTensor bot_l_4_linear_bias_golden_wu_out = createTensor(1U, syn_type_single, bot_l_4_linear_bias_golden_wu_out_sizes, true, "bot_l_4_linear_bias_golden_wu_out");
    UNUSED(bot_l_4_linear_bias_golden_wu_out); // For single op tests

    // create bot_l_4_linear_bias_wu_out tensor
    const unsigned bot_l_4_linear_bias_wu_out_sizes[] = {32,};
    uint64_t bot_l_4_linear_bias_wu_out_dram;
    unsigned bot_l_4_linear_bias_wu_out_size = 32;
    unsigned bot_l_4_linear_bias_wu_out_size_in_bytes = bot_l_4_linear_bias_wu_out_size * sizeof(bfloat16) ;
    status = hbmAlloc(bot_l_4_linear_bias_wu_out_size_in_bytes, &bot_l_4_linear_bias_wu_out_dram, "bot_l_4_linear_bias_wu_out");
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_bias_wu_out dram malloc failed!");
    synLaunchTensorInfo bot_l_4_linear_bias_wu_out_tr_info = {"bot_l_4_linear_bias_wu_out",
                                                              bot_l_4_linear_bias_wu_out_dram};
    UNUSED(bot_l_4_linear_bias_wu_out_tr_info); // For single op tests
    synTensor bot_l_4_linear_bias_wu_out = createTensor(1U, syn_type_bf16, bot_l_4_linear_bias_wu_out_sizes, true, "bot_l_4_linear_bias_wu_out");
    UNUSED(bot_l_4_linear_bias_wu_out); // For single op tests

    synTensor bot_l_4_linear_bias_update_node_out_vec[2] = {bot_l_4_linear_bias_golden_wu_out, bot_l_4_linear_bias_wu_out};


    status = synNodeCreate(wuGraphHandle, bot_l_4_linear_bias_update_node_in_vec, bot_l_4_linear_bias_update_node_out_vec, 3, 2, (void *)&bot_l_4_linear_bias_update_node_kernel_params, sizeof(bot_l_4_linear_bias_update_node_kernel_params), "optimizer_sgd_bwd_f32", "bot_l_4_linear_bias_update_node", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for bot_l_4_linear_bias_update_node failed!");

    /*************
     * top_l_0_linear_bias_update_node node
     * inputs: [top_l_0_linear_bias_grad_wu[1024](dtype=float32), top_l_0_linear_bias_golden[1024](dtype=float32), learning_rate[1](dtype=float32)]
     * output: [top_l_0_linear_bias_golden_wu_out(1024,)(dtype=float32), top_l_0_linear_bias_wu_out(1024,)(dtype=bf16)]
     *************/
    ns_OptimizerSGD::Params top_l_0_linear_bias_update_node_kernel_params;
    top_l_0_linear_bias_update_node_kernel_params.wd = 0;
    top_l_0_linear_bias_update_node_kernel_params.mom = 0;
    top_l_0_linear_bias_update_node_kernel_params.damp = 0;
    top_l_0_linear_bias_update_node_kernel_params.nesterov = false;

    // create top_l_0_linear_bias_grad_wu tensor
    const unsigned top_l_0_linear_bias_grad_wu_sizes[] = {1024,};
    uint64_t top_l_0_linear_bias_grad_wu_dram;
    unsigned top_l_0_linear_bias_grad_wu_size = 1024;
    unsigned top_l_0_linear_bias_grad_wu_size_in_bytes = top_l_0_linear_bias_grad_wu_size * sizeof(float) ;
    status = hbmAlloc(top_l_0_linear_bias_grad_wu_size_in_bytes, &top_l_0_linear_bias_grad_wu_dram, "top_l_0_linear_bias_grad_wu");
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_bias_grad_wu dram malloc failed!");
    synLaunchTensorInfo top_l_0_linear_bias_grad_wu_tr_info = {"top_l_0_linear_bias_grad_wu",
                                                               top_l_0_linear_bias_grad_wu_dram};
    UNUSED(top_l_0_linear_bias_grad_wu_tr_info); // For single op tests
    synTensor top_l_0_linear_bias_grad_wu = createTensor(1U, syn_type_single, top_l_0_linear_bias_grad_wu_sizes, true, "top_l_0_linear_bias_grad_wu");
    UNUSED(top_l_0_linear_bias_grad_wu); // For single op tests

    // create top_l_0_linear_bias_golden tensor
    const unsigned top_l_0_linear_bias_golden_sizes[] = {1024,};
    uint64_t top_l_0_linear_bias_golden_dram;
    unsigned top_l_0_linear_bias_golden_size = 1024;
    unsigned top_l_0_linear_bias_golden_size_in_bytes = top_l_0_linear_bias_golden_size * sizeof(float) ;
    status = hbmAlloc(top_l_0_linear_bias_golden_size_in_bytes, &top_l_0_linear_bias_golden_dram, "top_l_0_linear_bias_golden");
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_bias_golden dram malloc failed!");
    synLaunchTensorInfo top_l_0_linear_bias_golden_tr_info = {"top_l_0_linear_bias_golden",
                                                              top_l_0_linear_bias_golden_dram};
    UNUSED(top_l_0_linear_bias_golden_tr_info); // For single op tests
    synTensor top_l_0_linear_bias_golden = createTensor(1U, syn_type_single, top_l_0_linear_bias_golden_sizes, true, "top_l_0_linear_bias_golden");
    UNUSED(top_l_0_linear_bias_golden); // For single op tests

    synTensor top_l_0_linear_bias_update_node_in_vec[3] = {top_l_0_linear_bias_grad_wu, top_l_0_linear_bias_golden, learning_rate};


    // create top_l_0_linear_bias_golden_wu_out tensor
    const unsigned top_l_0_linear_bias_golden_wu_out_sizes[] = {1024,};
    uint64_t top_l_0_linear_bias_golden_wu_out_dram;
    unsigned top_l_0_linear_bias_golden_wu_out_size = 1024;
    unsigned top_l_0_linear_bias_golden_wu_out_size_in_bytes = top_l_0_linear_bias_golden_wu_out_size * sizeof(float) ;
    status = hbmAlloc(top_l_0_linear_bias_golden_wu_out_size_in_bytes, &top_l_0_linear_bias_golden_wu_out_dram, "top_l_0_linear_bias_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_bias_golden_wu_out dram malloc failed!");
    synLaunchTensorInfo top_l_0_linear_bias_golden_wu_out_tr_info = {"top_l_0_linear_bias_golden_wu_out",
                                                                     top_l_0_linear_bias_golden_wu_out_dram};
    UNUSED(top_l_0_linear_bias_golden_wu_out_tr_info); // For single op tests
    synTensor top_l_0_linear_bias_golden_wu_out = createTensor(1U, syn_type_single, top_l_0_linear_bias_golden_wu_out_sizes, true, "top_l_0_linear_bias_golden_wu_out");
    UNUSED(top_l_0_linear_bias_golden_wu_out); // For single op tests

    // create top_l_0_linear_bias_wu_out tensor
    const unsigned top_l_0_linear_bias_wu_out_sizes[] = {1024,};
    uint64_t top_l_0_linear_bias_wu_out_dram;
    unsigned top_l_0_linear_bias_wu_out_size = 1024;
    unsigned top_l_0_linear_bias_wu_out_size_in_bytes = top_l_0_linear_bias_wu_out_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_0_linear_bias_wu_out_size_in_bytes, &top_l_0_linear_bias_wu_out_dram, "top_l_0_linear_bias_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_bias_wu_out dram malloc failed!");
    synLaunchTensorInfo top_l_0_linear_bias_wu_out_tr_info = {"top_l_0_linear_bias_wu_out",
                                                              top_l_0_linear_bias_wu_out_dram};
    UNUSED(top_l_0_linear_bias_wu_out_tr_info); // For single op tests
    synTensor top_l_0_linear_bias_wu_out = createTensor(1U, syn_type_bf16, top_l_0_linear_bias_wu_out_sizes, true, "top_l_0_linear_bias_wu_out");
    UNUSED(top_l_0_linear_bias_wu_out); // For single op tests

    synTensor top_l_0_linear_bias_update_node_out_vec[2] = {top_l_0_linear_bias_golden_wu_out, top_l_0_linear_bias_wu_out};


    status = synNodeCreate(wuGraphHandle, top_l_0_linear_bias_update_node_in_vec, top_l_0_linear_bias_update_node_out_vec, 3, 2, (void *)&top_l_0_linear_bias_update_node_kernel_params, sizeof(top_l_0_linear_bias_update_node_kernel_params), "optimizer_sgd_bwd_f32", "top_l_0_linear_bias_update_node", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_0_linear_bias_update_node failed!");

    /*************
     * top_l_2_linear_bias_update_node node
     * inputs: [top_l_2_linear_bias_grad_wu[1024](dtype=float32), top_l_2_linear_bias_golden[1024](dtype=float32), learning_rate[1](dtype=float32)]
     * output: [top_l_2_linear_bias_golden_wu_out(1024,)(dtype=float32), top_l_2_linear_bias_wu_out(1024,)(dtype=bf16)]
     *************/
    ns_OptimizerSGD::Params top_l_2_linear_bias_update_node_kernel_params;
    top_l_2_linear_bias_update_node_kernel_params.wd = 0;
    top_l_2_linear_bias_update_node_kernel_params.mom = 0;
    top_l_2_linear_bias_update_node_kernel_params.damp = 0;
    top_l_2_linear_bias_update_node_kernel_params.nesterov = false;

    // create top_l_2_linear_bias_grad_wu tensor
    const unsigned top_l_2_linear_bias_grad_wu_sizes[] = {1024,};
    uint64_t top_l_2_linear_bias_grad_wu_dram;
    unsigned top_l_2_linear_bias_grad_wu_size = 1024;
    unsigned top_l_2_linear_bias_grad_wu_size_in_bytes = top_l_2_linear_bias_grad_wu_size * sizeof(float) ;
    status = hbmAlloc(top_l_2_linear_bias_grad_wu_size_in_bytes, &top_l_2_linear_bias_grad_wu_dram, "top_l_2_linear_bias_grad_wu");
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_bias_grad_wu dram malloc failed!");
    synLaunchTensorInfo top_l_2_linear_bias_grad_wu_tr_info = {"top_l_2_linear_bias_grad_wu",
                                                               top_l_2_linear_bias_grad_wu_dram};
    UNUSED(top_l_2_linear_bias_grad_wu_tr_info); // For single op tests
    synTensor top_l_2_linear_bias_grad_wu = createTensor(1U, syn_type_single, top_l_2_linear_bias_grad_wu_sizes, true, "top_l_2_linear_bias_grad_wu");
    UNUSED(top_l_2_linear_bias_grad_wu); // For single op tests

    // create top_l_2_linear_bias_golden tensor
    const unsigned top_l_2_linear_bias_golden_sizes[] = {1024,};
    uint64_t top_l_2_linear_bias_golden_dram;
    unsigned top_l_2_linear_bias_golden_size = 1024;
    unsigned top_l_2_linear_bias_golden_size_in_bytes = top_l_2_linear_bias_golden_size * sizeof(float) ;
    status = hbmAlloc(top_l_2_linear_bias_golden_size_in_bytes, &top_l_2_linear_bias_golden_dram, "top_l_2_linear_bias_golden");
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_bias_golden dram malloc failed!");
    synLaunchTensorInfo top_l_2_linear_bias_golden_tr_info = {"top_l_2_linear_bias_golden",
                                                              top_l_2_linear_bias_golden_dram};
    UNUSED(top_l_2_linear_bias_golden_tr_info); // For single op tests
    synTensor top_l_2_linear_bias_golden = createTensor(1U, syn_type_single, top_l_2_linear_bias_golden_sizes, true, "top_l_2_linear_bias_golden");
    UNUSED(top_l_2_linear_bias_golden); // For single op tests

    synTensor top_l_2_linear_bias_update_node_in_vec[3] = {top_l_2_linear_bias_grad_wu, top_l_2_linear_bias_golden, learning_rate};


    // create top_l_2_linear_bias_golden_wu_out tensor
    const unsigned top_l_2_linear_bias_golden_wu_out_sizes[] = {1024,};
    uint64_t top_l_2_linear_bias_golden_wu_out_dram;
    unsigned top_l_2_linear_bias_golden_wu_out_size = 1024;
    unsigned top_l_2_linear_bias_golden_wu_out_size_in_bytes = top_l_2_linear_bias_golden_wu_out_size * sizeof(float) ;
    status = hbmAlloc(top_l_2_linear_bias_golden_wu_out_size_in_bytes, &top_l_2_linear_bias_golden_wu_out_dram, "top_l_2_linear_bias_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_bias_golden_wu_out dram malloc failed!");
    synLaunchTensorInfo top_l_2_linear_bias_golden_wu_out_tr_info = {"top_l_2_linear_bias_golden_wu_out",
                                                                     top_l_2_linear_bias_golden_wu_out_dram};
    UNUSED(top_l_2_linear_bias_golden_wu_out_tr_info); // For single op tests
    synTensor top_l_2_linear_bias_golden_wu_out = createTensor(1U, syn_type_single, top_l_2_linear_bias_golden_wu_out_sizes, true, "top_l_2_linear_bias_golden_wu_out");
    UNUSED(top_l_2_linear_bias_golden_wu_out); // For single op tests

    // create top_l_2_linear_bias_wu_out tensor
    const unsigned top_l_2_linear_bias_wu_out_sizes[] = {1024,};
    uint64_t top_l_2_linear_bias_wu_out_dram;
    unsigned top_l_2_linear_bias_wu_out_size = 1024;
    unsigned top_l_2_linear_bias_wu_out_size_in_bytes = top_l_2_linear_bias_wu_out_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_2_linear_bias_wu_out_size_in_bytes, &top_l_2_linear_bias_wu_out_dram, "top_l_2_linear_bias_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_bias_wu_out dram malloc failed!");
    synLaunchTensorInfo top_l_2_linear_bias_wu_out_tr_info = {"top_l_2_linear_bias_wu_out",
                                                              top_l_2_linear_bias_wu_out_dram};
    UNUSED(top_l_2_linear_bias_wu_out_tr_info); // For single op tests
    synTensor top_l_2_linear_bias_wu_out = createTensor(1U, syn_type_bf16, top_l_2_linear_bias_wu_out_sizes, true, "top_l_2_linear_bias_wu_out");
    UNUSED(top_l_2_linear_bias_wu_out); // For single op tests

    synTensor top_l_2_linear_bias_update_node_out_vec[2] = {top_l_2_linear_bias_golden_wu_out, top_l_2_linear_bias_wu_out};


    status = synNodeCreate(wuGraphHandle, top_l_2_linear_bias_update_node_in_vec, top_l_2_linear_bias_update_node_out_vec, 3, 2, (void *)&top_l_2_linear_bias_update_node_kernel_params, sizeof(top_l_2_linear_bias_update_node_kernel_params), "optimizer_sgd_bwd_f32", "top_l_2_linear_bias_update_node", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_2_linear_bias_update_node failed!");

    /*************
     * top_l_4_linear_bias_update_node node
     * inputs: [top_l_4_linear_bias_grad_wu[1024](dtype=float32), top_l_4_linear_bias_golden[1024](dtype=float32), learning_rate[1](dtype=float32)]
     * output: [top_l_4_linear_bias_golden_wu_out(1024,)(dtype=float32), top_l_4_linear_bias_wu_out(1024,)(dtype=bf16)]
     *************/
    ns_OptimizerSGD::Params top_l_4_linear_bias_update_node_kernel_params;
    top_l_4_linear_bias_update_node_kernel_params.wd = 0;
    top_l_4_linear_bias_update_node_kernel_params.mom = 0;
    top_l_4_linear_bias_update_node_kernel_params.damp = 0;
    top_l_4_linear_bias_update_node_kernel_params.nesterov = false;

    // create top_l_4_linear_bias_grad_wu tensor
    const unsigned top_l_4_linear_bias_grad_wu_sizes[] = {1024,};
    uint64_t top_l_4_linear_bias_grad_wu_dram;
    unsigned top_l_4_linear_bias_grad_wu_size = 1024;
    unsigned top_l_4_linear_bias_grad_wu_size_in_bytes = top_l_4_linear_bias_grad_wu_size * sizeof(float) ;
    status = hbmAlloc(top_l_4_linear_bias_grad_wu_size_in_bytes, &top_l_4_linear_bias_grad_wu_dram, "top_l_4_linear_bias_grad_wu");
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_bias_grad_wu dram malloc failed!");
    synLaunchTensorInfo top_l_4_linear_bias_grad_wu_tr_info = {"top_l_4_linear_bias_grad_wu",
                                                               top_l_4_linear_bias_grad_wu_dram};
    UNUSED(top_l_4_linear_bias_grad_wu_tr_info); // For single op tests
    synTensor top_l_4_linear_bias_grad_wu = createTensor(1U, syn_type_single, top_l_4_linear_bias_grad_wu_sizes, true, "top_l_4_linear_bias_grad_wu");
    UNUSED(top_l_4_linear_bias_grad_wu); // For single op tests

    // create top_l_4_linear_bias_golden tensor
    const unsigned top_l_4_linear_bias_golden_sizes[] = {1024,};
    uint64_t top_l_4_linear_bias_golden_dram;
    unsigned top_l_4_linear_bias_golden_size = 1024;
    unsigned top_l_4_linear_bias_golden_size_in_bytes = top_l_4_linear_bias_golden_size * sizeof(float) ;
    status = hbmAlloc(top_l_4_linear_bias_golden_size_in_bytes, &top_l_4_linear_bias_golden_dram, "top_l_4_linear_bias_golden");
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_bias_golden dram malloc failed!");
    synLaunchTensorInfo top_l_4_linear_bias_golden_tr_info = {"top_l_4_linear_bias_golden",
                                                              top_l_4_linear_bias_golden_dram};
    UNUSED(top_l_4_linear_bias_golden_tr_info); // For single op tests
    synTensor top_l_4_linear_bias_golden = createTensor(1U, syn_type_single, top_l_4_linear_bias_golden_sizes, true, "top_l_4_linear_bias_golden");
    UNUSED(top_l_4_linear_bias_golden); // For single op tests

    synTensor top_l_4_linear_bias_update_node_in_vec[3] = {top_l_4_linear_bias_grad_wu, top_l_4_linear_bias_golden, learning_rate};


    // create top_l_4_linear_bias_golden_wu_out tensor
    const unsigned top_l_4_linear_bias_golden_wu_out_sizes[] = {1024,};
    uint64_t top_l_4_linear_bias_golden_wu_out_dram;
    unsigned top_l_4_linear_bias_golden_wu_out_size = 1024;
    unsigned top_l_4_linear_bias_golden_wu_out_size_in_bytes = top_l_4_linear_bias_golden_wu_out_size * sizeof(float) ;
    status = hbmAlloc(top_l_4_linear_bias_golden_wu_out_size_in_bytes, &top_l_4_linear_bias_golden_wu_out_dram, "top_l_4_linear_bias_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_bias_golden_wu_out dram malloc failed!");
    synLaunchTensorInfo top_l_4_linear_bias_golden_wu_out_tr_info = {"top_l_4_linear_bias_golden_wu_out",
                                                                     top_l_4_linear_bias_golden_wu_out_dram};
    UNUSED(top_l_4_linear_bias_golden_wu_out_tr_info); // For single op tests
    synTensor top_l_4_linear_bias_golden_wu_out = createTensor(1U, syn_type_single, top_l_4_linear_bias_golden_wu_out_sizes, true, "top_l_4_linear_bias_golden_wu_out");
    UNUSED(top_l_4_linear_bias_golden_wu_out); // For single op tests

    // create top_l_4_linear_bias_wu_out tensor
    const unsigned top_l_4_linear_bias_wu_out_sizes[] = {1024,};
    uint64_t top_l_4_linear_bias_wu_out_dram;
    unsigned top_l_4_linear_bias_wu_out_size = 1024;
    unsigned top_l_4_linear_bias_wu_out_size_in_bytes = top_l_4_linear_bias_wu_out_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_4_linear_bias_wu_out_size_in_bytes, &top_l_4_linear_bias_wu_out_dram, "top_l_4_linear_bias_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_bias_wu_out dram malloc failed!");
    synLaunchTensorInfo top_l_4_linear_bias_wu_out_tr_info = {"top_l_4_linear_bias_wu_out",
                                                              top_l_4_linear_bias_wu_out_dram};
    UNUSED(top_l_4_linear_bias_wu_out_tr_info); // For single op tests
    synTensor top_l_4_linear_bias_wu_out = createTensor(1U, syn_type_bf16, top_l_4_linear_bias_wu_out_sizes, true, "top_l_4_linear_bias_wu_out");
    UNUSED(top_l_4_linear_bias_wu_out); // For single op tests

    synTensor top_l_4_linear_bias_update_node_out_vec[2] = {top_l_4_linear_bias_golden_wu_out, top_l_4_linear_bias_wu_out};


    status = synNodeCreate(wuGraphHandle, top_l_4_linear_bias_update_node_in_vec, top_l_4_linear_bias_update_node_out_vec, 3, 2, (void *)&top_l_4_linear_bias_update_node_kernel_params, sizeof(top_l_4_linear_bias_update_node_kernel_params), "optimizer_sgd_bwd_f32", "top_l_4_linear_bias_update_node", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_4_linear_bias_update_node failed!");

    /*************
     * top_l_6_linear_bias_update_node node
     * inputs: [top_l_6_linear_bias_grad_wu[1024](dtype=float32), top_l_6_linear_bias_golden[1024](dtype=float32), learning_rate[1](dtype=float32)]
     * output: [top_l_6_linear_bias_golden_wu_out(1024,)(dtype=float32), top_l_6_linear_bias_wu_out(1024,)(dtype=bf16)]
     *************/
    ns_OptimizerSGD::Params top_l_6_linear_bias_update_node_kernel_params;
    top_l_6_linear_bias_update_node_kernel_params.wd = 0;
    top_l_6_linear_bias_update_node_kernel_params.mom = 0;
    top_l_6_linear_bias_update_node_kernel_params.damp = 0;
    top_l_6_linear_bias_update_node_kernel_params.nesterov = false;

    // create top_l_6_linear_bias_grad_wu tensor
    const unsigned top_l_6_linear_bias_grad_wu_sizes[] = {1024,};
    uint64_t top_l_6_linear_bias_grad_wu_dram;
    unsigned top_l_6_linear_bias_grad_wu_size = 1024;
    unsigned top_l_6_linear_bias_grad_wu_size_in_bytes = top_l_6_linear_bias_grad_wu_size * sizeof(float) ;
    status = hbmAlloc(top_l_6_linear_bias_grad_wu_size_in_bytes, &top_l_6_linear_bias_grad_wu_dram, "top_l_6_linear_bias_grad_wu");
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_bias_grad_wu dram malloc failed!");
    synLaunchTensorInfo top_l_6_linear_bias_grad_wu_tr_info = {"top_l_6_linear_bias_grad_wu",
                                                               top_l_6_linear_bias_grad_wu_dram};
    UNUSED(top_l_6_linear_bias_grad_wu_tr_info); // For single op tests
    synTensor top_l_6_linear_bias_grad_wu = createTensor(1U, syn_type_single, top_l_6_linear_bias_grad_wu_sizes, true, "top_l_6_linear_bias_grad_wu");
    UNUSED(top_l_6_linear_bias_grad_wu); // For single op tests

    // create top_l_6_linear_bias_golden tensor
    const unsigned top_l_6_linear_bias_golden_sizes[] = {1024,};
    uint64_t top_l_6_linear_bias_golden_dram;
    unsigned top_l_6_linear_bias_golden_size = 1024;
    unsigned top_l_6_linear_bias_golden_size_in_bytes = top_l_6_linear_bias_golden_size * sizeof(float) ;
    status = hbmAlloc(top_l_6_linear_bias_golden_size_in_bytes, &top_l_6_linear_bias_golden_dram, "top_l_6_linear_bias_golden");
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_bias_golden dram malloc failed!");
    synLaunchTensorInfo top_l_6_linear_bias_golden_tr_info = {"top_l_6_linear_bias_golden",
                                                              top_l_6_linear_bias_golden_dram};
    UNUSED(top_l_6_linear_bias_golden_tr_info); // For single op tests
    synTensor top_l_6_linear_bias_golden = createTensor(1U, syn_type_single, top_l_6_linear_bias_golden_sizes, true, "top_l_6_linear_bias_golden");
    UNUSED(top_l_6_linear_bias_golden); // For single op tests

    synTensor top_l_6_linear_bias_update_node_in_vec[3] = {top_l_6_linear_bias_grad_wu, top_l_6_linear_bias_golden, learning_rate};


    // create top_l_6_linear_bias_golden_wu_out tensor
    const unsigned top_l_6_linear_bias_golden_wu_out_sizes[] = {1024,};
    uint64_t top_l_6_linear_bias_golden_wu_out_dram;
    unsigned top_l_6_linear_bias_golden_wu_out_size = 1024;
    unsigned top_l_6_linear_bias_golden_wu_out_size_in_bytes = top_l_6_linear_bias_golden_wu_out_size * sizeof(float) ;
    status = hbmAlloc(top_l_6_linear_bias_golden_wu_out_size_in_bytes, &top_l_6_linear_bias_golden_wu_out_dram, "top_l_6_linear_bias_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_bias_golden_wu_out dram malloc failed!");
    synLaunchTensorInfo top_l_6_linear_bias_golden_wu_out_tr_info = {"top_l_6_linear_bias_golden_wu_out",
                                                                     top_l_6_linear_bias_golden_wu_out_dram};
    UNUSED(top_l_6_linear_bias_golden_wu_out_tr_info); // For single op tests
    synTensor top_l_6_linear_bias_golden_wu_out = createTensor(1U, syn_type_single, top_l_6_linear_bias_golden_wu_out_sizes, true, "top_l_6_linear_bias_golden_wu_out");
    UNUSED(top_l_6_linear_bias_golden_wu_out); // For single op tests

    // create top_l_6_linear_bias_wu_out tensor
    const unsigned top_l_6_linear_bias_wu_out_sizes[] = {1024,};
    uint64_t top_l_6_linear_bias_wu_out_dram;
    unsigned top_l_6_linear_bias_wu_out_size = 1024;
    unsigned top_l_6_linear_bias_wu_out_size_in_bytes = top_l_6_linear_bias_wu_out_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_6_linear_bias_wu_out_size_in_bytes, &top_l_6_linear_bias_wu_out_dram, "top_l_6_linear_bias_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_bias_wu_out dram malloc failed!");
    synLaunchTensorInfo top_l_6_linear_bias_wu_out_tr_info = {"top_l_6_linear_bias_wu_out",
                                                              top_l_6_linear_bias_wu_out_dram};
    UNUSED(top_l_6_linear_bias_wu_out_tr_info); // For single op tests
    synTensor top_l_6_linear_bias_wu_out = createTensor(1U, syn_type_bf16, top_l_6_linear_bias_wu_out_sizes, true, "top_l_6_linear_bias_wu_out");
    UNUSED(top_l_6_linear_bias_wu_out); // For single op tests

    synTensor top_l_6_linear_bias_update_node_out_vec[2] = {top_l_6_linear_bias_golden_wu_out, top_l_6_linear_bias_wu_out};


    status = synNodeCreate(wuGraphHandle, top_l_6_linear_bias_update_node_in_vec, top_l_6_linear_bias_update_node_out_vec, 3, 2, (void *)&top_l_6_linear_bias_update_node_kernel_params, sizeof(top_l_6_linear_bias_update_node_kernel_params), "optimizer_sgd_bwd_f32", "top_l_6_linear_bias_update_node", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_6_linear_bias_update_node failed!");

    /*************
     * top_l_8_linear_bias_update_node node
     * inputs: [top_l_8_linear_bias_grad_wu[1024](dtype=float32), top_l_8_linear_bias_golden[1024](dtype=float32), learning_rate[1](dtype=float32)]
     * output: [top_l_8_linear_bias_golden_wu_out(1024,)(dtype=float32), top_l_8_linear_bias_wu_out(1024,)(dtype=bf16)]
     *************/
    ns_OptimizerSGD::Params top_l_8_linear_bias_update_node_kernel_params;
    top_l_8_linear_bias_update_node_kernel_params.wd = 0;
    top_l_8_linear_bias_update_node_kernel_params.mom = 0;
    top_l_8_linear_bias_update_node_kernel_params.damp = 0;
    top_l_8_linear_bias_update_node_kernel_params.nesterov = false;

    // create top_l_8_linear_bias_grad_wu tensor
    const unsigned top_l_8_linear_bias_grad_wu_sizes[] = {1024,};
    uint64_t top_l_8_linear_bias_grad_wu_dram;
    unsigned top_l_8_linear_bias_grad_wu_size = 1024;
    unsigned top_l_8_linear_bias_grad_wu_size_in_bytes = top_l_8_linear_bias_grad_wu_size * sizeof(float) ;
    status = hbmAlloc(top_l_8_linear_bias_grad_wu_size_in_bytes, &top_l_8_linear_bias_grad_wu_dram, "top_l_8_linear_bias_grad_wu");
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_bias_grad_wu dram malloc failed!");
    synLaunchTensorInfo top_l_8_linear_bias_grad_wu_tr_info = {"top_l_8_linear_bias_grad_wu",
                                                               top_l_8_linear_bias_grad_wu_dram};
    UNUSED(top_l_8_linear_bias_grad_wu_tr_info); // For single op tests
    synTensor top_l_8_linear_bias_grad_wu = createTensor(1U, syn_type_single, top_l_8_linear_bias_grad_wu_sizes, true, "top_l_8_linear_bias_grad_wu");
    UNUSED(top_l_8_linear_bias_grad_wu); // For single op tests

    // create top_l_8_linear_bias_golden tensor
    const unsigned top_l_8_linear_bias_golden_sizes[] = {1024,};
    uint64_t top_l_8_linear_bias_golden_dram;
    unsigned top_l_8_linear_bias_golden_size = 1024;
    unsigned top_l_8_linear_bias_golden_size_in_bytes = top_l_8_linear_bias_golden_size * sizeof(float) ;
    status = hbmAlloc(top_l_8_linear_bias_golden_size_in_bytes, &top_l_8_linear_bias_golden_dram, "top_l_8_linear_bias_golden");
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_bias_golden dram malloc failed!");
    synLaunchTensorInfo top_l_8_linear_bias_golden_tr_info = {"top_l_8_linear_bias_golden",
                                                              top_l_8_linear_bias_golden_dram};
    UNUSED(top_l_8_linear_bias_golden_tr_info); // For single op tests
    synTensor top_l_8_linear_bias_golden = createTensor(1U, syn_type_single, top_l_8_linear_bias_golden_sizes, true, "top_l_8_linear_bias_golden");
    UNUSED(top_l_8_linear_bias_golden); // For single op tests

    synTensor top_l_8_linear_bias_update_node_in_vec[3] = {top_l_8_linear_bias_grad_wu, top_l_8_linear_bias_golden, learning_rate};


    // create top_l_8_linear_bias_golden_wu_out tensor
    const unsigned top_l_8_linear_bias_golden_wu_out_sizes[] = {1024,};
    uint64_t top_l_8_linear_bias_golden_wu_out_dram;
    unsigned top_l_8_linear_bias_golden_wu_out_size = 1024;
    unsigned top_l_8_linear_bias_golden_wu_out_size_in_bytes = top_l_8_linear_bias_golden_wu_out_size * sizeof(float) ;
    status = hbmAlloc(top_l_8_linear_bias_golden_wu_out_size_in_bytes, &top_l_8_linear_bias_golden_wu_out_dram, "top_l_8_linear_bias_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_bias_golden_wu_out dram malloc failed!");
    synLaunchTensorInfo top_l_8_linear_bias_golden_wu_out_tr_info = {"top_l_8_linear_bias_golden_wu_out",
                                                                     top_l_8_linear_bias_golden_wu_out_dram};
    UNUSED(top_l_8_linear_bias_golden_wu_out_tr_info); // For single op tests
    synTensor top_l_8_linear_bias_golden_wu_out = createTensor(1U, syn_type_single, top_l_8_linear_bias_golden_wu_out_sizes, true, "top_l_8_linear_bias_golden_wu_out");
    UNUSED(top_l_8_linear_bias_golden_wu_out); // For single op tests

    // create top_l_8_linear_bias_wu_out tensor
    const unsigned top_l_8_linear_bias_wu_out_sizes[] = {1024,};
    uint64_t top_l_8_linear_bias_wu_out_dram;
    unsigned top_l_8_linear_bias_wu_out_size = 1024;
    unsigned top_l_8_linear_bias_wu_out_size_in_bytes = top_l_8_linear_bias_wu_out_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_8_linear_bias_wu_out_size_in_bytes, &top_l_8_linear_bias_wu_out_dram, "top_l_8_linear_bias_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_bias_wu_out dram malloc failed!");
    synLaunchTensorInfo top_l_8_linear_bias_wu_out_tr_info = {"top_l_8_linear_bias_wu_out",
                                                              top_l_8_linear_bias_wu_out_dram};
    UNUSED(top_l_8_linear_bias_wu_out_tr_info); // For single op tests
    synTensor top_l_8_linear_bias_wu_out = createTensor(1U, syn_type_bf16, top_l_8_linear_bias_wu_out_sizes, true, "top_l_8_linear_bias_wu_out");
    UNUSED(top_l_8_linear_bias_wu_out); // For single op tests

    synTensor top_l_8_linear_bias_update_node_out_vec[2] = {top_l_8_linear_bias_golden_wu_out, top_l_8_linear_bias_wu_out};


    status = synNodeCreate(wuGraphHandle, top_l_8_linear_bias_update_node_in_vec, top_l_8_linear_bias_update_node_out_vec, 3, 2, (void *)&top_l_8_linear_bias_update_node_kernel_params, sizeof(top_l_8_linear_bias_update_node_kernel_params), "optimizer_sgd_bwd_f32", "top_l_8_linear_bias_update_node", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_8_linear_bias_update_node failed!");

    /*************
     * top_l_10_linear_bias_update_node node
     * inputs: [top_l_10_linear_bias_grad_wu[1](dtype=float32), top_l_10_linear_bias_golden[1](dtype=float32), learning_rate[1](dtype=float32)]
     * output: [top_l_10_linear_bias_golden_wu_out(1,)(dtype=float32), top_l_10_linear_bias_wu_out(1,)(dtype=bf16)]
     *************/
    ns_OptimizerSGD::Params top_l_10_linear_bias_update_node_kernel_params;
    top_l_10_linear_bias_update_node_kernel_params.wd = 0;
    top_l_10_linear_bias_update_node_kernel_params.mom = 0;
    top_l_10_linear_bias_update_node_kernel_params.damp = 0;
    top_l_10_linear_bias_update_node_kernel_params.nesterov = false;

    // create top_l_10_linear_bias_grad_wu tensor
    const unsigned top_l_10_linear_bias_grad_wu_sizes[] = {1,};
    uint64_t top_l_10_linear_bias_grad_wu_dram;
    unsigned top_l_10_linear_bias_grad_wu_size = 1;
    unsigned top_l_10_linear_bias_grad_wu_size_in_bytes = top_l_10_linear_bias_grad_wu_size * sizeof(float) ;
    status = hbmAlloc(top_l_10_linear_bias_grad_wu_size_in_bytes, &top_l_10_linear_bias_grad_wu_dram, "top_l_10_linear_bias_grad_wu");
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_bias_grad_wu dram malloc failed!");
    synLaunchTensorInfo top_l_10_linear_bias_grad_wu_tr_info = {"top_l_10_linear_bias_grad_wu",
                                                                top_l_10_linear_bias_grad_wu_dram};
    UNUSED(top_l_10_linear_bias_grad_wu_tr_info); // For single op tests
    synTensor top_l_10_linear_bias_grad_wu = createTensor(1U, syn_type_single, top_l_10_linear_bias_grad_wu_sizes, true, "top_l_10_linear_bias_grad_wu");
    UNUSED(top_l_10_linear_bias_grad_wu); // For single op tests

    // create top_l_10_linear_bias_golden tensor
    const unsigned top_l_10_linear_bias_golden_sizes[] = {1,};
    uint64_t top_l_10_linear_bias_golden_dram;
    unsigned top_l_10_linear_bias_golden_size = 1;
    unsigned top_l_10_linear_bias_golden_size_in_bytes = top_l_10_linear_bias_golden_size * sizeof(float) ;
    status = hbmAlloc(top_l_10_linear_bias_golden_size_in_bytes, &top_l_10_linear_bias_golden_dram, "top_l_10_linear_bias_golden");
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_bias_golden dram malloc failed!");
    synLaunchTensorInfo top_l_10_linear_bias_golden_tr_info = {"top_l_10_linear_bias_golden",
                                                               top_l_10_linear_bias_golden_dram};
    UNUSED(top_l_10_linear_bias_golden_tr_info); // For single op tests
    synTensor top_l_10_linear_bias_golden = createTensor(1U, syn_type_single, top_l_10_linear_bias_golden_sizes, true, "top_l_10_linear_bias_golden");
    UNUSED(top_l_10_linear_bias_golden); // For single op tests

    synTensor top_l_10_linear_bias_update_node_in_vec[3] = {top_l_10_linear_bias_grad_wu, top_l_10_linear_bias_golden, learning_rate};


    // create top_l_10_linear_bias_golden_wu_out tensor
    const unsigned top_l_10_linear_bias_golden_wu_out_sizes[] = {1,};
    uint64_t top_l_10_linear_bias_golden_wu_out_dram;
    unsigned top_l_10_linear_bias_golden_wu_out_size = 1;
    unsigned top_l_10_linear_bias_golden_wu_out_size_in_bytes = top_l_10_linear_bias_golden_wu_out_size * sizeof(float) ;
    status = hbmAlloc(top_l_10_linear_bias_golden_wu_out_size_in_bytes, &top_l_10_linear_bias_golden_wu_out_dram, "top_l_10_linear_bias_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_bias_golden_wu_out dram malloc failed!");
    synLaunchTensorInfo top_l_10_linear_bias_golden_wu_out_tr_info = {"top_l_10_linear_bias_golden_wu_out",
                                                                      top_l_10_linear_bias_golden_wu_out_dram};
    UNUSED(top_l_10_linear_bias_golden_wu_out_tr_info); // For single op tests
    synTensor top_l_10_linear_bias_golden_wu_out = createTensor(1U, syn_type_single, top_l_10_linear_bias_golden_wu_out_sizes, true, "top_l_10_linear_bias_golden_wu_out");
    UNUSED(top_l_10_linear_bias_golden_wu_out); // For single op tests

    // create top_l_10_linear_bias_wu_out tensor
    const unsigned top_l_10_linear_bias_wu_out_sizes[] = {1,};
    uint64_t top_l_10_linear_bias_wu_out_dram;
    unsigned top_l_10_linear_bias_wu_out_size = 1;
    unsigned top_l_10_linear_bias_wu_out_size_in_bytes = top_l_10_linear_bias_wu_out_size * sizeof(bfloat16) ;
    status = hbmAlloc(top_l_10_linear_bias_wu_out_size_in_bytes, &top_l_10_linear_bias_wu_out_dram, "top_l_10_linear_bias_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_bias_wu_out dram malloc failed!");
    synLaunchTensorInfo top_l_10_linear_bias_wu_out_tr_info = {"top_l_10_linear_bias_wu_out",
                                                               top_l_10_linear_bias_wu_out_dram};
    UNUSED(top_l_10_linear_bias_wu_out_tr_info); // For single op tests
    synTensor top_l_10_linear_bias_wu_out = createTensor(1U, syn_type_bf16, top_l_10_linear_bias_wu_out_sizes, true, "top_l_10_linear_bias_wu_out");
    UNUSED(top_l_10_linear_bias_wu_out); // For single op tests

    synTensor top_l_10_linear_bias_update_node_out_vec[2] = {top_l_10_linear_bias_golden_wu_out, top_l_10_linear_bias_wu_out};


    status = synNodeCreate(wuGraphHandle, top_l_10_linear_bias_update_node_in_vec, top_l_10_linear_bias_update_node_out_vec, 3, 2, (void *)&top_l_10_linear_bias_update_node_kernel_params, sizeof(top_l_10_linear_bias_update_node_kernel_params), "optimizer_sgd_bwd_f32", "top_l_10_linear_bias_update_node", nullptr, nullptr);
    ASSERT_TRUE(status == synSuccess && "synNodeCreate for top_l_10_linear_bias_update_node failed!");

    // init tensor bot_l_0_linear_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, bot_l_0_linear_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/bot_l_0_linear_weight", typed_data, bot_l_0_linear_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, bot_l_0_linear_weight_golden_dram, bot_l_0_linear_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor bot_l_2_linear_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, bot_l_2_linear_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/bot_l_2_linear_weight", typed_data, bot_l_2_linear_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, bot_l_2_linear_weight_golden_dram, bot_l_2_linear_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor bot_l_4_linear_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, bot_l_4_linear_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/bot_l_4_linear_weight", typed_data, bot_l_4_linear_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, bot_l_4_linear_weight_golden_dram, bot_l_4_linear_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor top_l_0_linear_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, top_l_0_linear_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_0_linear_weight", typed_data, top_l_0_linear_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, top_l_0_linear_weight_golden_dram, top_l_0_linear_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor top_l_2_linear_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, top_l_2_linear_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_2_linear_weight", typed_data, top_l_2_linear_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, top_l_2_linear_weight_golden_dram, top_l_2_linear_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor top_l_4_linear_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, top_l_4_linear_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_4_linear_weight", typed_data, top_l_4_linear_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, top_l_4_linear_weight_golden_dram, top_l_4_linear_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor top_l_6_linear_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, top_l_6_linear_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_6_linear_weight", typed_data, top_l_6_linear_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, top_l_6_linear_weight_golden_dram, top_l_6_linear_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor top_l_8_linear_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, top_l_8_linear_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_8_linear_weight", typed_data, top_l_8_linear_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, top_l_8_linear_weight_golden_dram, top_l_8_linear_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor top_l_10_linear_weight from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, top_l_10_linear_weight_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_10_linear_weight", typed_data, top_l_10_linear_weight_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, top_l_10_linear_weight_golden_dram, top_l_10_linear_weight_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor bot_l_0_linear_bias from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, bot_l_0_linear_bias_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/bot_l_0_linear_bias", typed_data, bot_l_0_linear_bias_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, bot_l_0_linear_bias_golden_dram, bot_l_0_linear_bias_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor bot_l_2_linear_bias from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, bot_l_2_linear_bias_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/bot_l_2_linear_bias", typed_data, bot_l_2_linear_bias_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, bot_l_2_linear_bias_golden_dram, bot_l_2_linear_bias_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor bot_l_4_linear_bias from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, bot_l_4_linear_bias_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/bot_l_4_linear_bias", typed_data, bot_l_4_linear_bias_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, bot_l_4_linear_bias_golden_dram, bot_l_4_linear_bias_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor top_l_0_linear_bias from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, top_l_0_linear_bias_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_0_linear_bias", typed_data, top_l_0_linear_bias_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, top_l_0_linear_bias_golden_dram, top_l_0_linear_bias_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor top_l_2_linear_bias from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, top_l_2_linear_bias_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_2_linear_bias", typed_data, top_l_2_linear_bias_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, top_l_2_linear_bias_golden_dram, top_l_2_linear_bias_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor top_l_4_linear_bias from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, top_l_4_linear_bias_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_4_linear_bias", typed_data, top_l_4_linear_bias_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, top_l_4_linear_bias_golden_dram, top_l_4_linear_bias_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor top_l_6_linear_bias from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, top_l_6_linear_bias_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_6_linear_bias", typed_data, top_l_6_linear_bias_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, top_l_6_linear_bias_golden_dram, top_l_6_linear_bias_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor top_l_8_linear_bias from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, top_l_8_linear_bias_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_8_linear_bias", typed_data, top_l_8_linear_bias_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, top_l_8_linear_bias_golden_dram, top_l_8_linear_bias_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    // init tensor top_l_10_linear_bias from file
    {
        void* data = nullptr;
        status = synHostMalloc(deviceId, top_l_10_linear_bias_golden_size_in_bytes, 0, &data);
        ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
        float* typed_data = static_cast<float*>(data);
        bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_10_linear_bias", typed_data, top_l_10_linear_bias_golden_size);
        ASSERT_TRUE(file_res);
        downloadTensorData(data, top_l_10_linear_bias_golden_dram, top_l_10_linear_bias_golden_size_in_bytes);
        status = synHostFree(deviceId, data, 0);
        ASSERT_TRUE(status == synSuccess && "synHostFree failed");
    }
    LaunchInfo wuLaunchInfo = compileAllocateAndLoadGraph(wuGraphHandle);
    setSingleValueInDram<float>(deviceId, 0.1, learning_rate_dram, m_streamHandleDownload);

    // Collect all inputs and outputs for weight update enqueue
    TensorInfoList wuInputs;
    TensorInfoList wuOutputs;

    wuInputs.push_back(bot_l_0_linear_weight_grad_wu_tr_info);
    wuInputs.push_back(bot_l_0_linear_weight_golden_tr_info);
    wuInputs.push_back(learning_rate_tr_info);
    wuInputs.push_back(bot_l_2_linear_weight_grad_wu_tr_info);
    wuInputs.push_back(bot_l_2_linear_weight_golden_tr_info);
    wuInputs.push_back(bot_l_4_linear_weight_grad_wu_tr_info);
    wuInputs.push_back(bot_l_4_linear_weight_golden_tr_info);
    wuInputs.push_back(top_l_0_linear_weight_grad_wu_tr_info);
    wuInputs.push_back(top_l_0_linear_weight_golden_tr_info);
    wuInputs.push_back(top_l_2_linear_weight_grad_wu_tr_info);
    wuInputs.push_back(top_l_2_linear_weight_golden_tr_info);
    wuInputs.push_back(top_l_4_linear_weight_grad_wu_tr_info);
    wuInputs.push_back(top_l_4_linear_weight_golden_tr_info);
    wuInputs.push_back(top_l_6_linear_weight_grad_wu_tr_info);
    wuInputs.push_back(top_l_6_linear_weight_golden_tr_info);
    wuInputs.push_back(top_l_8_linear_weight_grad_wu_tr_info);
    wuInputs.push_back(top_l_8_linear_weight_golden_tr_info);
    wuInputs.push_back(top_l_10_linear_weight_grad_wu_tr_info);
    wuInputs.push_back(top_l_10_linear_weight_golden_tr_info);
    wuInputs.push_back(bot_l_0_linear_bias_grad_wu_tr_info);
    wuInputs.push_back(bot_l_0_linear_bias_golden_tr_info);
    wuInputs.push_back(bot_l_2_linear_bias_grad_wu_tr_info);
    wuInputs.push_back(bot_l_2_linear_bias_golden_tr_info);
    wuInputs.push_back(bot_l_4_linear_bias_grad_wu_tr_info);
    wuInputs.push_back(bot_l_4_linear_bias_golden_tr_info);
    wuInputs.push_back(top_l_0_linear_bias_grad_wu_tr_info);
    wuInputs.push_back(top_l_0_linear_bias_golden_tr_info);
    wuInputs.push_back(top_l_2_linear_bias_grad_wu_tr_info);
    wuInputs.push_back(top_l_2_linear_bias_golden_tr_info);
    wuInputs.push_back(top_l_4_linear_bias_grad_wu_tr_info);
    wuInputs.push_back(top_l_4_linear_bias_golden_tr_info);
    wuInputs.push_back(top_l_6_linear_bias_grad_wu_tr_info);
    wuInputs.push_back(top_l_6_linear_bias_golden_tr_info);
    wuInputs.push_back(top_l_8_linear_bias_grad_wu_tr_info);
    wuInputs.push_back(top_l_8_linear_bias_golden_tr_info);
    wuInputs.push_back(top_l_10_linear_bias_grad_wu_tr_info);
    wuInputs.push_back(top_l_10_linear_bias_golden_tr_info);

    wuOutputs.push_back(bot_l_0_linear_weight_golden_wu_out_tr_info);
    wuOutputs.push_back(bot_l_0_linear_weight_wu_out_tr_info);
    wuOutputs.push_back(bot_l_2_linear_weight_golden_wu_out_tr_info);
    wuOutputs.push_back(bot_l_2_linear_weight_wu_out_tr_info);
    wuOutputs.push_back(bot_l_4_linear_weight_golden_wu_out_tr_info);
    wuOutputs.push_back(bot_l_4_linear_weight_wu_out_tr_info);
    wuOutputs.push_back(top_l_0_linear_weight_golden_wu_out_tr_info);
    wuOutputs.push_back(top_l_0_linear_weight_wu_out_tr_info);
    wuOutputs.push_back(top_l_2_linear_weight_golden_wu_out_tr_info);
    wuOutputs.push_back(top_l_2_linear_weight_wu_out_tr_info);
    wuOutputs.push_back(top_l_4_linear_weight_golden_wu_out_tr_info);
    wuOutputs.push_back(top_l_4_linear_weight_wu_out_tr_info);
    wuOutputs.push_back(top_l_6_linear_weight_golden_wu_out_tr_info);
    wuOutputs.push_back(top_l_6_linear_weight_wu_out_tr_info);
    wuOutputs.push_back(top_l_8_linear_weight_golden_wu_out_tr_info);
    wuOutputs.push_back(top_l_8_linear_weight_wu_out_tr_info);
    wuOutputs.push_back(top_l_10_linear_weight_golden_wu_out_tr_info);
    wuOutputs.push_back(top_l_10_linear_weight_wu_out_tr_info);
    wuOutputs.push_back(bot_l_0_linear_bias_golden_wu_out_tr_info);
    wuOutputs.push_back(bot_l_0_linear_bias_wu_out_tr_info);
    wuOutputs.push_back(bot_l_2_linear_bias_golden_wu_out_tr_info);
    wuOutputs.push_back(bot_l_2_linear_bias_wu_out_tr_info);
    wuOutputs.push_back(bot_l_4_linear_bias_golden_wu_out_tr_info);
    wuOutputs.push_back(bot_l_4_linear_bias_wu_out_tr_info);
    wuOutputs.push_back(top_l_0_linear_bias_golden_wu_out_tr_info);
    wuOutputs.push_back(top_l_0_linear_bias_wu_out_tr_info);
    wuOutputs.push_back(top_l_2_linear_bias_golden_wu_out_tr_info);
    wuOutputs.push_back(top_l_2_linear_bias_wu_out_tr_info);
    wuOutputs.push_back(top_l_4_linear_bias_golden_wu_out_tr_info);
    wuOutputs.push_back(top_l_4_linear_bias_wu_out_tr_info);
    wuOutputs.push_back(top_l_6_linear_bias_golden_wu_out_tr_info);
    wuOutputs.push_back(top_l_6_linear_bias_wu_out_tr_info);
    wuOutputs.push_back(top_l_8_linear_bias_golden_wu_out_tr_info);
    wuOutputs.push_back(top_l_8_linear_bias_wu_out_tr_info);
    wuOutputs.push_back(top_l_10_linear_bias_golden_wu_out_tr_info);
    wuOutputs.push_back(top_l_10_linear_bias_wu_out_tr_info);

    for(unsigned i = 0; i < 1; i++)
    {
        executeTraining(dlrmLaunchInfo, rnInputs, rnOutputs);
        executeTraining(wuLaunchInfo, wuInputs, wuOutputs);
        bfloat16 currentLoss = readSingleValueInDram <bfloat16> (deviceId, binary_cross_entropy_loss_output_dram, m_streamHandleUpload);
        checkResult((float)currentLoss, i);
        // Check data against files
        #if 0  // accuracy checks for binary cross entropy disabled due to BF16 resultion not allowing verificaiton succes.
        // data check for tensor binary_cross_entropy_loss_output from file
        {
            bfloat16* ref_arr = new bfloat16[binary_cross_entropy_loss_output_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, binary_cross_entropy_loss_output_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/binary_cross_entropy_loss_output", ref_arr, binary_cross_entropy_loss_output_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(binary_cross_entropy_loss_output_dram, data, binary_cross_entropy_loss_output_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: binary_cross_entropy_loss_output");
                validateResult(ref_arr, typed_data, binary_cross_entropy_loss_output_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: binary_cross_entropy_loss_output");
            }
            delete[] ref_arr;
        }
        // data check for tensor binary_cross_entropy_loss_saved_sigmoid from file
        {
            bfloat16* ref_arr = new bfloat16[binary_cross_entropy_loss_saved_sigmoid_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, binary_cross_entropy_loss_saved_sigmoid_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/binary_cross_entropy_loss_saved_sigmoid", ref_arr, binary_cross_entropy_loss_saved_sigmoid_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(binary_cross_entropy_loss_saved_sigmoid_dram, data, binary_cross_entropy_loss_saved_sigmoid_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: binary_cross_entropy_loss_saved_sigmoid");
                validateResult(ref_arr, typed_data, binary_cross_entropy_loss_saved_sigmoid_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: binary_cross_entropy_loss_saved_sigmoid");
            }
            delete[] ref_arr;
        }
        #endif
        // data check for tensor emb_0_embbag_weight_golden from file
        {
            float* ref_arr = new float[emb_0_embbag_weight_golden_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_0_embbag_weight_golden_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            float* typed_data = static_cast<float*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_0_embbag_dedw_weight_output", ref_arr, emb_0_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_0_embbag_weight_golden_dram, data, emb_0_embbag_weight_golden_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_0_embbag_weight_golden");
                validateResult(ref_arr, typed_data, emb_0_embbag_weight_golden_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_0_embbag_weight_golden");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_0_embbag_weight from file
        {
            bfloat16* ref_arr = new bfloat16[emb_0_embbag_weight_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_0_embbag_weight_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_0_embbag_dedw_weight_output", ref_arr, emb_0_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_0_embbag_weight_dram, data, emb_0_embbag_weight_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_0_embbag_weight");
                validateResult(ref_arr, typed_data, emb_0_embbag_weight_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_0_embbag_weight");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_1_embbag_weight_golden from file
        {
            float* ref_arr = new float[emb_1_embbag_weight_golden_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_1_embbag_weight_golden_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            float* typed_data = static_cast<float*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_1_embbag_dedw_weight_output", ref_arr, emb_1_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_1_embbag_weight_golden_dram, data, emb_1_embbag_weight_golden_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_1_embbag_weight_golden");
                validateResult(ref_arr, typed_data, emb_1_embbag_weight_golden_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_1_embbag_weight_golden");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_1_embbag_weight from file
        {
            bfloat16* ref_arr = new bfloat16[emb_1_embbag_weight_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_1_embbag_weight_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_1_embbag_dedw_weight_output", ref_arr, emb_1_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_1_embbag_weight_dram, data, emb_1_embbag_weight_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_1_embbag_weight");
                validateResult(ref_arr, typed_data, emb_1_embbag_weight_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_1_embbag_weight");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_2_embbag_weight_golden from file
        {
            float* ref_arr = new float[emb_2_embbag_weight_golden_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_2_embbag_weight_golden_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            float* typed_data = static_cast<float*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_2_embbag_dedw_weight_output", ref_arr, emb_2_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_2_embbag_weight_golden_dram, data, emb_2_embbag_weight_golden_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_2_embbag_weight_golden");
                validateResult(ref_arr, typed_data, emb_2_embbag_weight_golden_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_2_embbag_weight_golden");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_2_embbag_weight from file
        {
            bfloat16* ref_arr = new bfloat16[emb_2_embbag_weight_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_2_embbag_weight_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_2_embbag_dedw_weight_output", ref_arr, emb_2_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_2_embbag_weight_dram, data, emb_2_embbag_weight_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_2_embbag_weight");
                validateResult(ref_arr, typed_data, emb_2_embbag_weight_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_2_embbag_weight");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_3_embbag_weight_golden from file
        {
            float* ref_arr = new float[emb_3_embbag_weight_golden_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_3_embbag_weight_golden_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            float* typed_data = static_cast<float*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_3_embbag_dedw_weight_output", ref_arr, emb_3_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_3_embbag_weight_golden_dram, data, emb_3_embbag_weight_golden_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_3_embbag_weight_golden");
                validateResult(ref_arr, typed_data, emb_3_embbag_weight_golden_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_3_embbag_weight_golden");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_3_embbag_weight from file
        {
            bfloat16* ref_arr = new bfloat16[emb_3_embbag_weight_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_3_embbag_weight_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_3_embbag_dedw_weight_output", ref_arr, emb_3_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_3_embbag_weight_dram, data, emb_3_embbag_weight_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_3_embbag_weight");
                validateResult(ref_arr, typed_data, emb_3_embbag_weight_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_3_embbag_weight");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_4_embbag_weight_golden from file
        {
            float* ref_arr = new float[emb_4_embbag_weight_golden_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_4_embbag_weight_golden_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            float* typed_data = static_cast<float*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_4_embbag_dedw_weight_output", ref_arr, emb_4_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_4_embbag_weight_golden_dram, data, emb_4_embbag_weight_golden_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_4_embbag_weight_golden");
                validateResult(ref_arr, typed_data, emb_4_embbag_weight_golden_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_4_embbag_weight_golden");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_4_embbag_weight from file
        {
            bfloat16* ref_arr = new bfloat16[emb_4_embbag_weight_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_4_embbag_weight_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_4_embbag_dedw_weight_output", ref_arr, emb_4_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_4_embbag_weight_dram, data, emb_4_embbag_weight_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_4_embbag_weight");
                validateResult(ref_arr, typed_data, emb_4_embbag_weight_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_4_embbag_weight");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_5_embbag_weight_golden from file
        {
            float* ref_arr = new float[emb_5_embbag_weight_golden_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_5_embbag_weight_golden_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            float* typed_data = static_cast<float*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_5_embbag_dedw_weight_output", ref_arr, emb_5_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_5_embbag_weight_golden_dram, data, emb_5_embbag_weight_golden_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_5_embbag_weight_golden");
                validateResult(ref_arr, typed_data, emb_5_embbag_weight_golden_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_5_embbag_weight_golden");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_5_embbag_weight from file
        {
            bfloat16* ref_arr = new bfloat16[emb_5_embbag_weight_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_5_embbag_weight_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_5_embbag_dedw_weight_output", ref_arr, emb_5_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_5_embbag_weight_dram, data, emb_5_embbag_weight_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_5_embbag_weight");
                validateResult(ref_arr, typed_data, emb_5_embbag_weight_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_5_embbag_weight");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_6_embbag_weight_golden from file
        {
            float* ref_arr = new float[emb_6_embbag_weight_golden_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_6_embbag_weight_golden_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            float* typed_data = static_cast<float*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_6_embbag_dedw_weight_output", ref_arr, emb_6_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_6_embbag_weight_golden_dram, data, emb_6_embbag_weight_golden_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_6_embbag_weight_golden");
                validateResult(ref_arr, typed_data, emb_6_embbag_weight_golden_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_6_embbag_weight_golden");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_6_embbag_weight from file
        {
            bfloat16* ref_arr = new bfloat16[emb_6_embbag_weight_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_6_embbag_weight_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_6_embbag_dedw_weight_output", ref_arr, emb_6_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_6_embbag_weight_dram, data, emb_6_embbag_weight_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_6_embbag_weight");
                validateResult(ref_arr, typed_data, emb_6_embbag_weight_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_6_embbag_weight");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_7_embbag_weight_golden from file
        {
            float* ref_arr = new float[emb_7_embbag_weight_golden_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_7_embbag_weight_golden_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            float* typed_data = static_cast<float*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_7_embbag_dedw_weight_output", ref_arr, emb_7_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_7_embbag_weight_golden_dram, data, emb_7_embbag_weight_golden_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_7_embbag_weight_golden");
                validateResult(ref_arr, typed_data, emb_7_embbag_weight_golden_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_7_embbag_weight_golden");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_7_embbag_weight from file
        {
            bfloat16* ref_arr = new bfloat16[emb_7_embbag_weight_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_7_embbag_weight_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_7_embbag_dedw_weight_output", ref_arr, emb_7_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_7_embbag_weight_dram, data, emb_7_embbag_weight_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_7_embbag_weight");
                validateResult(ref_arr, typed_data, emb_7_embbag_weight_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_7_embbag_weight");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_8_embbag_weight_golden from file
        {
            float* ref_arr = new float[emb_8_embbag_weight_golden_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_8_embbag_weight_golden_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            float* typed_data = static_cast<float*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_8_embbag_dedw_weight_output", ref_arr, emb_8_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_8_embbag_weight_golden_dram, data, emb_8_embbag_weight_golden_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_8_embbag_weight_golden");
                validateResult(ref_arr, typed_data, emb_8_embbag_weight_golden_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_8_embbag_weight_golden");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_8_embbag_weight from file
        {
            bfloat16* ref_arr = new bfloat16[emb_8_embbag_weight_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_8_embbag_weight_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_8_embbag_dedw_weight_output", ref_arr, emb_8_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_8_embbag_weight_dram, data, emb_8_embbag_weight_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_8_embbag_weight");
                validateResult(ref_arr, typed_data, emb_8_embbag_weight_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_8_embbag_weight");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_9_embbag_weight_golden from file
        {
            float* ref_arr = new float[emb_9_embbag_weight_golden_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_9_embbag_weight_golden_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            float* typed_data = static_cast<float*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_9_embbag_dedw_weight_output", ref_arr, emb_9_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_9_embbag_weight_golden_dram, data, emb_9_embbag_weight_golden_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_9_embbag_weight_golden");
                validateResult(ref_arr, typed_data, emb_9_embbag_weight_golden_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_9_embbag_weight_golden");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_9_embbag_weight from file
        {
            bfloat16* ref_arr = new bfloat16[emb_9_embbag_weight_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_9_embbag_weight_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_9_embbag_dedw_weight_output", ref_arr, emb_9_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_9_embbag_weight_dram, data, emb_9_embbag_weight_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_9_embbag_weight");
                validateResult(ref_arr, typed_data, emb_9_embbag_weight_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_9_embbag_weight");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_10_embbag_weight_golden from file
        {
            float* ref_arr = new float[emb_10_embbag_weight_golden_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_10_embbag_weight_golden_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            float* typed_data = static_cast<float*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_10_embbag_dedw_weight_output", ref_arr, emb_10_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_10_embbag_weight_golden_dram, data, emb_10_embbag_weight_golden_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_10_embbag_weight_golden");
                validateResult(ref_arr, typed_data, emb_10_embbag_weight_golden_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_10_embbag_weight_golden");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_10_embbag_weight from file
        {
            bfloat16* ref_arr = new bfloat16[emb_10_embbag_weight_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_10_embbag_weight_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_10_embbag_dedw_weight_output", ref_arr, emb_10_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_10_embbag_weight_dram, data, emb_10_embbag_weight_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_10_embbag_weight");
                validateResult(ref_arr, typed_data, emb_10_embbag_weight_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_10_embbag_weight");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_11_embbag_weight_golden from file
        {
            float* ref_arr = new float[emb_11_embbag_weight_golden_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_11_embbag_weight_golden_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            float* typed_data = static_cast<float*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_11_embbag_dedw_weight_output", ref_arr, emb_11_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_11_embbag_weight_golden_dram, data, emb_11_embbag_weight_golden_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_11_embbag_weight_golden");
                validateResult(ref_arr, typed_data, emb_11_embbag_weight_golden_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_11_embbag_weight_golden");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_11_embbag_weight from file
        {
            bfloat16* ref_arr = new bfloat16[emb_11_embbag_weight_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_11_embbag_weight_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_11_embbag_dedw_weight_output", ref_arr, emb_11_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_11_embbag_weight_dram, data, emb_11_embbag_weight_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_11_embbag_weight");
                validateResult(ref_arr, typed_data, emb_11_embbag_weight_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_11_embbag_weight");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_12_embbag_weight_golden from file
        {
            float* ref_arr = new float[emb_12_embbag_weight_golden_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_12_embbag_weight_golden_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            float* typed_data = static_cast<float*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_12_embbag_dedw_weight_output", ref_arr, emb_12_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_12_embbag_weight_golden_dram, data, emb_12_embbag_weight_golden_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_12_embbag_weight_golden");
                validateResult(ref_arr, typed_data, emb_12_embbag_weight_golden_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_12_embbag_weight_golden");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_12_embbag_weight from file
        {
            bfloat16* ref_arr = new bfloat16[emb_12_embbag_weight_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_12_embbag_weight_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_12_embbag_dedw_weight_output", ref_arr, emb_12_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_12_embbag_weight_dram, data, emb_12_embbag_weight_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_12_embbag_weight");
                validateResult(ref_arr, typed_data, emb_12_embbag_weight_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_12_embbag_weight");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_13_embbag_weight_golden from file
        {
            float* ref_arr = new float[emb_13_embbag_weight_golden_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_13_embbag_weight_golden_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            float* typed_data = static_cast<float*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_13_embbag_dedw_weight_output", ref_arr, emb_13_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_13_embbag_weight_golden_dram, data, emb_13_embbag_weight_golden_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_13_embbag_weight_golden");
                validateResult(ref_arr, typed_data, emb_13_embbag_weight_golden_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_13_embbag_weight_golden");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_13_embbag_weight from file
        {
            bfloat16* ref_arr = new bfloat16[emb_13_embbag_weight_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_13_embbag_weight_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_13_embbag_dedw_weight_output", ref_arr, emb_13_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_13_embbag_weight_dram, data, emb_13_embbag_weight_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_13_embbag_weight");
                validateResult(ref_arr, typed_data, emb_13_embbag_weight_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_13_embbag_weight");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_14_embbag_weight_golden from file
        {
            float* ref_arr = new float[emb_14_embbag_weight_golden_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_14_embbag_weight_golden_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            float* typed_data = static_cast<float*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_14_embbag_dedw_weight_output", ref_arr, emb_14_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_14_embbag_weight_golden_dram, data, emb_14_embbag_weight_golden_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_14_embbag_weight_golden");
                validateResult(ref_arr, typed_data, emb_14_embbag_weight_golden_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_14_embbag_weight_golden");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_14_embbag_weight from file
        {
            bfloat16* ref_arr = new bfloat16[emb_14_embbag_weight_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_14_embbag_weight_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_14_embbag_dedw_weight_output", ref_arr, emb_14_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_14_embbag_weight_dram, data, emb_14_embbag_weight_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_14_embbag_weight");
                validateResult(ref_arr, typed_data, emb_14_embbag_weight_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_14_embbag_weight");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_15_embbag_weight_golden from file
        {
            float* ref_arr = new float[emb_15_embbag_weight_golden_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_15_embbag_weight_golden_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            float* typed_data = static_cast<float*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_15_embbag_dedw_weight_output", ref_arr, emb_15_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_15_embbag_weight_golden_dram, data, emb_15_embbag_weight_golden_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_15_embbag_weight_golden");
                validateResult(ref_arr, typed_data, emb_15_embbag_weight_golden_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_15_embbag_weight_golden");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_15_embbag_weight from file
        {
            bfloat16* ref_arr = new bfloat16[emb_15_embbag_weight_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_15_embbag_weight_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_15_embbag_dedw_weight_output", ref_arr, emb_15_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_15_embbag_weight_dram, data, emb_15_embbag_weight_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_15_embbag_weight");
                validateResult(ref_arr, typed_data, emb_15_embbag_weight_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_15_embbag_weight");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_16_embbag_weight_golden from file
        {
            float* ref_arr = new float[emb_16_embbag_weight_golden_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_16_embbag_weight_golden_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            float* typed_data = static_cast<float*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_16_embbag_dedw_weight_output", ref_arr, emb_16_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_16_embbag_weight_golden_dram, data, emb_16_embbag_weight_golden_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_16_embbag_weight_golden");
                validateResult(ref_arr, typed_data, emb_16_embbag_weight_golden_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_16_embbag_weight_golden");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_16_embbag_weight from file
        {
            bfloat16* ref_arr = new bfloat16[emb_16_embbag_weight_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_16_embbag_weight_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_16_embbag_dedw_weight_output", ref_arr, emb_16_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_16_embbag_weight_dram, data, emb_16_embbag_weight_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_16_embbag_weight");
                validateResult(ref_arr, typed_data, emb_16_embbag_weight_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_16_embbag_weight");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_17_embbag_weight_golden from file
        {
            float* ref_arr = new float[emb_17_embbag_weight_golden_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_17_embbag_weight_golden_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            float* typed_data = static_cast<float*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_17_embbag_dedw_weight_output", ref_arr, emb_17_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_17_embbag_weight_golden_dram, data, emb_17_embbag_weight_golden_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_17_embbag_weight_golden");
                validateResult(ref_arr, typed_data, emb_17_embbag_weight_golden_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_17_embbag_weight_golden");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_17_embbag_weight from file
        {
            bfloat16* ref_arr = new bfloat16[emb_17_embbag_weight_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_17_embbag_weight_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_17_embbag_dedw_weight_output", ref_arr, emb_17_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_17_embbag_weight_dram, data, emb_17_embbag_weight_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_17_embbag_weight");
                validateResult(ref_arr, typed_data, emb_17_embbag_weight_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_17_embbag_weight");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_18_embbag_weight_golden from file
        {
            float* ref_arr = new float[emb_18_embbag_weight_golden_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_18_embbag_weight_golden_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            float* typed_data = static_cast<float*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_18_embbag_dedw_weight_output", ref_arr, emb_18_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_18_embbag_weight_golden_dram, data, emb_18_embbag_weight_golden_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_18_embbag_weight_golden");
                validateResult(ref_arr, typed_data, emb_18_embbag_weight_golden_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_18_embbag_weight_golden");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_18_embbag_weight from file
        {
            bfloat16* ref_arr = new bfloat16[emb_18_embbag_weight_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_18_embbag_weight_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_18_embbag_dedw_weight_output", ref_arr, emb_18_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_18_embbag_weight_dram, data, emb_18_embbag_weight_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_18_embbag_weight");
                validateResult(ref_arr, typed_data, emb_18_embbag_weight_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_18_embbag_weight");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_19_embbag_weight_golden from file
        {
            float* ref_arr = new float[emb_19_embbag_weight_golden_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_19_embbag_weight_golden_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            float* typed_data = static_cast<float*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_19_embbag_dedw_weight_output", ref_arr, emb_19_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_19_embbag_weight_golden_dram, data, emb_19_embbag_weight_golden_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_19_embbag_weight_golden");
                validateResult(ref_arr, typed_data, emb_19_embbag_weight_golden_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_19_embbag_weight_golden");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_19_embbag_weight from file
        {
            bfloat16* ref_arr = new bfloat16[emb_19_embbag_weight_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_19_embbag_weight_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_19_embbag_dedw_weight_output", ref_arr, emb_19_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_19_embbag_weight_dram, data, emb_19_embbag_weight_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_19_embbag_weight");
                validateResult(ref_arr, typed_data, emb_19_embbag_weight_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_19_embbag_weight");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_20_embbag_weight_golden from file
        {
            float* ref_arr = new float[emb_20_embbag_weight_golden_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_20_embbag_weight_golden_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            float* typed_data = static_cast<float*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_20_embbag_dedw_weight_output", ref_arr, emb_20_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_20_embbag_weight_golden_dram, data, emb_20_embbag_weight_golden_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_20_embbag_weight_golden");
                validateResult(ref_arr, typed_data, emb_20_embbag_weight_golden_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_20_embbag_weight_golden");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_20_embbag_weight from file
        {
            bfloat16* ref_arr = new bfloat16[emb_20_embbag_weight_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_20_embbag_weight_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_20_embbag_dedw_weight_output", ref_arr, emb_20_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_20_embbag_weight_dram, data, emb_20_embbag_weight_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_20_embbag_weight");
                validateResult(ref_arr, typed_data, emb_20_embbag_weight_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_20_embbag_weight");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_21_embbag_weight_golden from file
        {
            float* ref_arr = new float[emb_21_embbag_weight_golden_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_21_embbag_weight_golden_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            float* typed_data = static_cast<float*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_21_embbag_dedw_weight_output", ref_arr, emb_21_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_21_embbag_weight_golden_dram, data, emb_21_embbag_weight_golden_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_21_embbag_weight_golden");
                validateResult(ref_arr, typed_data, emb_21_embbag_weight_golden_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_21_embbag_weight_golden");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_21_embbag_weight from file
        {
            bfloat16* ref_arr = new bfloat16[emb_21_embbag_weight_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_21_embbag_weight_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_21_embbag_dedw_weight_output", ref_arr, emb_21_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_21_embbag_weight_dram, data, emb_21_embbag_weight_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_21_embbag_weight");
                validateResult(ref_arr, typed_data, emb_21_embbag_weight_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_21_embbag_weight");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_22_embbag_weight_golden from file
        {
            float* ref_arr = new float[emb_22_embbag_weight_golden_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_22_embbag_weight_golden_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            float* typed_data = static_cast<float*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_22_embbag_dedw_weight_output", ref_arr, emb_22_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_22_embbag_weight_golden_dram, data, emb_22_embbag_weight_golden_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_22_embbag_weight_golden");
                validateResult(ref_arr, typed_data, emb_22_embbag_weight_golden_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_22_embbag_weight_golden");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_22_embbag_weight from file
        {
            bfloat16* ref_arr = new bfloat16[emb_22_embbag_weight_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_22_embbag_weight_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_22_embbag_dedw_weight_output", ref_arr, emb_22_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_22_embbag_weight_dram, data, emb_22_embbag_weight_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_22_embbag_weight");
                validateResult(ref_arr, typed_data, emb_22_embbag_weight_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_22_embbag_weight");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_23_embbag_weight_golden from file
        {
            float* ref_arr = new float[emb_23_embbag_weight_golden_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_23_embbag_weight_golden_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            float* typed_data = static_cast<float*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_23_embbag_dedw_weight_output", ref_arr, emb_23_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_23_embbag_weight_golden_dram, data, emb_23_embbag_weight_golden_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_23_embbag_weight_golden");
                validateResult(ref_arr, typed_data, emb_23_embbag_weight_golden_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_23_embbag_weight_golden");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_23_embbag_weight from file
        {
            bfloat16* ref_arr = new bfloat16[emb_23_embbag_weight_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_23_embbag_weight_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_23_embbag_dedw_weight_output", ref_arr, emb_23_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_23_embbag_weight_dram, data, emb_23_embbag_weight_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_23_embbag_weight");
                validateResult(ref_arr, typed_data, emb_23_embbag_weight_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_23_embbag_weight");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_24_embbag_weight_golden from file
        {
            float* ref_arr = new float[emb_24_embbag_weight_golden_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_24_embbag_weight_golden_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            float* typed_data = static_cast<float*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_24_embbag_dedw_weight_output", ref_arr, emb_24_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_24_embbag_weight_golden_dram, data, emb_24_embbag_weight_golden_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_24_embbag_weight_golden");
                validateResult(ref_arr, typed_data, emb_24_embbag_weight_golden_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_24_embbag_weight_golden");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_24_embbag_weight from file
        {
            bfloat16* ref_arr = new bfloat16[emb_24_embbag_weight_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_24_embbag_weight_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_24_embbag_dedw_weight_output", ref_arr, emb_24_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_24_embbag_weight_dram, data, emb_24_embbag_weight_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_24_embbag_weight");
                validateResult(ref_arr, typed_data, emb_24_embbag_weight_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_24_embbag_weight");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_25_embbag_weight_golden from file
        {
            float* ref_arr = new float[emb_25_embbag_weight_golden_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_25_embbag_weight_golden_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            float* typed_data = static_cast<float*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_25_embbag_dedw_weight_output", ref_arr, emb_25_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_25_embbag_weight_golden_dram, data, emb_25_embbag_weight_golden_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_25_embbag_weight_golden");
                validateResult(ref_arr, typed_data, emb_25_embbag_weight_golden_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_25_embbag_weight_golden");
            }
            delete[] ref_arr;
        }
        // data check for tensor emb_25_embbag_weight from file
        {
            bfloat16* ref_arr = new bfloat16[emb_25_embbag_weight_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, emb_25_embbag_weight_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/emb_25_embbag_dedw_weight_output", ref_arr, emb_25_embbag_weight_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(emb_25_embbag_weight_dram, data, emb_25_embbag_weight_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: emb_25_embbag_weight");
                validateResult(ref_arr, typed_data, emb_25_embbag_weight_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: emb_25_embbag_weight");
            }
            delete[] ref_arr;
        }
        // data check for tensor bot_l_0_linear_weight_wu_out from file
        {
            bfloat16* ref_arr = new bfloat16[bot_l_0_linear_weight_wu_out_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, bot_l_0_linear_weight_wu_out_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/bot_l_0_linear_weight_wu_out", ref_arr, bot_l_0_linear_weight_wu_out_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(bot_l_0_linear_weight_wu_out_dram, data, bot_l_0_linear_weight_wu_out_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: bot_l_0_linear_weight_wu_out");
                validateResult(ref_arr, typed_data, bot_l_0_linear_weight_wu_out_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: bot_l_0_linear_weight_wu_out");
            }
            delete[] ref_arr;
        }
        // data check for tensor bot_l_2_linear_weight_wu_out from file
        {
            bfloat16* ref_arr = new bfloat16[bot_l_2_linear_weight_wu_out_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, bot_l_2_linear_weight_wu_out_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/bot_l_2_linear_weight_wu_out", ref_arr, bot_l_2_linear_weight_wu_out_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(bot_l_2_linear_weight_wu_out_dram, data, bot_l_2_linear_weight_wu_out_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: bot_l_2_linear_weight_wu_out");
                validateResult(ref_arr, typed_data, bot_l_2_linear_weight_wu_out_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: bot_l_2_linear_weight_wu_out");
            }
            delete[] ref_arr;
        }
        // data check for tensor bot_l_4_linear_weight_wu_out from file
        {
            bfloat16* ref_arr = new bfloat16[bot_l_4_linear_weight_wu_out_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, bot_l_4_linear_weight_wu_out_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/bot_l_4_linear_weight_wu_out", ref_arr, bot_l_4_linear_weight_wu_out_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(bot_l_4_linear_weight_wu_out_dram, data, bot_l_4_linear_weight_wu_out_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: bot_l_4_linear_weight_wu_out");
                validateResult(ref_arr, typed_data, bot_l_4_linear_weight_wu_out_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: bot_l_4_linear_weight_wu_out");
            }
            delete[] ref_arr;
        }
        // data check for tensor top_l_0_linear_weight_wu_out from file
        {
            bfloat16* ref_arr = new bfloat16[top_l_0_linear_weight_wu_out_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, top_l_0_linear_weight_wu_out_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_0_linear_weight_wu_out", ref_arr, top_l_0_linear_weight_wu_out_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(top_l_0_linear_weight_wu_out_dram, data, top_l_0_linear_weight_wu_out_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: top_l_0_linear_weight_wu_out");
                validateResult(ref_arr, typed_data, top_l_0_linear_weight_wu_out_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: top_l_0_linear_weight_wu_out");
            }
            delete[] ref_arr;
        }
        // data check for tensor top_l_2_linear_weight_wu_out from file
        {
            bfloat16* ref_arr = new bfloat16[top_l_2_linear_weight_wu_out_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, top_l_2_linear_weight_wu_out_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_2_linear_weight_wu_out", ref_arr, top_l_2_linear_weight_wu_out_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(top_l_2_linear_weight_wu_out_dram, data, top_l_2_linear_weight_wu_out_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: top_l_2_linear_weight_wu_out");
                validateResult(ref_arr, typed_data, top_l_2_linear_weight_wu_out_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: top_l_2_linear_weight_wu_out");
            }
            delete[] ref_arr;
        }
        // data check for tensor top_l_4_linear_weight_wu_out from file
        {
            bfloat16* ref_arr = new bfloat16[top_l_4_linear_weight_wu_out_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, top_l_4_linear_weight_wu_out_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_4_linear_weight_wu_out", ref_arr, top_l_4_linear_weight_wu_out_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(top_l_4_linear_weight_wu_out_dram, data, top_l_4_linear_weight_wu_out_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: top_l_4_linear_weight_wu_out");
                validateResult(ref_arr, typed_data, top_l_4_linear_weight_wu_out_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: top_l_4_linear_weight_wu_out");
            }
            delete[] ref_arr;
        }
        // data check for tensor top_l_6_linear_weight_wu_out from file
        {
            bfloat16* ref_arr = new bfloat16[top_l_6_linear_weight_wu_out_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, top_l_6_linear_weight_wu_out_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_6_linear_weight_wu_out", ref_arr, top_l_6_linear_weight_wu_out_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(top_l_6_linear_weight_wu_out_dram, data, top_l_6_linear_weight_wu_out_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: top_l_6_linear_weight_wu_out");
                validateResult(ref_arr, typed_data, top_l_6_linear_weight_wu_out_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: top_l_6_linear_weight_wu_out");
            }
            delete[] ref_arr;
        }
        // data check for tensor top_l_8_linear_weight_wu_out from file
        {
            bfloat16* ref_arr = new bfloat16[top_l_8_linear_weight_wu_out_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, top_l_8_linear_weight_wu_out_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_8_linear_weight_wu_out", ref_arr, top_l_8_linear_weight_wu_out_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(top_l_8_linear_weight_wu_out_dram, data, top_l_8_linear_weight_wu_out_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: top_l_8_linear_weight_wu_out");
                validateResult(ref_arr, typed_data, top_l_8_linear_weight_wu_out_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: top_l_8_linear_weight_wu_out");
            }
            delete[] ref_arr;
        }
        // data check for tensor top_l_10_linear_weight_wu_out from file
        {
            bfloat16* ref_arr = new bfloat16[top_l_10_linear_weight_wu_out_size];
            void* data = nullptr;
            status = synHostMalloc(deviceId, top_l_10_linear_weight_wu_out_size_in_bytes, 0, &data);
            ASSERT_TRUE(status == synSuccess && "synHostMalloc failed");
            bfloat16* typed_data = static_cast<bfloat16*>(data);
            bool file_res = read_file("/software/data/gaudi/DLRM_synapse_test_data/top_l_10_linear_weight_wu_out", ref_arr, top_l_10_linear_weight_wu_out_size);
            (void)file_res;
            if (file_res)
            {
                uploadTensorData(top_l_10_linear_weight_wu_out_dram, data, top_l_10_linear_weight_wu_out_size_in_bytes);
                LOG_WARN(SYN_TEST, "validating: top_l_10_linear_weight_wu_out");
                validateResult(ref_arr, typed_data, top_l_10_linear_weight_wu_out_size);
            } else {
                LOG_WARN(SYN_TEST, "Result compare skipped due to missing file: top_l_10_linear_weight_wu_out");
            }
            delete[] ref_arr;
        }
    }

    status = synTensorDestroy(X_int);
    ASSERT_TRUE(status == synSuccess && "X_int tensor destruction failed!");
    status = hbmFree(X_int_dram, "X_int");
    ASSERT_TRUE(status == synSuccess && "X_int dram freeing failed!");
    status = synTensorDestroy(bot_l_0_linear_weight);
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_weight tensor destruction failed!");
    status = hbmFree(bot_l_0_linear_weight_dram, "bot_l_0_linear_weight");
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_weight dram freeing failed!");
    status = synTensorDestroy(bot_l_0_linear_bias);
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_bias tensor destruction failed!");
    status = hbmFree(bot_l_0_linear_bias_dram, "bot_l_0_linear_bias");
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_bias dram freeing failed!");
    status = synTensorDestroy(bot_l_0_linear_output);
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_output tensor destruction failed!");

    status = synTensorDestroy(bot_l_0_relu_output);
    ASSERT_TRUE(status == synSuccess && "bot_l_0_relu_output tensor destruction failed!");

    status = synTensorDestroy(bot_l_2_linear_weight);
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_weight tensor destruction failed!");
    status = hbmFree(bot_l_2_linear_weight_dram, "bot_l_2_linear_weight");
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_weight dram freeing failed!");
    status = synTensorDestroy(bot_l_2_linear_bias);
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_bias tensor destruction failed!");
    status = hbmFree(bot_l_2_linear_bias_dram, "bot_l_2_linear_bias");
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_bias dram freeing failed!");
    status = synTensorDestroy(bot_l_2_linear_output);
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_output tensor destruction failed!");

    status = synTensorDestroy(bot_l_2_relu_output);
    ASSERT_TRUE(status == synSuccess && "bot_l_2_relu_output tensor destruction failed!");

    status = synTensorDestroy(bot_l_4_linear_weight);
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_weight tensor destruction failed!");
    status = hbmFree(bot_l_4_linear_weight_dram, "bot_l_4_linear_weight");
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_weight dram freeing failed!");
    status = synTensorDestroy(bot_l_4_linear_bias);
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_bias tensor destruction failed!");
    status = hbmFree(bot_l_4_linear_bias_dram, "bot_l_4_linear_bias");
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_bias dram freeing failed!");
    status = synTensorDestroy(bot_l_4_linear_output);
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_output tensor destruction failed!");

    status = synTensorDestroy(bot_l_4_relu_output);
    ASSERT_TRUE(status == synSuccess && "bot_l_4_relu_output tensor destruction failed!");

    status = synTensorDestroy(emb_0_embbag_weight);
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_weight tensor destruction failed!");
    status = hbmFree(emb_0_embbag_weight_dram, "emb_0_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_weight dram freeing failed!");
    status = synTensorDestroy(lS_indices_0);
    ASSERT_TRUE(status == synSuccess && "lS_indices_0 tensor destruction failed!");
    status = hbmFree(lS_indices_0_dram, "lS_indices_0");
    ASSERT_TRUE(status == synSuccess && "lS_indices_0 dram freeing failed!");
    status = synTensorDestroy(lS_offset_0);
    ASSERT_TRUE(status == synSuccess && "lS_offset_0 tensor destruction failed!");
    status = hbmFree(lS_offset_0_dram, "lS_offset_0");
    ASSERT_TRUE(status == synSuccess && "lS_offset_0 dram freeing failed!");
    status = synTensorDestroy(emb_0_embbag_output);
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_output tensor destruction failed!");

    status = synTensorDestroy(emb_1_embbag_weight);
    ASSERT_TRUE(status == synSuccess && "emb_1_embbag_weight tensor destruction failed!");
    status = hbmFree(emb_1_embbag_weight_dram, "emb_1_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_1_embbag_weight dram freeing failed!");
    status = synTensorDestroy(lS_indices_1);
    ASSERT_TRUE(status == synSuccess && "lS_indices_1 tensor destruction failed!");
    status = hbmFree(lS_indices_1_dram, "lS_indices_1");
    ASSERT_TRUE(status == synSuccess && "lS_indices_1 dram freeing failed!");
    status = synTensorDestroy(lS_offset_1);
    ASSERT_TRUE(status == synSuccess && "lS_offset_1 tensor destruction failed!");
    status = hbmFree(lS_offset_1_dram, "lS_offset_1");
    ASSERT_TRUE(status == synSuccess && "lS_offset_1 dram freeing failed!");
    status = synTensorDestroy(emb_1_embbag_output);
    ASSERT_TRUE(status == synSuccess && "emb_1_embbag_output tensor destruction failed!");

    status = synTensorDestroy(emb_2_embbag_weight);
    ASSERT_TRUE(status == synSuccess && "emb_2_embbag_weight tensor destruction failed!");
    status = hbmFree(emb_2_embbag_weight_dram, "emb_2_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_2_embbag_weight dram freeing failed!");
    status = synTensorDestroy(lS_indices_2);
    ASSERT_TRUE(status == synSuccess && "lS_indices_2 tensor destruction failed!");
    status = hbmFree(lS_indices_2_dram, "lS_indices_2");
    ASSERT_TRUE(status == synSuccess && "lS_indices_2 dram freeing failed!");
    status = synTensorDestroy(lS_offset_2);
    ASSERT_TRUE(status == synSuccess && "lS_offset_2 tensor destruction failed!");
    status = hbmFree(lS_offset_2_dram, "lS_offset_2");
    ASSERT_TRUE(status == synSuccess && "lS_offset_2 dram freeing failed!");
    status = synTensorDestroy(emb_2_embbag_output);
    ASSERT_TRUE(status == synSuccess && "emb_2_embbag_output tensor destruction failed!");

    status = synTensorDestroy(emb_3_embbag_weight);
    ASSERT_TRUE(status == synSuccess && "emb_3_embbag_weight tensor destruction failed!");
    status = hbmFree(emb_3_embbag_weight_dram, "emb_3_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_3_embbag_weight dram freeing failed!");
    status = synTensorDestroy(lS_indices_3);
    ASSERT_TRUE(status == synSuccess && "lS_indices_3 tensor destruction failed!");
    status = hbmFree(lS_indices_3_dram, "lS_indices_3");
    ASSERT_TRUE(status == synSuccess && "lS_indices_3 dram freeing failed!");
    status = synTensorDestroy(lS_offset_3);
    ASSERT_TRUE(status == synSuccess && "lS_offset_3 tensor destruction failed!");
    status = hbmFree(lS_offset_3_dram, "lS_offset_3");
    ASSERT_TRUE(status == synSuccess && "lS_offset_3 dram freeing failed!");
    status = synTensorDestroy(emb_3_embbag_output);
    ASSERT_TRUE(status == synSuccess && "emb_3_embbag_output tensor destruction failed!");

    status = synTensorDestroy(emb_4_embbag_weight);
    ASSERT_TRUE(status == synSuccess && "emb_4_embbag_weight tensor destruction failed!");
    status = hbmFree(emb_4_embbag_weight_dram, "emb_4_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_4_embbag_weight dram freeing failed!");
    status = synTensorDestroy(lS_indices_4);
    ASSERT_TRUE(status == synSuccess && "lS_indices_4 tensor destruction failed!");
    status = hbmFree(lS_indices_4_dram, "lS_indices_4");
    ASSERT_TRUE(status == synSuccess && "lS_indices_4 dram freeing failed!");
    status = synTensorDestroy(lS_offset_4);
    ASSERT_TRUE(status == synSuccess && "lS_offset_4 tensor destruction failed!");
    status = hbmFree(lS_offset_4_dram, "lS_offset_4");
    ASSERT_TRUE(status == synSuccess && "lS_offset_4 dram freeing failed!");
    status = synTensorDestroy(emb_4_embbag_output);
    ASSERT_TRUE(status == synSuccess && "emb_4_embbag_output tensor destruction failed!");

    status = synTensorDestroy(emb_5_embbag_weight);
    ASSERT_TRUE(status == synSuccess && "emb_5_embbag_weight tensor destruction failed!");
    status = hbmFree(emb_5_embbag_weight_dram, "emb_5_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_5_embbag_weight dram freeing failed!");
    status = synTensorDestroy(lS_indices_5);
    ASSERT_TRUE(status == synSuccess && "lS_indices_5 tensor destruction failed!");
    status = hbmFree(lS_indices_5_dram, "lS_indices_5");
    ASSERT_TRUE(status == synSuccess && "lS_indices_5 dram freeing failed!");
    status = synTensorDestroy(lS_offset_5);
    ASSERT_TRUE(status == synSuccess && "lS_offset_5 tensor destruction failed!");
    status = hbmFree(lS_offset_5_dram, "lS_offset_5");
    ASSERT_TRUE(status == synSuccess && "lS_offset_5 dram freeing failed!");
    status = synTensorDestroy(emb_5_embbag_output);
    ASSERT_TRUE(status == synSuccess && "emb_5_embbag_output tensor destruction failed!");

    status = synTensorDestroy(emb_6_embbag_weight);
    ASSERT_TRUE(status == synSuccess && "emb_6_embbag_weight tensor destruction failed!");
    status = hbmFree(emb_6_embbag_weight_dram, "emb_6_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_6_embbag_weight dram freeing failed!");
    status = synTensorDestroy(lS_indices_6);
    ASSERT_TRUE(status == synSuccess && "lS_indices_6 tensor destruction failed!");
    status = hbmFree(lS_indices_6_dram, "lS_indices_6");
    ASSERT_TRUE(status == synSuccess && "lS_indices_6 dram freeing failed!");
    status = synTensorDestroy(lS_offset_6);
    ASSERT_TRUE(status == synSuccess && "lS_offset_6 tensor destruction failed!");
    status = hbmFree(lS_offset_6_dram, "lS_offset_6");
    ASSERT_TRUE(status == synSuccess && "lS_offset_6 dram freeing failed!");
    status = synTensorDestroy(emb_6_embbag_output);
    ASSERT_TRUE(status == synSuccess && "emb_6_embbag_output tensor destruction failed!");

    status = synTensorDestroy(emb_7_embbag_weight);
    ASSERT_TRUE(status == synSuccess && "emb_7_embbag_weight tensor destruction failed!");
    status = hbmFree(emb_7_embbag_weight_dram, "emb_7_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_7_embbag_weight dram freeing failed!");
    status = synTensorDestroy(lS_indices_7);
    ASSERT_TRUE(status == synSuccess && "lS_indices_7 tensor destruction failed!");
    status = hbmFree(lS_indices_7_dram, "lS_indices_7");
    ASSERT_TRUE(status == synSuccess && "lS_indices_7 dram freeing failed!");
    status = synTensorDestroy(lS_offset_7);
    ASSERT_TRUE(status == synSuccess && "lS_offset_7 tensor destruction failed!");
    status = hbmFree(lS_offset_7_dram, "lS_offset_7");
    ASSERT_TRUE(status == synSuccess && "lS_offset_7 dram freeing failed!");
    status = synTensorDestroy(emb_7_embbag_output);
    ASSERT_TRUE(status == synSuccess && "emb_7_embbag_output tensor destruction failed!");

    status = synTensorDestroy(emb_8_embbag_weight);
    ASSERT_TRUE(status == synSuccess && "emb_8_embbag_weight tensor destruction failed!");
    status = hbmFree(emb_8_embbag_weight_dram, "emb_8_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_8_embbag_weight dram freeing failed!");
    status = synTensorDestroy(lS_indices_8);
    ASSERT_TRUE(status == synSuccess && "lS_indices_8 tensor destruction failed!");
    status = hbmFree(lS_indices_8_dram, "lS_indices_8");
    ASSERT_TRUE(status == synSuccess && "lS_indices_8 dram freeing failed!");
    status = synTensorDestroy(lS_offset_8);
    ASSERT_TRUE(status == synSuccess && "lS_offset_8 tensor destruction failed!");
    status = hbmFree(lS_offset_8_dram, "lS_offset_8");
    ASSERT_TRUE(status == synSuccess && "lS_offset_8 dram freeing failed!");
    status = synTensorDestroy(emb_8_embbag_output);
    ASSERT_TRUE(status == synSuccess && "emb_8_embbag_output tensor destruction failed!");

    status = synTensorDestroy(emb_9_embbag_weight);
    ASSERT_TRUE(status == synSuccess && "emb_9_embbag_weight tensor destruction failed!");
    status = hbmFree(emb_9_embbag_weight_dram, "emb_9_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_9_embbag_weight dram freeing failed!");
    status = synTensorDestroy(lS_indices_9);
    ASSERT_TRUE(status == synSuccess && "lS_indices_9 tensor destruction failed!");
    status = hbmFree(lS_indices_9_dram, "lS_indices_9");
    ASSERT_TRUE(status == synSuccess && "lS_indices_9 dram freeing failed!");
    status = synTensorDestroy(lS_offset_9);
    ASSERT_TRUE(status == synSuccess && "lS_offset_9 tensor destruction failed!");
    status = hbmFree(lS_offset_9_dram, "lS_offset_9");
    ASSERT_TRUE(status == synSuccess && "lS_offset_9 dram freeing failed!");
    status = synTensorDestroy(emb_9_embbag_output);
    ASSERT_TRUE(status == synSuccess && "emb_9_embbag_output tensor destruction failed!");

    status = synTensorDestroy(emb_10_embbag_weight);
    ASSERT_TRUE(status == synSuccess && "emb_10_embbag_weight tensor destruction failed!");
    status = hbmFree(emb_10_embbag_weight_dram, "emb_10_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_10_embbag_weight dram freeing failed!");
    status = synTensorDestroy(lS_indices_10);
    ASSERT_TRUE(status == synSuccess && "lS_indices_10 tensor destruction failed!");
    status = hbmFree(lS_indices_10_dram, "lS_indices_10");
    ASSERT_TRUE(status == synSuccess && "lS_indices_10 dram freeing failed!");
    status = synTensorDestroy(lS_offset_10);
    ASSERT_TRUE(status == synSuccess && "lS_offset_10 tensor destruction failed!");
    status = hbmFree(lS_offset_10_dram, "lS_offset_10");
    ASSERT_TRUE(status == synSuccess && "lS_offset_10 dram freeing failed!");
    status = synTensorDestroy(emb_10_embbag_output);
    ASSERT_TRUE(status == synSuccess && "emb_10_embbag_output tensor destruction failed!");

    status = synTensorDestroy(emb_11_embbag_weight);
    ASSERT_TRUE(status == synSuccess && "emb_11_embbag_weight tensor destruction failed!");
    status = hbmFree(emb_11_embbag_weight_dram, "emb_11_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_11_embbag_weight dram freeing failed!");
    status = synTensorDestroy(lS_indices_11);
    ASSERT_TRUE(status == synSuccess && "lS_indices_11 tensor destruction failed!");
    status = hbmFree(lS_indices_11_dram, "lS_indices_11");
    ASSERT_TRUE(status == synSuccess && "lS_indices_11 dram freeing failed!");
    status = synTensorDestroy(lS_offset_11);
    ASSERT_TRUE(status == synSuccess && "lS_offset_11 tensor destruction failed!");
    status = hbmFree(lS_offset_11_dram, "lS_offset_11");
    ASSERT_TRUE(status == synSuccess && "lS_offset_11 dram freeing failed!");
    status = synTensorDestroy(emb_11_embbag_output);
    ASSERT_TRUE(status == synSuccess && "emb_11_embbag_output tensor destruction failed!");

    status = synTensorDestroy(emb_12_embbag_weight);
    ASSERT_TRUE(status == synSuccess && "emb_12_embbag_weight tensor destruction failed!");
    status = hbmFree(emb_12_embbag_weight_dram, "emb_12_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_12_embbag_weight dram freeing failed!");
    status = synTensorDestroy(lS_indices_12);
    ASSERT_TRUE(status == synSuccess && "lS_indices_12 tensor destruction failed!");
    status = hbmFree(lS_indices_12_dram, "lS_indices_12");
    ASSERT_TRUE(status == synSuccess && "lS_indices_12 dram freeing failed!");
    status = synTensorDestroy(lS_offset_12);
    ASSERT_TRUE(status == synSuccess && "lS_offset_12 tensor destruction failed!");
    status = hbmFree(lS_offset_12_dram, "lS_offset_12");
    ASSERT_TRUE(status == synSuccess && "lS_offset_12 dram freeing failed!");
    status = synTensorDestroy(emb_12_embbag_output);
    ASSERT_TRUE(status == synSuccess && "emb_12_embbag_output tensor destruction failed!");

    status = synTensorDestroy(emb_13_embbag_weight);
    ASSERT_TRUE(status == synSuccess && "emb_13_embbag_weight tensor destruction failed!");
    status = hbmFree(emb_13_embbag_weight_dram, "emb_13_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_13_embbag_weight dram freeing failed!");
    status = synTensorDestroy(lS_indices_13);
    ASSERT_TRUE(status == synSuccess && "lS_indices_13 tensor destruction failed!");
    status = hbmFree(lS_indices_13_dram, "lS_indices_13");
    ASSERT_TRUE(status == synSuccess && "lS_indices_13 dram freeing failed!");
    status = synTensorDestroy(lS_offset_13);
    ASSERT_TRUE(status == synSuccess && "lS_offset_13 tensor destruction failed!");
    status = hbmFree(lS_offset_13_dram, "lS_offset_13");
    ASSERT_TRUE(status == synSuccess && "lS_offset_13 dram freeing failed!");
    status = synTensorDestroy(emb_13_embbag_output);
    ASSERT_TRUE(status == synSuccess && "emb_13_embbag_output tensor destruction failed!");

    status = synTensorDestroy(emb_14_embbag_weight);
    ASSERT_TRUE(status == synSuccess && "emb_14_embbag_weight tensor destruction failed!");
    status = hbmFree(emb_14_embbag_weight_dram, "emb_14_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_14_embbag_weight dram freeing failed!");
    status = synTensorDestroy(lS_indices_14);
    ASSERT_TRUE(status == synSuccess && "lS_indices_14 tensor destruction failed!");
    status = hbmFree(lS_indices_14_dram, "lS_indices_14");
    ASSERT_TRUE(status == synSuccess && "lS_indices_14 dram freeing failed!");
    status = synTensorDestroy(lS_offset_14);
    ASSERT_TRUE(status == synSuccess && "lS_offset_14 tensor destruction failed!");
    status = hbmFree(lS_offset_14_dram, "lS_offset_14");
    ASSERT_TRUE(status == synSuccess && "lS_offset_14 dram freeing failed!");
    status = synTensorDestroy(emb_14_embbag_output);
    ASSERT_TRUE(status == synSuccess && "emb_14_embbag_output tensor destruction failed!");

    status = synTensorDestroy(emb_15_embbag_weight);
    ASSERT_TRUE(status == synSuccess && "emb_15_embbag_weight tensor destruction failed!");
    status = hbmFree(emb_15_embbag_weight_dram, "emb_15_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_15_embbag_weight dram freeing failed!");
    status = synTensorDestroy(lS_indices_15);
    ASSERT_TRUE(status == synSuccess && "lS_indices_15 tensor destruction failed!");
    status = hbmFree(lS_indices_15_dram, "lS_indices_15");
    ASSERT_TRUE(status == synSuccess && "lS_indices_15 dram freeing failed!");
    status = synTensorDestroy(lS_offset_15);
    ASSERT_TRUE(status == synSuccess && "lS_offset_15 tensor destruction failed!");
    status = hbmFree(lS_offset_15_dram, "lS_offset_15");
    ASSERT_TRUE(status == synSuccess && "lS_offset_15 dram freeing failed!");
    status = synTensorDestroy(emb_15_embbag_output);
    ASSERT_TRUE(status == synSuccess && "emb_15_embbag_output tensor destruction failed!");

    status = synTensorDestroy(emb_16_embbag_weight);
    ASSERT_TRUE(status == synSuccess && "emb_16_embbag_weight tensor destruction failed!");
    status = hbmFree(emb_16_embbag_weight_dram, "emb_16_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_16_embbag_weight dram freeing failed!");
    status = synTensorDestroy(lS_indices_16);
    ASSERT_TRUE(status == synSuccess && "lS_indices_16 tensor destruction failed!");
    status = hbmFree(lS_indices_16_dram, "lS_indices_16");
    ASSERT_TRUE(status == synSuccess && "lS_indices_16 dram freeing failed!");
    status = synTensorDestroy(lS_offset_16);
    ASSERT_TRUE(status == synSuccess && "lS_offset_16 tensor destruction failed!");
    status = hbmFree(lS_offset_16_dram, "lS_offset_16");
    ASSERT_TRUE(status == synSuccess && "lS_offset_16 dram freeing failed!");
    status = synTensorDestroy(emb_16_embbag_output);
    ASSERT_TRUE(status == synSuccess && "emb_16_embbag_output tensor destruction failed!");

    status = synTensorDestroy(emb_17_embbag_weight);
    ASSERT_TRUE(status == synSuccess && "emb_17_embbag_weight tensor destruction failed!");
    status = hbmFree(emb_17_embbag_weight_dram, "emb_17_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_17_embbag_weight dram freeing failed!");
    status = synTensorDestroy(lS_indices_17);
    ASSERT_TRUE(status == synSuccess && "lS_indices_17 tensor destruction failed!");
    status = hbmFree(lS_indices_17_dram, "lS_indices_17");
    ASSERT_TRUE(status == synSuccess && "lS_indices_17 dram freeing failed!");
    status = synTensorDestroy(lS_offset_17);
    ASSERT_TRUE(status == synSuccess && "lS_offset_17 tensor destruction failed!");
    status = hbmFree(lS_offset_17_dram, "lS_offset_17");
    ASSERT_TRUE(status == synSuccess && "lS_offset_17 dram freeing failed!");
    status = synTensorDestroy(emb_17_embbag_output);
    ASSERT_TRUE(status == synSuccess && "emb_17_embbag_output tensor destruction failed!");

    status = synTensorDestroy(emb_18_embbag_weight);
    ASSERT_TRUE(status == synSuccess && "emb_18_embbag_weight tensor destruction failed!");
    status = hbmFree(emb_18_embbag_weight_dram, "emb_18_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_18_embbag_weight dram freeing failed!");
    status = synTensorDestroy(lS_indices_18);
    ASSERT_TRUE(status == synSuccess && "lS_indices_18 tensor destruction failed!");
    status = hbmFree(lS_indices_18_dram, "lS_indices_18");
    ASSERT_TRUE(status == synSuccess && "lS_indices_18 dram freeing failed!");
    status = synTensorDestroy(lS_offset_18);
    ASSERT_TRUE(status == synSuccess && "lS_offset_18 tensor destruction failed!");
    status = hbmFree(lS_offset_18_dram, "lS_offset_18");
    ASSERT_TRUE(status == synSuccess && "lS_offset_18 dram freeing failed!");
    status = synTensorDestroy(emb_18_embbag_output);
    ASSERT_TRUE(status == synSuccess && "emb_18_embbag_output tensor destruction failed!");

    status = synTensorDestroy(emb_19_embbag_weight);
    ASSERT_TRUE(status == synSuccess && "emb_19_embbag_weight tensor destruction failed!");
    status = hbmFree(emb_19_embbag_weight_dram, "emb_19_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_19_embbag_weight dram freeing failed!");
    status = synTensorDestroy(lS_indices_19);
    ASSERT_TRUE(status == synSuccess && "lS_indices_19 tensor destruction failed!");
    status = hbmFree(lS_indices_19_dram, "lS_indices_19");
    ASSERT_TRUE(status == synSuccess && "lS_indices_19 dram freeing failed!");
    status = synTensorDestroy(lS_offset_19);
    ASSERT_TRUE(status == synSuccess && "lS_offset_19 tensor destruction failed!");
    status = hbmFree(lS_offset_19_dram, "lS_offset_19");
    ASSERT_TRUE(status == synSuccess && "lS_offset_19 dram freeing failed!");
    status = synTensorDestroy(emb_19_embbag_output);
    ASSERT_TRUE(status == synSuccess && "emb_19_embbag_output tensor destruction failed!");

    status = synTensorDestroy(emb_20_embbag_weight);
    ASSERT_TRUE(status == synSuccess && "emb_20_embbag_weight tensor destruction failed!");
    status = hbmFree(emb_20_embbag_weight_dram, "emb_20_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_20_embbag_weight dram freeing failed!");
    status = synTensorDestroy(lS_indices_20);
    ASSERT_TRUE(status == synSuccess && "lS_indices_20 tensor destruction failed!");
    status = hbmFree(lS_indices_20_dram, "lS_indices_20");
    ASSERT_TRUE(status == synSuccess && "lS_indices_20 dram freeing failed!");
    status = synTensorDestroy(lS_offset_20);
    ASSERT_TRUE(status == synSuccess && "lS_offset_20 tensor destruction failed!");
    status = hbmFree(lS_offset_20_dram, "lS_offset_20");
    ASSERT_TRUE(status == synSuccess && "lS_offset_20 dram freeing failed!");
    status = synTensorDestroy(emb_20_embbag_output);
    ASSERT_TRUE(status == synSuccess && "emb_20_embbag_output tensor destruction failed!");

    status = synTensorDestroy(emb_21_embbag_weight);
    ASSERT_TRUE(status == synSuccess && "emb_21_embbag_weight tensor destruction failed!");
    status = hbmFree(emb_21_embbag_weight_dram, "emb_21_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_21_embbag_weight dram freeing failed!");
    status = synTensorDestroy(lS_indices_21);
    ASSERT_TRUE(status == synSuccess && "lS_indices_21 tensor destruction failed!");
    status = hbmFree(lS_indices_21_dram, "lS_indices_21");
    ASSERT_TRUE(status == synSuccess && "lS_indices_21 dram freeing failed!");
    status = synTensorDestroy(lS_offset_21);
    ASSERT_TRUE(status == synSuccess && "lS_offset_21 tensor destruction failed!");
    status = hbmFree(lS_offset_21_dram, "lS_offset_21");
    ASSERT_TRUE(status == synSuccess && "lS_offset_21 dram freeing failed!");
    status = synTensorDestroy(emb_21_embbag_output);
    ASSERT_TRUE(status == synSuccess && "emb_21_embbag_output tensor destruction failed!");

    status = synTensorDestroy(emb_22_embbag_weight);
    ASSERT_TRUE(status == synSuccess && "emb_22_embbag_weight tensor destruction failed!");
    status = hbmFree(emb_22_embbag_weight_dram, "emb_22_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_22_embbag_weight dram freeing failed!");
    status = synTensorDestroy(lS_indices_22);
    ASSERT_TRUE(status == synSuccess && "lS_indices_22 tensor destruction failed!");
    status = hbmFree(lS_indices_22_dram, "lS_indices_22");
    ASSERT_TRUE(status == synSuccess && "lS_indices_22 dram freeing failed!");
    status = synTensorDestroy(lS_offset_22);
    ASSERT_TRUE(status == synSuccess && "lS_offset_22 tensor destruction failed!");
    status = hbmFree(lS_offset_22_dram, "lS_offset_22");
    ASSERT_TRUE(status == synSuccess && "lS_offset_22 dram freeing failed!");
    status = synTensorDestroy(emb_22_embbag_output);
    ASSERT_TRUE(status == synSuccess && "emb_22_embbag_output tensor destruction failed!");

    status = synTensorDestroy(emb_23_embbag_weight);
    ASSERT_TRUE(status == synSuccess && "emb_23_embbag_weight tensor destruction failed!");
    status = hbmFree(emb_23_embbag_weight_dram, "emb_23_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_23_embbag_weight dram freeing failed!");
    status = synTensorDestroy(lS_indices_23);
    ASSERT_TRUE(status == synSuccess && "lS_indices_23 tensor destruction failed!");
    status = hbmFree(lS_indices_23_dram, "lS_indices_23");
    ASSERT_TRUE(status == synSuccess && "lS_indices_23 dram freeing failed!");
    status = synTensorDestroy(lS_offset_23);
    ASSERT_TRUE(status == synSuccess && "lS_offset_23 tensor destruction failed!");
    status = hbmFree(lS_offset_23_dram, "lS_offset_23");
    ASSERT_TRUE(status == synSuccess && "lS_offset_23 dram freeing failed!");
    status = synTensorDestroy(emb_23_embbag_output);
    ASSERT_TRUE(status == synSuccess && "emb_23_embbag_output tensor destruction failed!");

    status = synTensorDestroy(emb_24_embbag_weight);
    ASSERT_TRUE(status == synSuccess && "emb_24_embbag_weight tensor destruction failed!");
    status = hbmFree(emb_24_embbag_weight_dram, "emb_24_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_24_embbag_weight dram freeing failed!");
    status = synTensorDestroy(lS_indices_24);
    ASSERT_TRUE(status == synSuccess && "lS_indices_24 tensor destruction failed!");
    status = hbmFree(lS_indices_24_dram, "lS_indices_24");
    ASSERT_TRUE(status == synSuccess && "lS_indices_24 dram freeing failed!");
    status = synTensorDestroy(lS_offset_24);
    ASSERT_TRUE(status == synSuccess && "lS_offset_24 tensor destruction failed!");
    status = hbmFree(lS_offset_24_dram, "lS_offset_24");
    ASSERT_TRUE(status == synSuccess && "lS_offset_24 dram freeing failed!");
    status = synTensorDestroy(emb_24_embbag_output);
    ASSERT_TRUE(status == synSuccess && "emb_24_embbag_output tensor destruction failed!");

    status = synTensorDestroy(emb_25_embbag_weight);
    ASSERT_TRUE(status == synSuccess && "emb_25_embbag_weight tensor destruction failed!");
    status = hbmFree(emb_25_embbag_weight_dram, "emb_25_embbag_weight");
    ASSERT_TRUE(status == synSuccess && "emb_25_embbag_weight dram freeing failed!");
    status = synTensorDestroy(lS_indices_25);
    ASSERT_TRUE(status == synSuccess && "lS_indices_25 tensor destruction failed!");
    status = hbmFree(lS_indices_25_dram, "lS_indices_25");
    ASSERT_TRUE(status == synSuccess && "lS_indices_25 dram freeing failed!");
    status = synTensorDestroy(lS_offset_25);
    ASSERT_TRUE(status == synSuccess && "lS_offset_25 tensor destruction failed!");
    status = hbmFree(lS_offset_25_dram, "lS_offset_25");
    ASSERT_TRUE(status == synSuccess && "lS_offset_25 dram freeing failed!");
    status = synTensorDestroy(emb_25_embbag_output);
    ASSERT_TRUE(status == synSuccess && "emb_25_embbag_output tensor destruction failed!");

    status = synTensorDestroy(concat_interact0_bot_l_4_relu_output_tensor_reshape);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_bot_l_4_relu_output_tensor_reshape tensor destruction failed!");

    status = synTensorDestroy(concat_interact0_output);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_output tensor destruction failed!");

    status = synTensorDestroy(reshape_bmm_output);
    ASSERT_TRUE(status == synSuccess && "reshape_bmm_output tensor destruction failed!");
    status = hbmFree(reshape_bmm_output_dram, "reshape_bmm_output");
    ASSERT_TRUE(status == synSuccess && "reshape_bmm_output dram freeing failed!");

    status = synTensorDestroy(bmm_interact_output);
    ASSERT_TRUE(status == synSuccess && "bmm_interact_output tensor destruction failed!");

    status = synTensorDestroy(reshape_tril_output);
    ASSERT_TRUE(status == synSuccess && "reshape_tril_output tensor destruction failed!");

    status = synTensorDestroy(tril_indices);
    ASSERT_TRUE(status == synSuccess && "tril_indices tensor destruction failed!");
    status = hbmFree(tril_indices_dram, "tril_indices");
    ASSERT_TRUE(status == synSuccess && "tril_indices dram freeing failed!");
    status = synTensorDestroy(tril_indices_output);
    ASSERT_TRUE(status == synSuccess && "tril_indices_output tensor destruction failed!");

    status = synTensorDestroy(concat_interact1_bot_l_4_relu_output_tensor_reshape);
    ASSERT_TRUE(status == synSuccess && "concat_interact1_bot_l_4_relu_output_tensor_reshape tensor destruction failed!");

    status = synTensorDestroy(concat_interact1_output);
    ASSERT_TRUE(status == synSuccess && "concat_interact1_output tensor destruction failed!");

    status = synTensorDestroy(top_l_0_linear_concat_interact1_output_tensor_reshape);
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_concat_interact1_output_tensor_reshape tensor destruction failed!");

    status = synTensorDestroy(top_l_0_linear_weight);
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_weight tensor destruction failed!");
    status = hbmFree(top_l_0_linear_weight_dram, "top_l_0_linear_weight");
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_weight dram freeing failed!");
    status = synTensorDestroy(top_l_0_linear_bias);
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_bias tensor destruction failed!");
    status = hbmFree(top_l_0_linear_bias_dram, "top_l_0_linear_bias");
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_bias dram freeing failed!");
    status = synTensorDestroy(top_l_0_linear_output);
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_output tensor destruction failed!");

    status = synTensorDestroy(top_l_0_relu_output);
    ASSERT_TRUE(status == synSuccess && "top_l_0_relu_output tensor destruction failed!");

    status = synTensorDestroy(top_l_2_linear_weight);
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_weight tensor destruction failed!");
    status = hbmFree(top_l_2_linear_weight_dram, "top_l_2_linear_weight");
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_weight dram freeing failed!");
    status = synTensorDestroy(top_l_2_linear_bias);
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_bias tensor destruction failed!");
    status = hbmFree(top_l_2_linear_bias_dram, "top_l_2_linear_bias");
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_bias dram freeing failed!");
    status = synTensorDestroy(top_l_2_linear_output);
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_output tensor destruction failed!");

    status = synTensorDestroy(top_l_2_relu_output);
    ASSERT_TRUE(status == synSuccess && "top_l_2_relu_output tensor destruction failed!");

    status = synTensorDestroy(top_l_4_linear_weight);
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_weight tensor destruction failed!");
    status = hbmFree(top_l_4_linear_weight_dram, "top_l_4_linear_weight");
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_weight dram freeing failed!");
    status = synTensorDestroy(top_l_4_linear_bias);
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_bias tensor destruction failed!");
    status = hbmFree(top_l_4_linear_bias_dram, "top_l_4_linear_bias");
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_bias dram freeing failed!");
    status = synTensorDestroy(top_l_4_linear_output);
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_output tensor destruction failed!");

    status = synTensorDestroy(top_l_4_relu_output);
    ASSERT_TRUE(status == synSuccess && "top_l_4_relu_output tensor destruction failed!");

    status = synTensorDestroy(top_l_6_linear_weight);
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_weight tensor destruction failed!");
    status = hbmFree(top_l_6_linear_weight_dram, "top_l_6_linear_weight");
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_weight dram freeing failed!");
    status = synTensorDestroy(top_l_6_linear_bias);
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_bias tensor destruction failed!");
    status = hbmFree(top_l_6_linear_bias_dram, "top_l_6_linear_bias");
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_bias dram freeing failed!");
    status = synTensorDestroy(top_l_6_linear_output);
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_output tensor destruction failed!");

    status = synTensorDestroy(top_l_6_relu_output);
    ASSERT_TRUE(status == synSuccess && "top_l_6_relu_output tensor destruction failed!");

    status = synTensorDestroy(top_l_8_linear_weight);
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_weight tensor destruction failed!");
    status = hbmFree(top_l_8_linear_weight_dram, "top_l_8_linear_weight");
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_weight dram freeing failed!");
    status = synTensorDestroy(top_l_8_linear_bias);
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_bias tensor destruction failed!");
    status = hbmFree(top_l_8_linear_bias_dram, "top_l_8_linear_bias");
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_bias dram freeing failed!");
    status = synTensorDestroy(top_l_8_linear_output);
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_output tensor destruction failed!");

    status = synTensorDestroy(top_l_8_relu_output);
    ASSERT_TRUE(status == synSuccess && "top_l_8_relu_output tensor destruction failed!");

    status = synTensorDestroy(top_l_10_linear_weight);
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_weight tensor destruction failed!");
    status = hbmFree(top_l_10_linear_weight_dram, "top_l_10_linear_weight");
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_weight dram freeing failed!");
    status = synTensorDestroy(top_l_10_linear_bias);
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_bias tensor destruction failed!");
    status = hbmFree(top_l_10_linear_bias_dram, "top_l_10_linear_bias");
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_bias dram freeing failed!");
    status = synTensorDestroy(top_l_10_linear_output);
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_output tensor destruction failed!");
    status = hbmFree(top_l_10_linear_output_dram, "top_l_10_linear_output");
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_output dram freeing failed!");

    status = synTensorDestroy(binary_cross_entropy_loss_fwd_top_l_10_linear_output_tensor_reshape);
    ASSERT_TRUE(status == synSuccess && "binary_cross_entropy_loss_fwd_top_l_10_linear_output_tensor_reshape tensor destruction failed!");

    status = synTensorDestroy(target);
    ASSERT_TRUE(status == synSuccess && "target tensor destruction failed!");
    status = hbmFree(target_dram, "target");
    ASSERT_TRUE(status == synSuccess && "target dram freeing failed!");
    status = synTensorDestroy(binary_cross_entropy_loss_output);
    ASSERT_TRUE(status == synSuccess && "binary_cross_entropy_loss_output tensor destruction failed!");
    status = hbmFree(binary_cross_entropy_loss_output_dram, "binary_cross_entropy_loss_output");
    ASSERT_TRUE(status == synSuccess && "binary_cross_entropy_loss_output dram freeing failed!");
    status = synTensorDestroy(binary_cross_entropy_loss_saved_sigmoid);
    ASSERT_TRUE(status == synSuccess && "binary_cross_entropy_loss_saved_sigmoid tensor destruction failed!");
    status = hbmFree(binary_cross_entropy_loss_saved_sigmoid_dram, "binary_cross_entropy_loss_saved_sigmoid");
    ASSERT_TRUE(status == synSuccess && "binary_cross_entropy_loss_saved_sigmoid dram freeing failed!");

    status = synTensorDestroy(binary_cross_entropy_loss_bwd_top_l_10_linear_output_tensor_reshape);
    ASSERT_TRUE(status == synSuccess && "binary_cross_entropy_loss_bwd_top_l_10_linear_output_tensor_reshape tensor destruction failed!");

    status = synTensorDestroy(binary_cross_entropy_loss_grad_input);
    ASSERT_TRUE(status == synSuccess && "binary_cross_entropy_loss_grad_input tensor destruction failed!");

    status = synTensorDestroy(top_l_10_linear_dedx_binary_cross_entropy_loss_grad_input_tensor_reshape);
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_dedx_binary_cross_entropy_loss_grad_input_tensor_reshape tensor destruction failed!");

    status = synTensorDestroy(top_l_10_linear_grad_input);
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_grad_input tensor destruction failed!");
    status = hbmFree(top_l_10_linear_grad_input_dram, "top_l_10_linear_grad_input");
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_grad_input dram freeing failed!");

    status = synTensorDestroy(top_l_10_linear_dedw_binary_cross_entropy_loss_grad_input_tensor_reshape);
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_dedw_binary_cross_entropy_loss_grad_input_tensor_reshape tensor destruction failed!");

    status = synTensorDestroy(top_l_10_linear_weight_grad);
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_weight_grad tensor destruction failed!");
    status = hbmFree(top_l_10_linear_weight_grad_dram, "top_l_10_linear_weight_grad");
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_weight_grad dram freeing failed!");

    status = synTensorDestroy(top_l_10_linear_dedb_binary_cross_entropy_loss_grad_input_tensor_reshape);
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_dedb_binary_cross_entropy_loss_grad_input_tensor_reshape tensor destruction failed!");

    status = synTensorDestroy(top_l_10_linear_bias_grad);
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_bias_grad tensor destruction failed!");
    status = hbmFree(top_l_10_linear_bias_grad_dram, "top_l_10_linear_bias_grad");
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_bias_grad dram freeing failed!");

    status = synTensorDestroy(top_l_8_relu_grad_input);
    ASSERT_TRUE(status == synSuccess && "top_l_8_relu_grad_input tensor destruction failed!");

    status = synTensorDestroy(top_l_8_linear_grad_input);
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_grad_input tensor destruction failed!");
    status = hbmFree(top_l_8_linear_grad_input_dram, "top_l_8_linear_grad_input");
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_grad_input dram freeing failed!");

    status = synTensorDestroy(top_l_8_linear_weight_grad);
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_weight_grad tensor destruction failed!");
    status = hbmFree(top_l_8_linear_weight_grad_dram, "top_l_8_linear_weight_grad");
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_weight_grad dram freeing failed!");

    status = synTensorDestroy(top_l_8_linear_dedb_top_l_8_relu_grad_input_tensor_reshape);
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_dedb_top_l_8_relu_grad_input_tensor_reshape tensor destruction failed!");

    status = synTensorDestroy(top_l_8_linear_bias_grad);
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_bias_grad tensor destruction failed!");
    status = hbmFree(top_l_8_linear_bias_grad_dram, "top_l_8_linear_bias_grad");
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_bias_grad dram freeing failed!");

    status = synTensorDestroy(top_l_6_relu_grad_input);
    ASSERT_TRUE(status == synSuccess && "top_l_6_relu_grad_input tensor destruction failed!");

    status = synTensorDestroy(top_l_6_linear_grad_input);
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_grad_input tensor destruction failed!");
    status = hbmFree(top_l_6_linear_grad_input_dram, "top_l_6_linear_grad_input");
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_grad_input dram freeing failed!");

    status = synTensorDestroy(top_l_6_linear_weight_grad);
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_weight_grad tensor destruction failed!");
    status = hbmFree(top_l_6_linear_weight_grad_dram, "top_l_6_linear_weight_grad");
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_weight_grad dram freeing failed!");

    status = synTensorDestroy(top_l_6_linear_dedb_top_l_6_relu_grad_input_tensor_reshape);
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_dedb_top_l_6_relu_grad_input_tensor_reshape tensor destruction failed!");

    status = synTensorDestroy(top_l_6_linear_bias_grad);
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_bias_grad tensor destruction failed!");
    status = hbmFree(top_l_6_linear_bias_grad_dram, "top_l_6_linear_bias_grad");
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_bias_grad dram freeing failed!");

    status = synTensorDestroy(top_l_4_relu_grad_input);
    ASSERT_TRUE(status == synSuccess && "top_l_4_relu_grad_input tensor destruction failed!");

    status = synTensorDestroy(top_l_4_linear_grad_input);
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_grad_input tensor destruction failed!");
    status = hbmFree(top_l_4_linear_grad_input_dram, "top_l_4_linear_grad_input");
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_grad_input dram freeing failed!");

    status = synTensorDestroy(top_l_4_linear_weight_grad);
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_weight_grad tensor destruction failed!");
    status = hbmFree(top_l_4_linear_weight_grad_dram, "top_l_4_linear_weight_grad");
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_weight_grad dram freeing failed!");

    status = synTensorDestroy(top_l_4_linear_dedb_top_l_4_relu_grad_input_tensor_reshape);
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_dedb_top_l_4_relu_grad_input_tensor_reshape tensor destruction failed!");

    status = synTensorDestroy(top_l_4_linear_bias_grad);
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_bias_grad tensor destruction failed!");
    status = hbmFree(top_l_4_linear_bias_grad_dram, "top_l_4_linear_bias_grad");
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_bias_grad dram freeing failed!");

    status = synTensorDestroy(top_l_2_relu_grad_input);
    ASSERT_TRUE(status == synSuccess && "top_l_2_relu_grad_input tensor destruction failed!");

    status = synTensorDestroy(top_l_2_linear_grad_input);
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_grad_input tensor destruction failed!");
    status = hbmFree(top_l_2_linear_grad_input_dram, "top_l_2_linear_grad_input");
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_grad_input dram freeing failed!");

    status = synTensorDestroy(top_l_2_linear_weight_grad);
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_weight_grad tensor destruction failed!");
    status = hbmFree(top_l_2_linear_weight_grad_dram, "top_l_2_linear_weight_grad");
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_weight_grad dram freeing failed!");

    status = synTensorDestroy(top_l_2_linear_dedb_top_l_2_relu_grad_input_tensor_reshape);
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_dedb_top_l_2_relu_grad_input_tensor_reshape tensor destruction failed!");

    status = synTensorDestroy(top_l_2_linear_bias_grad);
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_bias_grad tensor destruction failed!");
    status = hbmFree(top_l_2_linear_bias_grad_dram, "top_l_2_linear_bias_grad");
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_bias_grad dram freeing failed!");

    status = synTensorDestroy(top_l_0_relu_grad_input);
    ASSERT_TRUE(status == synSuccess && "top_l_0_relu_grad_input tensor destruction failed!");

    status = synTensorDestroy(top_l_0_linear_grad_input);
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_grad_input tensor destruction failed!");
    status = hbmFree(top_l_0_linear_grad_input_dram, "top_l_0_linear_grad_input");
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_grad_input dram freeing failed!");

    status = synTensorDestroy(top_l_0_linear_dedw_concat_interact1_output_tensor_reshape);
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_dedw_concat_interact1_output_tensor_reshape tensor destruction failed!");

    status = synTensorDestroy(top_l_0_linear_weight_grad);
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_weight_grad tensor destruction failed!");
    status = hbmFree(top_l_0_linear_weight_grad_dram, "top_l_0_linear_weight_grad");
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_weight_grad dram freeing failed!");

    status = synTensorDestroy(top_l_0_linear_dedb_top_l_0_relu_grad_input_tensor_reshape);
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_dedb_top_l_0_relu_grad_input_tensor_reshape tensor destruction failed!");

    status = synTensorDestroy(top_l_0_linear_bias_grad);
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_bias_grad tensor destruction failed!");
    status = hbmFree(top_l_0_linear_bias_grad_dram, "top_l_0_linear_bias_grad");
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_bias_grad dram freeing failed!");

    status = synTensorDestroy(concat_interact1_dedx_top_l_0_linear_grad_input_tensor_reshape);
    ASSERT_TRUE(status == synSuccess && "concat_interact1_dedx_top_l_0_linear_grad_input_tensor_reshape tensor destruction failed!");
    status = hbmFree(concat_interact1_dedx_top_l_0_linear_grad_input_tensor_reshape_dram, "concat_interact1_dedx_top_l_0_linear_grad_input_tensor_reshape");
    ASSERT_TRUE(status == synSuccess && "concat_interact1_dedx_top_l_0_linear_grad_input_tensor_reshape dram freeing failed!");

    status = synTensorDestroy(concat_interact1_grad_input0);
    ASSERT_TRUE(status == synSuccess && "concat_interact1_grad_input0 tensor destruction failed!");
    status = synTensorDestroy(concat_interact1_grad_input1);
    ASSERT_TRUE(status == synSuccess && "concat_interact1_grad_input1 tensor destruction failed!");

    status = synTensorDestroy(tril_grad_buffer);
    ASSERT_TRUE(status == synSuccess && "tril_grad_buffer tensor destruction failed!");
    status = hbmFree(tril_grad_buffer_dram, "tril_grad_buffer");
    ASSERT_TRUE(status == synSuccess && "tril_grad_buffer dram freeing failed!");
    status = synTensorDestroy(tril_indices_broadcast);
    ASSERT_TRUE(status == synSuccess && "tril_indices_broadcast tensor destruction failed!");
    status = hbmFree(tril_indices_broadcast_dram, "tril_indices_broadcast");
    ASSERT_TRUE(status == synSuccess && "tril_indices_broadcast dram freeing failed!");
    status = synTensorDestroy(tril_indices_grad_input);
    ASSERT_TRUE(status == synSuccess && "tril_indices_grad_input tensor destruction failed!");
    status = hbmFree(tril_indices_grad_input_dram, "tril_indices_grad_input");
    ASSERT_TRUE(status == synSuccess && "tril_indices_grad_input dram freeing failed!");

    status = synTensorDestroy(reshape_tril_grad_input);
    ASSERT_TRUE(status == synSuccess && "reshape_tril_grad_input tensor destruction failed!");
    status = hbmFree(reshape_tril_grad_input_dram, "reshape_tril_grad_input");
    ASSERT_TRUE(status == synSuccess && "reshape_tril_grad_input dram freeing failed!");

    status = synTensorDestroy(bmm_interact_grad_input0);
    ASSERT_TRUE(status == synSuccess && "bmm_interact_grad_input0 tensor destruction failed!");
    status = hbmFree(bmm_interact_grad_input0_dram, "bmm_interact_grad_input0");
    ASSERT_TRUE(status == synSuccess && "bmm_interact_grad_input0 dram freeing failed!");

    status = synTensorDestroy(bmm_interact_grad_input1);
    ASSERT_TRUE(status == synSuccess && "bmm_interact_grad_input1 tensor destruction failed!");

    status = synTensorDestroy(bmm_interact_grad_input1_transpose);
    ASSERT_TRUE(status == synSuccess && "bmm_interact_grad_input1_transpose tensor destruction failed!");

    status = synTensorDestroy(add_grads_bmm_output);
    ASSERT_TRUE(status == synSuccess && "add_grads_bmm_output tensor destruction failed!");
    status = hbmFree(add_grads_bmm_output_dram, "add_grads_bmm_output");
    ASSERT_TRUE(status == synSuccess && "add_grads_bmm_output dram freeing failed!");

    status = synTensorDestroy(reshape_bmm_grad_input);
    ASSERT_TRUE(status == synSuccess && "reshape_bmm_grad_input tensor destruction failed!");

    status = synTensorDestroy(concat_interact0_grad_input0);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_grad_input0 tensor destruction failed!");
    status = synTensorDestroy(concat_interact0_grad_input1);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_grad_input1 tensor destruction failed!");
    status = synTensorDestroy(concat_interact0_grad_input2);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_grad_input2 tensor destruction failed!");
    status = synTensorDestroy(concat_interact0_grad_input3);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_grad_input3 tensor destruction failed!");
    status = synTensorDestroy(concat_interact0_grad_input4);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_grad_input4 tensor destruction failed!");
    status = synTensorDestroy(concat_interact0_grad_input5);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_grad_input5 tensor destruction failed!");
    status = synTensorDestroy(concat_interact0_grad_input6);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_grad_input6 tensor destruction failed!");
    status = synTensorDestroy(concat_interact0_grad_input7);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_grad_input7 tensor destruction failed!");
    status = synTensorDestroy(concat_interact0_grad_input8);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_grad_input8 tensor destruction failed!");
    status = synTensorDestroy(concat_interact0_grad_input9);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_grad_input9 tensor destruction failed!");
    status = synTensorDestroy(concat_interact0_grad_input10);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_grad_input10 tensor destruction failed!");
    status = synTensorDestroy(concat_interact0_grad_input11);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_grad_input11 tensor destruction failed!");
    status = synTensorDestroy(concat_interact0_grad_input12);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_grad_input12 tensor destruction failed!");
    status = synTensorDestroy(concat_interact0_grad_input13);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_grad_input13 tensor destruction failed!");
    status = synTensorDestroy(concat_interact0_grad_input14);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_grad_input14 tensor destruction failed!");
    status = synTensorDestroy(concat_interact0_grad_input15);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_grad_input15 tensor destruction failed!");
    status = synTensorDestroy(concat_interact0_grad_input16);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_grad_input16 tensor destruction failed!");
    status = synTensorDestroy(concat_interact0_grad_input17);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_grad_input17 tensor destruction failed!");
    status = synTensorDestroy(concat_interact0_grad_input18);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_grad_input18 tensor destruction failed!");
    status = synTensorDestroy(concat_interact0_grad_input19);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_grad_input19 tensor destruction failed!");
    status = synTensorDestroy(concat_interact0_grad_input20);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_grad_input20 tensor destruction failed!");
    status = synTensorDestroy(concat_interact0_grad_input21);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_grad_input21 tensor destruction failed!");
    status = synTensorDestroy(concat_interact0_grad_input22);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_grad_input22 tensor destruction failed!");
    status = synTensorDestroy(concat_interact0_grad_input23);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_grad_input23 tensor destruction failed!");
    status = synTensorDestroy(concat_interact0_grad_input24);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_grad_input24 tensor destruction failed!");
    status = synTensorDestroy(concat_interact0_grad_input25);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_grad_input25 tensor destruction failed!");
    status = synTensorDestroy(concat_interact0_grad_input26);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_grad_input26 tensor destruction failed!");

    status = synTensorDestroy(concat_interact0_grad_input0_cast_BF16);
    ASSERT_TRUE(status == synSuccess && "concat_interact0_grad_input0_cast_BF16 tensor destruction failed!");

    status = synTensorDestroy(add_grads_concat_output);
    ASSERT_TRUE(status == synSuccess && "add_grads_concat_output tensor destruction failed!");
    status = hbmFree(add_grads_concat_output_dram, "add_grads_concat_output");
    ASSERT_TRUE(status == synSuccess && "add_grads_concat_output dram freeing failed!");

    status = synTensorDestroy(emb_0_embbag_dedw_grad_indices);
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_dedw_grad_indices tensor destruction failed!");
    status = hbmFree(emb_0_embbag_dedw_grad_indices_dram, "emb_0_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_dedw_grad_indices dram freeing failed!");
    status = synTensorDestroy(emb_0_embbag_dedw_lengths);
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_dedw_lengths tensor destruction failed!");
    status = hbmFree(emb_0_embbag_dedw_lengths_dram, "emb_0_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_dedw_lengths dram freeing failed!");
    status = synTensorDestroy(emb_0_embbag_valid_indices);
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_valid_indices tensor destruction failed!");
    status = hbmFree(emb_0_embbag_valid_indices_dram, "emb_0_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_valid_indices dram freeing failed!");
    status = synTensorDestroy(emb_0_embbag_dedw_grad_inter);
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_dedw_grad_inter tensor destruction failed!");

    status = synTensorDestroy(emb_0_embbag_weight_golden);
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_weight_golden tensor destruction failed!");
    status = hbmFree(emb_0_embbag_weight_golden_dram, "emb_0_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_weight_golden dram freeing failed!");
    status = synTensorDestroy(emb_0_embbag_momentum);
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_momentum tensor destruction failed!");
    status = hbmFree(emb_0_embbag_momentum_dram, "emb_0_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_momentum dram freeing failed!");
    status = synTensorDestroy(emb_0_embbag_dedw_param_table_indices);
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_dedw_param_table_indices tensor destruction failed!");
    status = hbmFree(emb_0_embbag_dedw_param_table_indices_dram, "emb_0_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_dedw_param_table_indices dram freeing failed!");
    status = synTensorDestroy(emb_0_offset_shape);
    ASSERT_TRUE(status == synSuccess && "emb_0_offset_shape tensor destruction failed!");
    status = hbmFree(emb_0_offset_shape_dram, "emb_0_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_0_offset_shape dram freeing failed!");
    status = synTensorDestroy(emb_0_embbag_timestamp);
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_timestamp tensor destruction failed!");
    status = hbmFree(emb_0_embbag_timestamp_dram, "emb_0_embbag_timestamp");
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_timestamp dram freeing failed!");
    status = synTensorDestroy(emb_0_embbag_rate);
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_rate tensor destruction failed!");
    status = hbmFree(emb_0_embbag_rate_dram, "emb_0_embbag_rate");
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_rate dram freeing failed!");
    status = synTensorDestroy(emb_0_embbag_dedw_weight_output_golden);
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_dedw_weight_output_golden tensor destruction failed!");
    status = synTensorDestroy(emb_0_embbag_dedw_momentum_output);
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_dedw_momentum_output tensor destruction failed!");
    status = hbmFree(emb_0_embbag_dedw_momentum_output_dram, "emb_0_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_dedw_momentum_output dram freeing failed!");
    status = synTensorDestroy(emb_0_embbag_dedw_weight_output);
    ASSERT_TRUE(status == synSuccess && "emb_0_embbag_dedw_weight_output tensor destruction failed!");

    status = synTensorDestroy(emb_1_embbag_dedw_grad_indices);
    ASSERT_TRUE(status == synSuccess && "emb_1_embbag_dedw_grad_indices tensor destruction failed!");
    status = hbmFree(emb_1_embbag_dedw_grad_indices_dram, "emb_1_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_1_embbag_dedw_grad_indices dram freeing failed!");
    status = synTensorDestroy(emb_1_embbag_dedw_lengths);
    ASSERT_TRUE(status == synSuccess && "emb_1_embbag_dedw_lengths tensor destruction failed!");
    status = hbmFree(emb_1_embbag_dedw_lengths_dram, "emb_1_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_1_embbag_dedw_lengths dram freeing failed!");
    status = synTensorDestroy(emb_1_embbag_valid_indices);
    ASSERT_TRUE(status == synSuccess && "emb_1_embbag_valid_indices tensor destruction failed!");
    status = hbmFree(emb_1_embbag_valid_indices_dram, "emb_1_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_1_embbag_valid_indices dram freeing failed!");
    status = synTensorDestroy(emb_1_embbag_dedw_grad_inter);
    ASSERT_TRUE(status == synSuccess && "emb_1_embbag_dedw_grad_inter tensor destruction failed!");

    status = synTensorDestroy(emb_1_embbag_weight_golden);
    ASSERT_TRUE(status == synSuccess && "emb_1_embbag_weight_golden tensor destruction failed!");
    status = hbmFree(emb_1_embbag_weight_golden_dram, "emb_1_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_1_embbag_weight_golden dram freeing failed!");
    status = synTensorDestroy(emb_1_embbag_momentum);
    ASSERT_TRUE(status == synSuccess && "emb_1_embbag_momentum tensor destruction failed!");
    status = hbmFree(emb_1_embbag_momentum_dram, "emb_1_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_1_embbag_momentum dram freeing failed!");
    status = synTensorDestroy(emb_1_embbag_dedw_param_table_indices);
    ASSERT_TRUE(status == synSuccess && "emb_1_embbag_dedw_param_table_indices tensor destruction failed!");
    status = hbmFree(emb_1_embbag_dedw_param_table_indices_dram, "emb_1_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_1_embbag_dedw_param_table_indices dram freeing failed!");
    status = synTensorDestroy(emb_1_offset_shape);
    ASSERT_TRUE(status == synSuccess && "emb_1_offset_shape tensor destruction failed!");
    status = hbmFree(emb_1_offset_shape_dram, "emb_1_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_1_offset_shape dram freeing failed!");
    status = synTensorDestroy(emb_1_embbag_dedw_weight_output_golden);
    ASSERT_TRUE(status == synSuccess && "emb_1_embbag_dedw_weight_output_golden tensor destruction failed!");
    status = synTensorDestroy(emb_1_embbag_dedw_momentum_output);
    ASSERT_TRUE(status == synSuccess && "emb_1_embbag_dedw_momentum_output tensor destruction failed!");
    status = hbmFree(emb_1_embbag_dedw_momentum_output_dram, "emb_1_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_1_embbag_dedw_momentum_output dram freeing failed!");
    status = synTensorDestroy(emb_1_embbag_dedw_weight_output);
    ASSERT_TRUE(status == synSuccess && "emb_1_embbag_dedw_weight_output tensor destruction failed!");

    status = synTensorDestroy(emb_2_embbag_dedw_grad_indices);
    ASSERT_TRUE(status == synSuccess && "emb_2_embbag_dedw_grad_indices tensor destruction failed!");
    status = hbmFree(emb_2_embbag_dedw_grad_indices_dram, "emb_2_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_2_embbag_dedw_grad_indices dram freeing failed!");
    status = synTensorDestroy(emb_2_embbag_dedw_lengths);
    ASSERT_TRUE(status == synSuccess && "emb_2_embbag_dedw_lengths tensor destruction failed!");
    status = hbmFree(emb_2_embbag_dedw_lengths_dram, "emb_2_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_2_embbag_dedw_lengths dram freeing failed!");
    status = synTensorDestroy(emb_2_embbag_valid_indices);
    ASSERT_TRUE(status == synSuccess && "emb_2_embbag_valid_indices tensor destruction failed!");
    status = hbmFree(emb_2_embbag_valid_indices_dram, "emb_2_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_2_embbag_valid_indices dram freeing failed!");
    status = synTensorDestroy(emb_2_embbag_dedw_grad_inter);
    ASSERT_TRUE(status == synSuccess && "emb_2_embbag_dedw_grad_inter tensor destruction failed!");

    status = synTensorDestroy(emb_2_embbag_weight_golden);
    ASSERT_TRUE(status == synSuccess && "emb_2_embbag_weight_golden tensor destruction failed!");
    status = hbmFree(emb_2_embbag_weight_golden_dram, "emb_2_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_2_embbag_weight_golden dram freeing failed!");
    status = synTensorDestroy(emb_2_embbag_momentum);
    ASSERT_TRUE(status == synSuccess && "emb_2_embbag_momentum tensor destruction failed!");
    status = hbmFree(emb_2_embbag_momentum_dram, "emb_2_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_2_embbag_momentum dram freeing failed!");
    status = synTensorDestroy(emb_2_embbag_dedw_param_table_indices);
    ASSERT_TRUE(status == synSuccess && "emb_2_embbag_dedw_param_table_indices tensor destruction failed!");
    status = hbmFree(emb_2_embbag_dedw_param_table_indices_dram, "emb_2_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_2_embbag_dedw_param_table_indices dram freeing failed!");
    status = synTensorDestroy(emb_2_offset_shape);
    ASSERT_TRUE(status == synSuccess && "emb_2_offset_shape tensor destruction failed!");
    status = hbmFree(emb_2_offset_shape_dram, "emb_2_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_2_offset_shape dram freeing failed!");
    status = synTensorDestroy(emb_2_embbag_dedw_weight_output_golden);
    ASSERT_TRUE(status == synSuccess && "emb_2_embbag_dedw_weight_output_golden tensor destruction failed!");
    status = synTensorDestroy(emb_2_embbag_dedw_momentum_output);
    ASSERT_TRUE(status == synSuccess && "emb_2_embbag_dedw_momentum_output tensor destruction failed!");
    status = hbmFree(emb_2_embbag_dedw_momentum_output_dram, "emb_2_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_2_embbag_dedw_momentum_output dram freeing failed!");
    status = synTensorDestroy(emb_2_embbag_dedw_weight_output);
    ASSERT_TRUE(status == synSuccess && "emb_2_embbag_dedw_weight_output tensor destruction failed!");

    status = synTensorDestroy(emb_3_embbag_dedw_grad_indices);
    ASSERT_TRUE(status == synSuccess && "emb_3_embbag_dedw_grad_indices tensor destruction failed!");
    status = hbmFree(emb_3_embbag_dedw_grad_indices_dram, "emb_3_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_3_embbag_dedw_grad_indices dram freeing failed!");
    status = synTensorDestroy(emb_3_embbag_dedw_lengths);
    ASSERT_TRUE(status == synSuccess && "emb_3_embbag_dedw_lengths tensor destruction failed!");
    status = hbmFree(emb_3_embbag_dedw_lengths_dram, "emb_3_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_3_embbag_dedw_lengths dram freeing failed!");
    status = synTensorDestroy(emb_3_embbag_valid_indices);
    ASSERT_TRUE(status == synSuccess && "emb_3_embbag_valid_indices tensor destruction failed!");
    status = hbmFree(emb_3_embbag_valid_indices_dram, "emb_3_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_3_embbag_valid_indices dram freeing failed!");
    status = synTensorDestroy(emb_3_embbag_dedw_grad_inter);
    ASSERT_TRUE(status == synSuccess && "emb_3_embbag_dedw_grad_inter tensor destruction failed!");

    status = synTensorDestroy(emb_3_embbag_weight_golden);
    ASSERT_TRUE(status == synSuccess && "emb_3_embbag_weight_golden tensor destruction failed!");
    status = hbmFree(emb_3_embbag_weight_golden_dram, "emb_3_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_3_embbag_weight_golden dram freeing failed!");
    status = synTensorDestroy(emb_3_embbag_momentum);
    ASSERT_TRUE(status == synSuccess && "emb_3_embbag_momentum tensor destruction failed!");
    status = hbmFree(emb_3_embbag_momentum_dram, "emb_3_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_3_embbag_momentum dram freeing failed!");
    status = synTensorDestroy(emb_3_embbag_dedw_param_table_indices);
    ASSERT_TRUE(status == synSuccess && "emb_3_embbag_dedw_param_table_indices tensor destruction failed!");
    status = hbmFree(emb_3_embbag_dedw_param_table_indices_dram, "emb_3_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_3_embbag_dedw_param_table_indices dram freeing failed!");
    status = synTensorDestroy(emb_3_offset_shape);
    ASSERT_TRUE(status == synSuccess && "emb_3_offset_shape tensor destruction failed!");
    status = hbmFree(emb_3_offset_shape_dram, "emb_3_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_3_offset_shape dram freeing failed!");
    status = synTensorDestroy(emb_3_embbag_dedw_weight_output_golden);
    ASSERT_TRUE(status == synSuccess && "emb_3_embbag_dedw_weight_output_golden tensor destruction failed!");
    status = synTensorDestroy(emb_3_embbag_dedw_momentum_output);
    ASSERT_TRUE(status == synSuccess && "emb_3_embbag_dedw_momentum_output tensor destruction failed!");
    status = hbmFree(emb_3_embbag_dedw_momentum_output_dram, "emb_3_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_3_embbag_dedw_momentum_output dram freeing failed!");
    status = synTensorDestroy(emb_3_embbag_dedw_weight_output);
    ASSERT_TRUE(status == synSuccess && "emb_3_embbag_dedw_weight_output tensor destruction failed!");

    status = synTensorDestroy(emb_4_embbag_dedw_grad_indices);
    ASSERT_TRUE(status == synSuccess && "emb_4_embbag_dedw_grad_indices tensor destruction failed!");
    status = hbmFree(emb_4_embbag_dedw_grad_indices_dram, "emb_4_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_4_embbag_dedw_grad_indices dram freeing failed!");
    status = synTensorDestroy(emb_4_embbag_dedw_lengths);
    ASSERT_TRUE(status == synSuccess && "emb_4_embbag_dedw_lengths tensor destruction failed!");
    status = hbmFree(emb_4_embbag_dedw_lengths_dram, "emb_4_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_4_embbag_dedw_lengths dram freeing failed!");
    status = synTensorDestroy(emb_4_embbag_valid_indices);
    ASSERT_TRUE(status == synSuccess && "emb_4_embbag_valid_indices tensor destruction failed!");
    status = hbmFree(emb_4_embbag_valid_indices_dram, "emb_4_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_4_embbag_valid_indices dram freeing failed!");
    status = synTensorDestroy(emb_4_embbag_dedw_grad_inter);
    ASSERT_TRUE(status == synSuccess && "emb_4_embbag_dedw_grad_inter tensor destruction failed!");

    status = synTensorDestroy(emb_4_embbag_weight_golden);
    ASSERT_TRUE(status == synSuccess && "emb_4_embbag_weight_golden tensor destruction failed!");
    status = hbmFree(emb_4_embbag_weight_golden_dram, "emb_4_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_4_embbag_weight_golden dram freeing failed!");
    status = synTensorDestroy(emb_4_embbag_momentum);
    ASSERT_TRUE(status == synSuccess && "emb_4_embbag_momentum tensor destruction failed!");
    status = hbmFree(emb_4_embbag_momentum_dram, "emb_4_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_4_embbag_momentum dram freeing failed!");
    status = synTensorDestroy(emb_4_embbag_dedw_param_table_indices);
    ASSERT_TRUE(status == synSuccess && "emb_4_embbag_dedw_param_table_indices tensor destruction failed!");
    status = hbmFree(emb_4_embbag_dedw_param_table_indices_dram, "emb_4_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_4_embbag_dedw_param_table_indices dram freeing failed!");
    status = synTensorDestroy(emb_4_offset_shape);
    ASSERT_TRUE(status == synSuccess && "emb_4_offset_shape tensor destruction failed!");
    status = hbmFree(emb_4_offset_shape_dram, "emb_4_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_4_offset_shape dram freeing failed!");
    status = synTensorDestroy(emb_4_embbag_dedw_weight_output_golden);
    ASSERT_TRUE(status == synSuccess && "emb_4_embbag_dedw_weight_output_golden tensor destruction failed!");
    status = synTensorDestroy(emb_4_embbag_dedw_momentum_output);
    ASSERT_TRUE(status == synSuccess && "emb_4_embbag_dedw_momentum_output tensor destruction failed!");
    status = hbmFree(emb_4_embbag_dedw_momentum_output_dram, "emb_4_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_4_embbag_dedw_momentum_output dram freeing failed!");
    status = synTensorDestroy(emb_4_embbag_dedw_weight_output);
    ASSERT_TRUE(status == synSuccess && "emb_4_embbag_dedw_weight_output tensor destruction failed!");

    status = synTensorDestroy(emb_5_embbag_dedw_grad_indices);
    ASSERT_TRUE(status == synSuccess && "emb_5_embbag_dedw_grad_indices tensor destruction failed!");
    status = hbmFree(emb_5_embbag_dedw_grad_indices_dram, "emb_5_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_5_embbag_dedw_grad_indices dram freeing failed!");
    status = synTensorDestroy(emb_5_embbag_dedw_lengths);
    ASSERT_TRUE(status == synSuccess && "emb_5_embbag_dedw_lengths tensor destruction failed!");
    status = hbmFree(emb_5_embbag_dedw_lengths_dram, "emb_5_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_5_embbag_dedw_lengths dram freeing failed!");
    status = synTensorDestroy(emb_5_embbag_valid_indices);
    ASSERT_TRUE(status == synSuccess && "emb_5_embbag_valid_indices tensor destruction failed!");
    status = hbmFree(emb_5_embbag_valid_indices_dram, "emb_5_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_5_embbag_valid_indices dram freeing failed!");
    status = synTensorDestroy(emb_5_embbag_dedw_grad_inter);
    ASSERT_TRUE(status == synSuccess && "emb_5_embbag_dedw_grad_inter tensor destruction failed!");

    status = synTensorDestroy(emb_5_embbag_weight_golden);
    ASSERT_TRUE(status == synSuccess && "emb_5_embbag_weight_golden tensor destruction failed!");
    status = hbmFree(emb_5_embbag_weight_golden_dram, "emb_5_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_5_embbag_weight_golden dram freeing failed!");
    status = synTensorDestroy(emb_5_embbag_momentum);
    ASSERT_TRUE(status == synSuccess && "emb_5_embbag_momentum tensor destruction failed!");
    status = hbmFree(emb_5_embbag_momentum_dram, "emb_5_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_5_embbag_momentum dram freeing failed!");
    status = synTensorDestroy(emb_5_embbag_dedw_param_table_indices);
    ASSERT_TRUE(status == synSuccess && "emb_5_embbag_dedw_param_table_indices tensor destruction failed!");
    status = hbmFree(emb_5_embbag_dedw_param_table_indices_dram, "emb_5_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_5_embbag_dedw_param_table_indices dram freeing failed!");
    status = synTensorDestroy(emb_5_offset_shape);
    ASSERT_TRUE(status == synSuccess && "emb_5_offset_shape tensor destruction failed!");
    status = hbmFree(emb_5_offset_shape_dram, "emb_5_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_5_offset_shape dram freeing failed!");
    status = synTensorDestroy(emb_5_embbag_dedw_weight_output_golden);
    ASSERT_TRUE(status == synSuccess && "emb_5_embbag_dedw_weight_output_golden tensor destruction failed!");
    status = synTensorDestroy(emb_5_embbag_dedw_momentum_output);
    ASSERT_TRUE(status == synSuccess && "emb_5_embbag_dedw_momentum_output tensor destruction failed!");
    status = hbmFree(emb_5_embbag_dedw_momentum_output_dram, "emb_5_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_5_embbag_dedw_momentum_output dram freeing failed!");
    status = synTensorDestroy(emb_5_embbag_dedw_weight_output);
    ASSERT_TRUE(status == synSuccess && "emb_5_embbag_dedw_weight_output tensor destruction failed!");

    status = synTensorDestroy(emb_6_embbag_dedw_grad_indices);
    ASSERT_TRUE(status == synSuccess && "emb_6_embbag_dedw_grad_indices tensor destruction failed!");
    status = hbmFree(emb_6_embbag_dedw_grad_indices_dram, "emb_6_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_6_embbag_dedw_grad_indices dram freeing failed!");
    status = synTensorDestroy(emb_6_embbag_dedw_lengths);
    ASSERT_TRUE(status == synSuccess && "emb_6_embbag_dedw_lengths tensor destruction failed!");
    status = hbmFree(emb_6_embbag_dedw_lengths_dram, "emb_6_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_6_embbag_dedw_lengths dram freeing failed!");
    status = synTensorDestroy(emb_6_embbag_valid_indices);
    ASSERT_TRUE(status == synSuccess && "emb_6_embbag_valid_indices tensor destruction failed!");
    status = hbmFree(emb_6_embbag_valid_indices_dram, "emb_6_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_6_embbag_valid_indices dram freeing failed!");
    status = synTensorDestroy(emb_6_embbag_dedw_grad_inter);
    ASSERT_TRUE(status == synSuccess && "emb_6_embbag_dedw_grad_inter tensor destruction failed!");

    status = synTensorDestroy(emb_6_embbag_weight_golden);
    ASSERT_TRUE(status == synSuccess && "emb_6_embbag_weight_golden tensor destruction failed!");
    status = hbmFree(emb_6_embbag_weight_golden_dram, "emb_6_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_6_embbag_weight_golden dram freeing failed!");
    status = synTensorDestroy(emb_6_embbag_momentum);
    ASSERT_TRUE(status == synSuccess && "emb_6_embbag_momentum tensor destruction failed!");
    status = hbmFree(emb_6_embbag_momentum_dram, "emb_6_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_6_embbag_momentum dram freeing failed!");
    status = synTensorDestroy(emb_6_embbag_dedw_param_table_indices);
    ASSERT_TRUE(status == synSuccess && "emb_6_embbag_dedw_param_table_indices tensor destruction failed!");
    status = hbmFree(emb_6_embbag_dedw_param_table_indices_dram, "emb_6_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_6_embbag_dedw_param_table_indices dram freeing failed!");
    status = synTensorDestroy(emb_6_offset_shape);
    ASSERT_TRUE(status == synSuccess && "emb_6_offset_shape tensor destruction failed!");
    status = hbmFree(emb_6_offset_shape_dram, "emb_6_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_6_offset_shape dram freeing failed!");
    status = synTensorDestroy(emb_6_embbag_dedw_weight_output_golden);
    ASSERT_TRUE(status == synSuccess && "emb_6_embbag_dedw_weight_output_golden tensor destruction failed!");
    status = synTensorDestroy(emb_6_embbag_dedw_momentum_output);
    ASSERT_TRUE(status == synSuccess && "emb_6_embbag_dedw_momentum_output tensor destruction failed!");
    status = hbmFree(emb_6_embbag_dedw_momentum_output_dram, "emb_6_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_6_embbag_dedw_momentum_output dram freeing failed!");
    status = synTensorDestroy(emb_6_embbag_dedw_weight_output);
    ASSERT_TRUE(status == synSuccess && "emb_6_embbag_dedw_weight_output tensor destruction failed!");

    status = synTensorDestroy(emb_7_embbag_dedw_grad_indices);
    ASSERT_TRUE(status == synSuccess && "emb_7_embbag_dedw_grad_indices tensor destruction failed!");
    status = hbmFree(emb_7_embbag_dedw_grad_indices_dram, "emb_7_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_7_embbag_dedw_grad_indices dram freeing failed!");
    status = synTensorDestroy(emb_7_embbag_dedw_lengths);
    ASSERT_TRUE(status == synSuccess && "emb_7_embbag_dedw_lengths tensor destruction failed!");
    status = hbmFree(emb_7_embbag_dedw_lengths_dram, "emb_7_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_7_embbag_dedw_lengths dram freeing failed!");
    status = synTensorDestroy(emb_7_embbag_valid_indices);
    ASSERT_TRUE(status == synSuccess && "emb_7_embbag_valid_indices tensor destruction failed!");
    status = hbmFree(emb_7_embbag_valid_indices_dram, "emb_7_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_7_embbag_valid_indices dram freeing failed!");
    status = synTensorDestroy(emb_7_embbag_dedw_grad_inter);
    ASSERT_TRUE(status == synSuccess && "emb_7_embbag_dedw_grad_inter tensor destruction failed!");

    status = synTensorDestroy(emb_7_embbag_weight_golden);
    ASSERT_TRUE(status == synSuccess && "emb_7_embbag_weight_golden tensor destruction failed!");
    status = hbmFree(emb_7_embbag_weight_golden_dram, "emb_7_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_7_embbag_weight_golden dram freeing failed!");
    status = synTensorDestroy(emb_7_embbag_momentum);
    ASSERT_TRUE(status == synSuccess && "emb_7_embbag_momentum tensor destruction failed!");
    status = hbmFree(emb_7_embbag_momentum_dram, "emb_7_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_7_embbag_momentum dram freeing failed!");
    status = synTensorDestroy(emb_7_embbag_dedw_param_table_indices);
    ASSERT_TRUE(status == synSuccess && "emb_7_embbag_dedw_param_table_indices tensor destruction failed!");
    status = hbmFree(emb_7_embbag_dedw_param_table_indices_dram, "emb_7_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_7_embbag_dedw_param_table_indices dram freeing failed!");
    status = synTensorDestroy(emb_7_offset_shape);
    ASSERT_TRUE(status == synSuccess && "emb_7_offset_shape tensor destruction failed!");
    status = hbmFree(emb_7_offset_shape_dram, "emb_7_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_7_offset_shape dram freeing failed!");
    status = synTensorDestroy(emb_7_embbag_dedw_weight_output_golden);
    ASSERT_TRUE(status == synSuccess && "emb_7_embbag_dedw_weight_output_golden tensor destruction failed!");
    status = synTensorDestroy(emb_7_embbag_dedw_momentum_output);
    ASSERT_TRUE(status == synSuccess && "emb_7_embbag_dedw_momentum_output tensor destruction failed!");
    status = hbmFree(emb_7_embbag_dedw_momentum_output_dram, "emb_7_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_7_embbag_dedw_momentum_output dram freeing failed!");
    status = synTensorDestroy(emb_7_embbag_dedw_weight_output);
    ASSERT_TRUE(status == synSuccess && "emb_7_embbag_dedw_weight_output tensor destruction failed!");

    status = synTensorDestroy(emb_8_embbag_dedw_grad_indices);
    ASSERT_TRUE(status == synSuccess && "emb_8_embbag_dedw_grad_indices tensor destruction failed!");
    status = hbmFree(emb_8_embbag_dedw_grad_indices_dram, "emb_8_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_8_embbag_dedw_grad_indices dram freeing failed!");
    status = synTensorDestroy(emb_8_embbag_dedw_lengths);
    ASSERT_TRUE(status == synSuccess && "emb_8_embbag_dedw_lengths tensor destruction failed!");
    status = hbmFree(emb_8_embbag_dedw_lengths_dram, "emb_8_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_8_embbag_dedw_lengths dram freeing failed!");
    status = synTensorDestroy(emb_8_embbag_valid_indices);
    ASSERT_TRUE(status == synSuccess && "emb_8_embbag_valid_indices tensor destruction failed!");
    status = hbmFree(emb_8_embbag_valid_indices_dram, "emb_8_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_8_embbag_valid_indices dram freeing failed!");
    status = synTensorDestroy(emb_8_embbag_dedw_grad_inter);
    ASSERT_TRUE(status == synSuccess && "emb_8_embbag_dedw_grad_inter tensor destruction failed!");

    status = synTensorDestroy(emb_8_embbag_weight_golden);
    ASSERT_TRUE(status == synSuccess && "emb_8_embbag_weight_golden tensor destruction failed!");
    status = hbmFree(emb_8_embbag_weight_golden_dram, "emb_8_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_8_embbag_weight_golden dram freeing failed!");
    status = synTensorDestroy(emb_8_embbag_momentum);
    ASSERT_TRUE(status == synSuccess && "emb_8_embbag_momentum tensor destruction failed!");
    status = hbmFree(emb_8_embbag_momentum_dram, "emb_8_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_8_embbag_momentum dram freeing failed!");
    status = synTensorDestroy(emb_8_embbag_dedw_param_table_indices);
    ASSERT_TRUE(status == synSuccess && "emb_8_embbag_dedw_param_table_indices tensor destruction failed!");
    status = hbmFree(emb_8_embbag_dedw_param_table_indices_dram, "emb_8_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_8_embbag_dedw_param_table_indices dram freeing failed!");
    status = synTensorDestroy(emb_8_offset_shape);
    ASSERT_TRUE(status == synSuccess && "emb_8_offset_shape tensor destruction failed!");
    status = hbmFree(emb_8_offset_shape_dram, "emb_8_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_8_offset_shape dram freeing failed!");
    status = synTensorDestroy(emb_8_embbag_dedw_weight_output_golden);
    ASSERT_TRUE(status == synSuccess && "emb_8_embbag_dedw_weight_output_golden tensor destruction failed!");
    status = synTensorDestroy(emb_8_embbag_dedw_momentum_output);
    ASSERT_TRUE(status == synSuccess && "emb_8_embbag_dedw_momentum_output tensor destruction failed!");
    status = hbmFree(emb_8_embbag_dedw_momentum_output_dram, "emb_8_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_8_embbag_dedw_momentum_output dram freeing failed!");
    status = synTensorDestroy(emb_8_embbag_dedw_weight_output);
    ASSERT_TRUE(status == synSuccess && "emb_8_embbag_dedw_weight_output tensor destruction failed!");

    status = synTensorDestroy(emb_9_embbag_dedw_grad_indices);
    ASSERT_TRUE(status == synSuccess && "emb_9_embbag_dedw_grad_indices tensor destruction failed!");
    status = hbmFree(emb_9_embbag_dedw_grad_indices_dram, "emb_9_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_9_embbag_dedw_grad_indices dram freeing failed!");
    status = synTensorDestroy(emb_9_embbag_dedw_lengths);
    ASSERT_TRUE(status == synSuccess && "emb_9_embbag_dedw_lengths tensor destruction failed!");
    status = hbmFree(emb_9_embbag_dedw_lengths_dram, "emb_9_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_9_embbag_dedw_lengths dram freeing failed!");
    status = synTensorDestroy(emb_9_embbag_valid_indices);
    ASSERT_TRUE(status == synSuccess && "emb_9_embbag_valid_indices tensor destruction failed!");
    status = hbmFree(emb_9_embbag_valid_indices_dram, "emb_9_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_9_embbag_valid_indices dram freeing failed!");
    status = synTensorDestroy(emb_9_embbag_dedw_grad_inter);
    ASSERT_TRUE(status == synSuccess && "emb_9_embbag_dedw_grad_inter tensor destruction failed!");

    status = synTensorDestroy(emb_9_embbag_weight_golden);
    ASSERT_TRUE(status == synSuccess && "emb_9_embbag_weight_golden tensor destruction failed!");
    status = hbmFree(emb_9_embbag_weight_golden_dram, "emb_9_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_9_embbag_weight_golden dram freeing failed!");
    status = synTensorDestroy(emb_9_embbag_momentum);
    ASSERT_TRUE(status == synSuccess && "emb_9_embbag_momentum tensor destruction failed!");
    status = hbmFree(emb_9_embbag_momentum_dram, "emb_9_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_9_embbag_momentum dram freeing failed!");
    status = synTensorDestroy(emb_9_embbag_dedw_param_table_indices);
    ASSERT_TRUE(status == synSuccess && "emb_9_embbag_dedw_param_table_indices tensor destruction failed!");
    status = hbmFree(emb_9_embbag_dedw_param_table_indices_dram, "emb_9_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_9_embbag_dedw_param_table_indices dram freeing failed!");
    status = synTensorDestroy(emb_9_offset_shape);
    ASSERT_TRUE(status == synSuccess && "emb_9_offset_shape tensor destruction failed!");
    status = hbmFree(emb_9_offset_shape_dram, "emb_9_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_9_offset_shape dram freeing failed!");
    status = synTensorDestroy(emb_9_embbag_dedw_weight_output_golden);
    ASSERT_TRUE(status == synSuccess && "emb_9_embbag_dedw_weight_output_golden tensor destruction failed!");
    status = synTensorDestroy(emb_9_embbag_dedw_momentum_output);
    ASSERT_TRUE(status == synSuccess && "emb_9_embbag_dedw_momentum_output tensor destruction failed!");
    status = hbmFree(emb_9_embbag_dedw_momentum_output_dram, "emb_9_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_9_embbag_dedw_momentum_output dram freeing failed!");
    status = synTensorDestroy(emb_9_embbag_dedw_weight_output);
    ASSERT_TRUE(status == synSuccess && "emb_9_embbag_dedw_weight_output tensor destruction failed!");

    status = synTensorDestroy(emb_10_embbag_dedw_grad_indices);
    ASSERT_TRUE(status == synSuccess && "emb_10_embbag_dedw_grad_indices tensor destruction failed!");
    status = hbmFree(emb_10_embbag_dedw_grad_indices_dram, "emb_10_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_10_embbag_dedw_grad_indices dram freeing failed!");
    status = synTensorDestroy(emb_10_embbag_dedw_lengths);
    ASSERT_TRUE(status == synSuccess && "emb_10_embbag_dedw_lengths tensor destruction failed!");
    status = hbmFree(emb_10_embbag_dedw_lengths_dram, "emb_10_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_10_embbag_dedw_lengths dram freeing failed!");
    status = synTensorDestroy(emb_10_embbag_valid_indices);
    ASSERT_TRUE(status == synSuccess && "emb_10_embbag_valid_indices tensor destruction failed!");
    status = hbmFree(emb_10_embbag_valid_indices_dram, "emb_10_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_10_embbag_valid_indices dram freeing failed!");
    status = synTensorDestroy(emb_10_embbag_dedw_grad_inter);
    ASSERT_TRUE(status == synSuccess && "emb_10_embbag_dedw_grad_inter tensor destruction failed!");

    status = synTensorDestroy(emb_10_embbag_weight_golden);
    ASSERT_TRUE(status == synSuccess && "emb_10_embbag_weight_golden tensor destruction failed!");
    status = hbmFree(emb_10_embbag_weight_golden_dram, "emb_10_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_10_embbag_weight_golden dram freeing failed!");
    status = synTensorDestroy(emb_10_embbag_momentum);
    ASSERT_TRUE(status == synSuccess && "emb_10_embbag_momentum tensor destruction failed!");
    status = hbmFree(emb_10_embbag_momentum_dram, "emb_10_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_10_embbag_momentum dram freeing failed!");
    status = synTensorDestroy(emb_10_embbag_dedw_param_table_indices);
    ASSERT_TRUE(status == synSuccess && "emb_10_embbag_dedw_param_table_indices tensor destruction failed!");
    status = hbmFree(emb_10_embbag_dedw_param_table_indices_dram, "emb_10_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_10_embbag_dedw_param_table_indices dram freeing failed!");
    status = synTensorDestroy(emb_10_offset_shape);
    ASSERT_TRUE(status == synSuccess && "emb_10_offset_shape tensor destruction failed!");
    status = hbmFree(emb_10_offset_shape_dram, "emb_10_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_10_offset_shape dram freeing failed!");
    status = synTensorDestroy(emb_10_embbag_dedw_weight_output_golden);
    ASSERT_TRUE(status == synSuccess && "emb_10_embbag_dedw_weight_output_golden tensor destruction failed!");
    status = synTensorDestroy(emb_10_embbag_dedw_momentum_output);
    ASSERT_TRUE(status == synSuccess && "emb_10_embbag_dedw_momentum_output tensor destruction failed!");
    status = hbmFree(emb_10_embbag_dedw_momentum_output_dram, "emb_10_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_10_embbag_dedw_momentum_output dram freeing failed!");
    status = synTensorDestroy(emb_10_embbag_dedw_weight_output);
    ASSERT_TRUE(status == synSuccess && "emb_10_embbag_dedw_weight_output tensor destruction failed!");

    status = synTensorDestroy(emb_11_embbag_dedw_grad_indices);
    ASSERT_TRUE(status == synSuccess && "emb_11_embbag_dedw_grad_indices tensor destruction failed!");
    status = hbmFree(emb_11_embbag_dedw_grad_indices_dram, "emb_11_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_11_embbag_dedw_grad_indices dram freeing failed!");
    status = synTensorDestroy(emb_11_embbag_dedw_lengths);
    ASSERT_TRUE(status == synSuccess && "emb_11_embbag_dedw_lengths tensor destruction failed!");
    status = hbmFree(emb_11_embbag_dedw_lengths_dram, "emb_11_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_11_embbag_dedw_lengths dram freeing failed!");
    status = synTensorDestroy(emb_11_embbag_valid_indices);
    ASSERT_TRUE(status == synSuccess && "emb_11_embbag_valid_indices tensor destruction failed!");
    status = hbmFree(emb_11_embbag_valid_indices_dram, "emb_11_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_11_embbag_valid_indices dram freeing failed!");
    status = synTensorDestroy(emb_11_embbag_dedw_grad_inter);
    ASSERT_TRUE(status == synSuccess && "emb_11_embbag_dedw_grad_inter tensor destruction failed!");

    status = synTensorDestroy(emb_11_embbag_weight_golden);
    ASSERT_TRUE(status == synSuccess && "emb_11_embbag_weight_golden tensor destruction failed!");
    status = hbmFree(emb_11_embbag_weight_golden_dram, "emb_11_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_11_embbag_weight_golden dram freeing failed!");
    status = synTensorDestroy(emb_11_embbag_momentum);
    ASSERT_TRUE(status == synSuccess && "emb_11_embbag_momentum tensor destruction failed!");
    status = hbmFree(emb_11_embbag_momentum_dram, "emb_11_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_11_embbag_momentum dram freeing failed!");
    status = synTensorDestroy(emb_11_embbag_dedw_param_table_indices);
    ASSERT_TRUE(status == synSuccess && "emb_11_embbag_dedw_param_table_indices tensor destruction failed!");
    status = hbmFree(emb_11_embbag_dedw_param_table_indices_dram, "emb_11_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_11_embbag_dedw_param_table_indices dram freeing failed!");
    status = synTensorDestroy(emb_11_offset_shape);
    ASSERT_TRUE(status == synSuccess && "emb_11_offset_shape tensor destruction failed!");
    status = hbmFree(emb_11_offset_shape_dram, "emb_11_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_11_offset_shape dram freeing failed!");
    status = synTensorDestroy(emb_11_embbag_dedw_weight_output_golden);
    ASSERT_TRUE(status == synSuccess && "emb_11_embbag_dedw_weight_output_golden tensor destruction failed!");
    status = synTensorDestroy(emb_11_embbag_dedw_momentum_output);
    ASSERT_TRUE(status == synSuccess && "emb_11_embbag_dedw_momentum_output tensor destruction failed!");
    status = hbmFree(emb_11_embbag_dedw_momentum_output_dram, "emb_11_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_11_embbag_dedw_momentum_output dram freeing failed!");
    status = synTensorDestroy(emb_11_embbag_dedw_weight_output);
    ASSERT_TRUE(status == synSuccess && "emb_11_embbag_dedw_weight_output tensor destruction failed!");

    status = synTensorDestroy(emb_12_embbag_dedw_grad_indices);
    ASSERT_TRUE(status == synSuccess && "emb_12_embbag_dedw_grad_indices tensor destruction failed!");
    status = hbmFree(emb_12_embbag_dedw_grad_indices_dram, "emb_12_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_12_embbag_dedw_grad_indices dram freeing failed!");
    status = synTensorDestroy(emb_12_embbag_dedw_lengths);
    ASSERT_TRUE(status == synSuccess && "emb_12_embbag_dedw_lengths tensor destruction failed!");
    status = hbmFree(emb_12_embbag_dedw_lengths_dram, "emb_12_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_12_embbag_dedw_lengths dram freeing failed!");
    status = synTensorDestroy(emb_12_embbag_valid_indices);
    ASSERT_TRUE(status == synSuccess && "emb_12_embbag_valid_indices tensor destruction failed!");
    status = hbmFree(emb_12_embbag_valid_indices_dram, "emb_12_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_12_embbag_valid_indices dram freeing failed!");
    status = synTensorDestroy(emb_12_embbag_dedw_grad_inter);
    ASSERT_TRUE(status == synSuccess && "emb_12_embbag_dedw_grad_inter tensor destruction failed!");

    status = synTensorDestroy(emb_12_embbag_weight_golden);
    ASSERT_TRUE(status == synSuccess && "emb_12_embbag_weight_golden tensor destruction failed!");
    status = hbmFree(emb_12_embbag_weight_golden_dram, "emb_12_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_12_embbag_weight_golden dram freeing failed!");
    status = synTensorDestroy(emb_12_embbag_momentum);
    ASSERT_TRUE(status == synSuccess && "emb_12_embbag_momentum tensor destruction failed!");
    status = hbmFree(emb_12_embbag_momentum_dram, "emb_12_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_12_embbag_momentum dram freeing failed!");
    status = synTensorDestroy(emb_12_embbag_dedw_param_table_indices);
    ASSERT_TRUE(status == synSuccess && "emb_12_embbag_dedw_param_table_indices tensor destruction failed!");
    status = hbmFree(emb_12_embbag_dedw_param_table_indices_dram, "emb_12_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_12_embbag_dedw_param_table_indices dram freeing failed!");
    status = synTensorDestroy(emb_12_offset_shape);
    ASSERT_TRUE(status == synSuccess && "emb_12_offset_shape tensor destruction failed!");
    status = hbmFree(emb_12_offset_shape_dram, "emb_12_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_12_offset_shape dram freeing failed!");
    status = synTensorDestroy(emb_12_embbag_dedw_weight_output_golden);
    ASSERT_TRUE(status == synSuccess && "emb_12_embbag_dedw_weight_output_golden tensor destruction failed!");
    status = synTensorDestroy(emb_12_embbag_dedw_momentum_output);
    ASSERT_TRUE(status == synSuccess && "emb_12_embbag_dedw_momentum_output tensor destruction failed!");
    status = hbmFree(emb_12_embbag_dedw_momentum_output_dram, "emb_12_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_12_embbag_dedw_momentum_output dram freeing failed!");
    status = synTensorDestroy(emb_12_embbag_dedw_weight_output);
    ASSERT_TRUE(status == synSuccess && "emb_12_embbag_dedw_weight_output tensor destruction failed!");

    status = synTensorDestroy(emb_13_embbag_dedw_grad_indices);
    ASSERT_TRUE(status == synSuccess && "emb_13_embbag_dedw_grad_indices tensor destruction failed!");
    status = hbmFree(emb_13_embbag_dedw_grad_indices_dram, "emb_13_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_13_embbag_dedw_grad_indices dram freeing failed!");
    status = synTensorDestroy(emb_13_embbag_dedw_lengths);
    ASSERT_TRUE(status == synSuccess && "emb_13_embbag_dedw_lengths tensor destruction failed!");
    status = hbmFree(emb_13_embbag_dedw_lengths_dram, "emb_13_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_13_embbag_dedw_lengths dram freeing failed!");
    status = synTensorDestroy(emb_13_embbag_valid_indices);
    ASSERT_TRUE(status == synSuccess && "emb_13_embbag_valid_indices tensor destruction failed!");
    status = hbmFree(emb_13_embbag_valid_indices_dram, "emb_13_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_13_embbag_valid_indices dram freeing failed!");
    status = synTensorDestroy(emb_13_embbag_dedw_grad_inter);
    ASSERT_TRUE(status == synSuccess && "emb_13_embbag_dedw_grad_inter tensor destruction failed!");

    status = synTensorDestroy(emb_13_embbag_weight_golden);
    ASSERT_TRUE(status == synSuccess && "emb_13_embbag_weight_golden tensor destruction failed!");
    status = hbmFree(emb_13_embbag_weight_golden_dram, "emb_13_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_13_embbag_weight_golden dram freeing failed!");
    status = synTensorDestroy(emb_13_embbag_momentum);
    ASSERT_TRUE(status == synSuccess && "emb_13_embbag_momentum tensor destruction failed!");
    status = hbmFree(emb_13_embbag_momentum_dram, "emb_13_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_13_embbag_momentum dram freeing failed!");
    status = synTensorDestroy(emb_13_embbag_dedw_param_table_indices);
    ASSERT_TRUE(status == synSuccess && "emb_13_embbag_dedw_param_table_indices tensor destruction failed!");
    status = hbmFree(emb_13_embbag_dedw_param_table_indices_dram, "emb_13_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_13_embbag_dedw_param_table_indices dram freeing failed!");
    status = synTensorDestroy(emb_13_offset_shape);
    ASSERT_TRUE(status == synSuccess && "emb_13_offset_shape tensor destruction failed!");
    status = hbmFree(emb_13_offset_shape_dram, "emb_13_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_13_offset_shape dram freeing failed!");
    status = synTensorDestroy(emb_13_embbag_dedw_weight_output_golden);
    ASSERT_TRUE(status == synSuccess && "emb_13_embbag_dedw_weight_output_golden tensor destruction failed!");
    status = synTensorDestroy(emb_13_embbag_dedw_momentum_output);
    ASSERT_TRUE(status == synSuccess && "emb_13_embbag_dedw_momentum_output tensor destruction failed!");
    status = hbmFree(emb_13_embbag_dedw_momentum_output_dram, "emb_13_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_13_embbag_dedw_momentum_output dram freeing failed!");
    status = synTensorDestroy(emb_13_embbag_dedw_weight_output);
    ASSERT_TRUE(status == synSuccess && "emb_13_embbag_dedw_weight_output tensor destruction failed!");

    status = synTensorDestroy(emb_14_embbag_dedw_grad_indices);
    ASSERT_TRUE(status == synSuccess && "emb_14_embbag_dedw_grad_indices tensor destruction failed!");
    status = hbmFree(emb_14_embbag_dedw_grad_indices_dram, "emb_14_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_14_embbag_dedw_grad_indices dram freeing failed!");
    status = synTensorDestroy(emb_14_embbag_dedw_lengths);
    ASSERT_TRUE(status == synSuccess && "emb_14_embbag_dedw_lengths tensor destruction failed!");
    status = hbmFree(emb_14_embbag_dedw_lengths_dram, "emb_14_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_14_embbag_dedw_lengths dram freeing failed!");
    status = synTensorDestroy(emb_14_embbag_valid_indices);
    ASSERT_TRUE(status == synSuccess && "emb_14_embbag_valid_indices tensor destruction failed!");
    status = hbmFree(emb_14_embbag_valid_indices_dram, "emb_14_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_14_embbag_valid_indices dram freeing failed!");
    status = synTensorDestroy(emb_14_embbag_dedw_grad_inter);
    ASSERT_TRUE(status == synSuccess && "emb_14_embbag_dedw_grad_inter tensor destruction failed!");

    status = synTensorDestroy(emb_14_embbag_weight_golden);
    ASSERT_TRUE(status == synSuccess && "emb_14_embbag_weight_golden tensor destruction failed!");
    status = hbmFree(emb_14_embbag_weight_golden_dram, "emb_14_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_14_embbag_weight_golden dram freeing failed!");
    status = synTensorDestroy(emb_14_embbag_momentum);
    ASSERT_TRUE(status == synSuccess && "emb_14_embbag_momentum tensor destruction failed!");
    status = hbmFree(emb_14_embbag_momentum_dram, "emb_14_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_14_embbag_momentum dram freeing failed!");
    status = synTensorDestroy(emb_14_embbag_dedw_param_table_indices);
    ASSERT_TRUE(status == synSuccess && "emb_14_embbag_dedw_param_table_indices tensor destruction failed!");
    status = hbmFree(emb_14_embbag_dedw_param_table_indices_dram, "emb_14_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_14_embbag_dedw_param_table_indices dram freeing failed!");
    status = synTensorDestroy(emb_14_offset_shape);
    ASSERT_TRUE(status == synSuccess && "emb_14_offset_shape tensor destruction failed!");
    status = hbmFree(emb_14_offset_shape_dram, "emb_14_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_14_offset_shape dram freeing failed!");
    status = synTensorDestroy(emb_14_embbag_dedw_weight_output_golden);
    ASSERT_TRUE(status == synSuccess && "emb_14_embbag_dedw_weight_output_golden tensor destruction failed!");
    status = synTensorDestroy(emb_14_embbag_dedw_momentum_output);
    ASSERT_TRUE(status == synSuccess && "emb_14_embbag_dedw_momentum_output tensor destruction failed!");
    status = hbmFree(emb_14_embbag_dedw_momentum_output_dram, "emb_14_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_14_embbag_dedw_momentum_output dram freeing failed!");
    status = synTensorDestroy(emb_14_embbag_dedw_weight_output);
    ASSERT_TRUE(status == synSuccess && "emb_14_embbag_dedw_weight_output tensor destruction failed!");

    status = synTensorDestroy(emb_15_embbag_dedw_grad_indices);
    ASSERT_TRUE(status == synSuccess && "emb_15_embbag_dedw_grad_indices tensor destruction failed!");
    status = hbmFree(emb_15_embbag_dedw_grad_indices_dram, "emb_15_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_15_embbag_dedw_grad_indices dram freeing failed!");
    status = synTensorDestroy(emb_15_embbag_dedw_lengths);
    ASSERT_TRUE(status == synSuccess && "emb_15_embbag_dedw_lengths tensor destruction failed!");
    status = hbmFree(emb_15_embbag_dedw_lengths_dram, "emb_15_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_15_embbag_dedw_lengths dram freeing failed!");
    status = synTensorDestroy(emb_15_embbag_valid_indices);
    ASSERT_TRUE(status == synSuccess && "emb_15_embbag_valid_indices tensor destruction failed!");
    status = hbmFree(emb_15_embbag_valid_indices_dram, "emb_15_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_15_embbag_valid_indices dram freeing failed!");
    status = synTensorDestroy(emb_15_embbag_dedw_grad_inter);
    ASSERT_TRUE(status == synSuccess && "emb_15_embbag_dedw_grad_inter tensor destruction failed!");

    status = synTensorDestroy(emb_15_embbag_weight_golden);
    ASSERT_TRUE(status == synSuccess && "emb_15_embbag_weight_golden tensor destruction failed!");
    status = hbmFree(emb_15_embbag_weight_golden_dram, "emb_15_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_15_embbag_weight_golden dram freeing failed!");
    status = synTensorDestroy(emb_15_embbag_momentum);
    ASSERT_TRUE(status == synSuccess && "emb_15_embbag_momentum tensor destruction failed!");
    status = hbmFree(emb_15_embbag_momentum_dram, "emb_15_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_15_embbag_momentum dram freeing failed!");
    status = synTensorDestroy(emb_15_embbag_dedw_param_table_indices);
    ASSERT_TRUE(status == synSuccess && "emb_15_embbag_dedw_param_table_indices tensor destruction failed!");
    status = hbmFree(emb_15_embbag_dedw_param_table_indices_dram, "emb_15_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_15_embbag_dedw_param_table_indices dram freeing failed!");
    status = synTensorDestroy(emb_15_offset_shape);
    ASSERT_TRUE(status == synSuccess && "emb_15_offset_shape tensor destruction failed!");
    status = hbmFree(emb_15_offset_shape_dram, "emb_15_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_15_offset_shape dram freeing failed!");
    status = synTensorDestroy(emb_15_embbag_dedw_weight_output_golden);
    ASSERT_TRUE(status == synSuccess && "emb_15_embbag_dedw_weight_output_golden tensor destruction failed!");
    status = synTensorDestroy(emb_15_embbag_dedw_momentum_output);
    ASSERT_TRUE(status == synSuccess && "emb_15_embbag_dedw_momentum_output tensor destruction failed!");
    status = hbmFree(emb_15_embbag_dedw_momentum_output_dram, "emb_15_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_15_embbag_dedw_momentum_output dram freeing failed!");
    status = synTensorDestroy(emb_15_embbag_dedw_weight_output);
    ASSERT_TRUE(status == synSuccess && "emb_15_embbag_dedw_weight_output tensor destruction failed!");

    status = synTensorDestroy(emb_16_embbag_dedw_grad_indices);
    ASSERT_TRUE(status == synSuccess && "emb_16_embbag_dedw_grad_indices tensor destruction failed!");
    status = hbmFree(emb_16_embbag_dedw_grad_indices_dram, "emb_16_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_16_embbag_dedw_grad_indices dram freeing failed!");
    status = synTensorDestroy(emb_16_embbag_dedw_lengths);
    ASSERT_TRUE(status == synSuccess && "emb_16_embbag_dedw_lengths tensor destruction failed!");
    status = hbmFree(emb_16_embbag_dedw_lengths_dram, "emb_16_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_16_embbag_dedw_lengths dram freeing failed!");
    status = synTensorDestroy(emb_16_embbag_valid_indices);
    ASSERT_TRUE(status == synSuccess && "emb_16_embbag_valid_indices tensor destruction failed!");
    status = hbmFree(emb_16_embbag_valid_indices_dram, "emb_16_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_16_embbag_valid_indices dram freeing failed!");
    status = synTensorDestroy(emb_16_embbag_dedw_grad_inter);
    ASSERT_TRUE(status == synSuccess && "emb_16_embbag_dedw_grad_inter tensor destruction failed!");

    status = synTensorDestroy(emb_16_embbag_weight_golden);
    ASSERT_TRUE(status == synSuccess && "emb_16_embbag_weight_golden tensor destruction failed!");
    status = hbmFree(emb_16_embbag_weight_golden_dram, "emb_16_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_16_embbag_weight_golden dram freeing failed!");
    status = synTensorDestroy(emb_16_embbag_momentum);
    ASSERT_TRUE(status == synSuccess && "emb_16_embbag_momentum tensor destruction failed!");
    status = hbmFree(emb_16_embbag_momentum_dram, "emb_16_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_16_embbag_momentum dram freeing failed!");
    status = synTensorDestroy(emb_16_embbag_dedw_param_table_indices);
    ASSERT_TRUE(status == synSuccess && "emb_16_embbag_dedw_param_table_indices tensor destruction failed!");
    status = hbmFree(emb_16_embbag_dedw_param_table_indices_dram, "emb_16_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_16_embbag_dedw_param_table_indices dram freeing failed!");
    status = synTensorDestroy(emb_16_offset_shape);
    ASSERT_TRUE(status == synSuccess && "emb_16_offset_shape tensor destruction failed!");
    status = hbmFree(emb_16_offset_shape_dram, "emb_16_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_16_offset_shape dram freeing failed!");
    status = synTensorDestroy(emb_16_embbag_dedw_weight_output_golden);
    ASSERT_TRUE(status == synSuccess && "emb_16_embbag_dedw_weight_output_golden tensor destruction failed!");
    status = synTensorDestroy(emb_16_embbag_dedw_momentum_output);
    ASSERT_TRUE(status == synSuccess && "emb_16_embbag_dedw_momentum_output tensor destruction failed!");
    status = hbmFree(emb_16_embbag_dedw_momentum_output_dram, "emb_16_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_16_embbag_dedw_momentum_output dram freeing failed!");
    status = synTensorDestroy(emb_16_embbag_dedw_weight_output);
    ASSERT_TRUE(status == synSuccess && "emb_16_embbag_dedw_weight_output tensor destruction failed!");

    status = synTensorDestroy(emb_17_embbag_dedw_grad_indices);
    ASSERT_TRUE(status == synSuccess && "emb_17_embbag_dedw_grad_indices tensor destruction failed!");
    status = hbmFree(emb_17_embbag_dedw_grad_indices_dram, "emb_17_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_17_embbag_dedw_grad_indices dram freeing failed!");
    status = synTensorDestroy(emb_17_embbag_dedw_lengths);
    ASSERT_TRUE(status == synSuccess && "emb_17_embbag_dedw_lengths tensor destruction failed!");
    status = hbmFree(emb_17_embbag_dedw_lengths_dram, "emb_17_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_17_embbag_dedw_lengths dram freeing failed!");
    status = synTensorDestroy(emb_17_embbag_valid_indices);
    ASSERT_TRUE(status == synSuccess && "emb_17_embbag_valid_indices tensor destruction failed!");
    status = hbmFree(emb_17_embbag_valid_indices_dram, "emb_17_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_17_embbag_valid_indices dram freeing failed!");
    status = synTensorDestroy(emb_17_embbag_dedw_grad_inter);
    ASSERT_TRUE(status == synSuccess && "emb_17_embbag_dedw_grad_inter tensor destruction failed!");

    status = synTensorDestroy(emb_17_embbag_weight_golden);
    ASSERT_TRUE(status == synSuccess && "emb_17_embbag_weight_golden tensor destruction failed!");
    status = hbmFree(emb_17_embbag_weight_golden_dram, "emb_17_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_17_embbag_weight_golden dram freeing failed!");
    status = synTensorDestroy(emb_17_embbag_momentum);
    ASSERT_TRUE(status == synSuccess && "emb_17_embbag_momentum tensor destruction failed!");
    status = hbmFree(emb_17_embbag_momentum_dram, "emb_17_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_17_embbag_momentum dram freeing failed!");
    status = synTensorDestroy(emb_17_embbag_dedw_param_table_indices);
    ASSERT_TRUE(status == synSuccess && "emb_17_embbag_dedw_param_table_indices tensor destruction failed!");
    status = hbmFree(emb_17_embbag_dedw_param_table_indices_dram, "emb_17_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_17_embbag_dedw_param_table_indices dram freeing failed!");
    status = synTensorDestroy(emb_17_offset_shape);
    ASSERT_TRUE(status == synSuccess && "emb_17_offset_shape tensor destruction failed!");
    status = hbmFree(emb_17_offset_shape_dram, "emb_17_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_17_offset_shape dram freeing failed!");
    status = synTensorDestroy(emb_17_embbag_dedw_weight_output_golden);
    ASSERT_TRUE(status == synSuccess && "emb_17_embbag_dedw_weight_output_golden tensor destruction failed!");
    status = synTensorDestroy(emb_17_embbag_dedw_momentum_output);
    ASSERT_TRUE(status == synSuccess && "emb_17_embbag_dedw_momentum_output tensor destruction failed!");
    status = hbmFree(emb_17_embbag_dedw_momentum_output_dram, "emb_17_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_17_embbag_dedw_momentum_output dram freeing failed!");
    status = synTensorDestroy(emb_17_embbag_dedw_weight_output);
    ASSERT_TRUE(status == synSuccess && "emb_17_embbag_dedw_weight_output tensor destruction failed!");

    status = synTensorDestroy(emb_18_embbag_dedw_grad_indices);
    ASSERT_TRUE(status == synSuccess && "emb_18_embbag_dedw_grad_indices tensor destruction failed!");
    status = hbmFree(emb_18_embbag_dedw_grad_indices_dram, "emb_18_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_18_embbag_dedw_grad_indices dram freeing failed!");
    status = synTensorDestroy(emb_18_embbag_dedw_lengths);
    ASSERT_TRUE(status == synSuccess && "emb_18_embbag_dedw_lengths tensor destruction failed!");
    status = hbmFree(emb_18_embbag_dedw_lengths_dram, "emb_18_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_18_embbag_dedw_lengths dram freeing failed!");
    status = synTensorDestroy(emb_18_embbag_valid_indices);
    ASSERT_TRUE(status == synSuccess && "emb_18_embbag_valid_indices tensor destruction failed!");
    status = hbmFree(emb_18_embbag_valid_indices_dram, "emb_18_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_18_embbag_valid_indices dram freeing failed!");
    status = synTensorDestroy(emb_18_embbag_dedw_grad_inter);
    ASSERT_TRUE(status == synSuccess && "emb_18_embbag_dedw_grad_inter tensor destruction failed!");

    status = synTensorDestroy(emb_18_embbag_weight_golden);
    ASSERT_TRUE(status == synSuccess && "emb_18_embbag_weight_golden tensor destruction failed!");
    status = hbmFree(emb_18_embbag_weight_golden_dram, "emb_18_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_18_embbag_weight_golden dram freeing failed!");
    status = synTensorDestroy(emb_18_embbag_momentum);
    ASSERT_TRUE(status == synSuccess && "emb_18_embbag_momentum tensor destruction failed!");
    status = hbmFree(emb_18_embbag_momentum_dram, "emb_18_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_18_embbag_momentum dram freeing failed!");
    status = synTensorDestroy(emb_18_embbag_dedw_param_table_indices);
    ASSERT_TRUE(status == synSuccess && "emb_18_embbag_dedw_param_table_indices tensor destruction failed!");
    status = hbmFree(emb_18_embbag_dedw_param_table_indices_dram, "emb_18_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_18_embbag_dedw_param_table_indices dram freeing failed!");
    status = synTensorDestroy(emb_18_offset_shape);
    ASSERT_TRUE(status == synSuccess && "emb_18_offset_shape tensor destruction failed!");
    status = hbmFree(emb_18_offset_shape_dram, "emb_18_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_18_offset_shape dram freeing failed!");
    status = synTensorDestroy(emb_18_embbag_dedw_weight_output_golden);
    ASSERT_TRUE(status == synSuccess && "emb_18_embbag_dedw_weight_output_golden tensor destruction failed!");
    status = synTensorDestroy(emb_18_embbag_dedw_momentum_output);
    ASSERT_TRUE(status == synSuccess && "emb_18_embbag_dedw_momentum_output tensor destruction failed!");
    status = hbmFree(emb_18_embbag_dedw_momentum_output_dram, "emb_18_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_18_embbag_dedw_momentum_output dram freeing failed!");
    status = synTensorDestroy(emb_18_embbag_dedw_weight_output);
    ASSERT_TRUE(status == synSuccess && "emb_18_embbag_dedw_weight_output tensor destruction failed!");

    status = synTensorDestroy(emb_19_embbag_dedw_grad_indices);
    ASSERT_TRUE(status == synSuccess && "emb_19_embbag_dedw_grad_indices tensor destruction failed!");
    status = hbmFree(emb_19_embbag_dedw_grad_indices_dram, "emb_19_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_19_embbag_dedw_grad_indices dram freeing failed!");
    status = synTensorDestroy(emb_19_embbag_dedw_lengths);
    ASSERT_TRUE(status == synSuccess && "emb_19_embbag_dedw_lengths tensor destruction failed!");
    status = hbmFree(emb_19_embbag_dedw_lengths_dram, "emb_19_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_19_embbag_dedw_lengths dram freeing failed!");
    status = synTensorDestroy(emb_19_embbag_valid_indices);
    ASSERT_TRUE(status == synSuccess && "emb_19_embbag_valid_indices tensor destruction failed!");
    status = hbmFree(emb_19_embbag_valid_indices_dram, "emb_19_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_19_embbag_valid_indices dram freeing failed!");
    status = synTensorDestroy(emb_19_embbag_dedw_grad_inter);
    ASSERT_TRUE(status == synSuccess && "emb_19_embbag_dedw_grad_inter tensor destruction failed!");

    status = synTensorDestroy(emb_19_embbag_weight_golden);
    ASSERT_TRUE(status == synSuccess && "emb_19_embbag_weight_golden tensor destruction failed!");
    status = hbmFree(emb_19_embbag_weight_golden_dram, "emb_19_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_19_embbag_weight_golden dram freeing failed!");
    status = synTensorDestroy(emb_19_embbag_momentum);
    ASSERT_TRUE(status == synSuccess && "emb_19_embbag_momentum tensor destruction failed!");
    status = hbmFree(emb_19_embbag_momentum_dram, "emb_19_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_19_embbag_momentum dram freeing failed!");
    status = synTensorDestroy(emb_19_embbag_dedw_param_table_indices);
    ASSERT_TRUE(status == synSuccess && "emb_19_embbag_dedw_param_table_indices tensor destruction failed!");
    status = hbmFree(emb_19_embbag_dedw_param_table_indices_dram, "emb_19_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_19_embbag_dedw_param_table_indices dram freeing failed!");
    status = synTensorDestroy(emb_19_offset_shape);
    ASSERT_TRUE(status == synSuccess && "emb_19_offset_shape tensor destruction failed!");
    status = hbmFree(emb_19_offset_shape_dram, "emb_19_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_19_offset_shape dram freeing failed!");
    status = synTensorDestroy(emb_19_embbag_dedw_weight_output_golden);
    ASSERT_TRUE(status == synSuccess && "emb_19_embbag_dedw_weight_output_golden tensor destruction failed!");
    status = synTensorDestroy(emb_19_embbag_dedw_momentum_output);
    ASSERT_TRUE(status == synSuccess && "emb_19_embbag_dedw_momentum_output tensor destruction failed!");
    status = hbmFree(emb_19_embbag_dedw_momentum_output_dram, "emb_19_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_19_embbag_dedw_momentum_output dram freeing failed!");
    status = synTensorDestroy(emb_19_embbag_dedw_weight_output);
    ASSERT_TRUE(status == synSuccess && "emb_19_embbag_dedw_weight_output tensor destruction failed!");

    status = synTensorDestroy(emb_20_embbag_dedw_grad_indices);
    ASSERT_TRUE(status == synSuccess && "emb_20_embbag_dedw_grad_indices tensor destruction failed!");
    status = hbmFree(emb_20_embbag_dedw_grad_indices_dram, "emb_20_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_20_embbag_dedw_grad_indices dram freeing failed!");
    status = synTensorDestroy(emb_20_embbag_dedw_lengths);
    ASSERT_TRUE(status == synSuccess && "emb_20_embbag_dedw_lengths tensor destruction failed!");
    status = hbmFree(emb_20_embbag_dedw_lengths_dram, "emb_20_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_20_embbag_dedw_lengths dram freeing failed!");
    status = synTensorDestroy(emb_20_embbag_valid_indices);
    ASSERT_TRUE(status == synSuccess && "emb_20_embbag_valid_indices tensor destruction failed!");
    status = hbmFree(emb_20_embbag_valid_indices_dram, "emb_20_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_20_embbag_valid_indices dram freeing failed!");
    status = synTensorDestroy(emb_20_embbag_dedw_grad_inter);
    ASSERT_TRUE(status == synSuccess && "emb_20_embbag_dedw_grad_inter tensor destruction failed!");

    status = synTensorDestroy(emb_20_embbag_weight_golden);
    ASSERT_TRUE(status == synSuccess && "emb_20_embbag_weight_golden tensor destruction failed!");
    status = hbmFree(emb_20_embbag_weight_golden_dram, "emb_20_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_20_embbag_weight_golden dram freeing failed!");
    status = synTensorDestroy(emb_20_embbag_momentum);
    ASSERT_TRUE(status == synSuccess && "emb_20_embbag_momentum tensor destruction failed!");
    status = hbmFree(emb_20_embbag_momentum_dram, "emb_20_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_20_embbag_momentum dram freeing failed!");
    status = synTensorDestroy(emb_20_embbag_dedw_param_table_indices);
    ASSERT_TRUE(status == synSuccess && "emb_20_embbag_dedw_param_table_indices tensor destruction failed!");
    status = hbmFree(emb_20_embbag_dedw_param_table_indices_dram, "emb_20_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_20_embbag_dedw_param_table_indices dram freeing failed!");
    status = synTensorDestroy(emb_20_offset_shape);
    ASSERT_TRUE(status == synSuccess && "emb_20_offset_shape tensor destruction failed!");
    status = hbmFree(emb_20_offset_shape_dram, "emb_20_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_20_offset_shape dram freeing failed!");
    status = synTensorDestroy(emb_20_embbag_dedw_weight_output_golden);
    ASSERT_TRUE(status == synSuccess && "emb_20_embbag_dedw_weight_output_golden tensor destruction failed!");
    status = synTensorDestroy(emb_20_embbag_dedw_momentum_output);
    ASSERT_TRUE(status == synSuccess && "emb_20_embbag_dedw_momentum_output tensor destruction failed!");
    status = hbmFree(emb_20_embbag_dedw_momentum_output_dram, "emb_20_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_20_embbag_dedw_momentum_output dram freeing failed!");
    status = synTensorDestroy(emb_20_embbag_dedw_weight_output);
    ASSERT_TRUE(status == synSuccess && "emb_20_embbag_dedw_weight_output tensor destruction failed!");

    status = synTensorDestroy(emb_21_embbag_dedw_grad_indices);
    ASSERT_TRUE(status == synSuccess && "emb_21_embbag_dedw_grad_indices tensor destruction failed!");
    status = hbmFree(emb_21_embbag_dedw_grad_indices_dram, "emb_21_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_21_embbag_dedw_grad_indices dram freeing failed!");
    status = synTensorDestroy(emb_21_embbag_dedw_lengths);
    ASSERT_TRUE(status == synSuccess && "emb_21_embbag_dedw_lengths tensor destruction failed!");
    status = hbmFree(emb_21_embbag_dedw_lengths_dram, "emb_21_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_21_embbag_dedw_lengths dram freeing failed!");
    status = synTensorDestroy(emb_21_embbag_valid_indices);
    ASSERT_TRUE(status == synSuccess && "emb_21_embbag_valid_indices tensor destruction failed!");
    status = hbmFree(emb_21_embbag_valid_indices_dram, "emb_21_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_21_embbag_valid_indices dram freeing failed!");
    status = synTensorDestroy(emb_21_embbag_dedw_grad_inter);
    ASSERT_TRUE(status == synSuccess && "emb_21_embbag_dedw_grad_inter tensor destruction failed!");

    status = synTensorDestroy(emb_21_embbag_weight_golden);
    ASSERT_TRUE(status == synSuccess && "emb_21_embbag_weight_golden tensor destruction failed!");
    status = hbmFree(emb_21_embbag_weight_golden_dram, "emb_21_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_21_embbag_weight_golden dram freeing failed!");
    status = synTensorDestroy(emb_21_embbag_momentum);
    ASSERT_TRUE(status == synSuccess && "emb_21_embbag_momentum tensor destruction failed!");
    status = hbmFree(emb_21_embbag_momentum_dram, "emb_21_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_21_embbag_momentum dram freeing failed!");
    status = synTensorDestroy(emb_21_embbag_dedw_param_table_indices);
    ASSERT_TRUE(status == synSuccess && "emb_21_embbag_dedw_param_table_indices tensor destruction failed!");
    status = hbmFree(emb_21_embbag_dedw_param_table_indices_dram, "emb_21_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_21_embbag_dedw_param_table_indices dram freeing failed!");
    status = synTensorDestroy(emb_21_offset_shape);
    ASSERT_TRUE(status == synSuccess && "emb_21_offset_shape tensor destruction failed!");
    status = hbmFree(emb_21_offset_shape_dram, "emb_21_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_21_offset_shape dram freeing failed!");
    status = synTensorDestroy(emb_21_embbag_dedw_weight_output_golden);
    ASSERT_TRUE(status == synSuccess && "emb_21_embbag_dedw_weight_output_golden tensor destruction failed!");
    status = synTensorDestroy(emb_21_embbag_dedw_momentum_output);
    ASSERT_TRUE(status == synSuccess && "emb_21_embbag_dedw_momentum_output tensor destruction failed!");
    status = hbmFree(emb_21_embbag_dedw_momentum_output_dram, "emb_21_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_21_embbag_dedw_momentum_output dram freeing failed!");
    status = synTensorDestroy(emb_21_embbag_dedw_weight_output);
    ASSERT_TRUE(status == synSuccess && "emb_21_embbag_dedw_weight_output tensor destruction failed!");

    status = synTensorDestroy(emb_22_embbag_dedw_grad_indices);
    ASSERT_TRUE(status == synSuccess && "emb_22_embbag_dedw_grad_indices tensor destruction failed!");
    status = hbmFree(emb_22_embbag_dedw_grad_indices_dram, "emb_22_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_22_embbag_dedw_grad_indices dram freeing failed!");
    status = synTensorDestroy(emb_22_embbag_dedw_lengths);
    ASSERT_TRUE(status == synSuccess && "emb_22_embbag_dedw_lengths tensor destruction failed!");
    status = hbmFree(emb_22_embbag_dedw_lengths_dram, "emb_22_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_22_embbag_dedw_lengths dram freeing failed!");
    status = synTensorDestroy(emb_22_embbag_valid_indices);
    ASSERT_TRUE(status == synSuccess && "emb_22_embbag_valid_indices tensor destruction failed!");
    status = hbmFree(emb_22_embbag_valid_indices_dram, "emb_22_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_22_embbag_valid_indices dram freeing failed!");
    status = synTensorDestroy(emb_22_embbag_dedw_grad_inter);
    ASSERT_TRUE(status == synSuccess && "emb_22_embbag_dedw_grad_inter tensor destruction failed!");

    status = synTensorDestroy(emb_22_embbag_weight_golden);
    ASSERT_TRUE(status == synSuccess && "emb_22_embbag_weight_golden tensor destruction failed!");
    status = hbmFree(emb_22_embbag_weight_golden_dram, "emb_22_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_22_embbag_weight_golden dram freeing failed!");
    status = synTensorDestroy(emb_22_embbag_momentum);
    ASSERT_TRUE(status == synSuccess && "emb_22_embbag_momentum tensor destruction failed!");
    status = hbmFree(emb_22_embbag_momentum_dram, "emb_22_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_22_embbag_momentum dram freeing failed!");
    status = synTensorDestroy(emb_22_embbag_dedw_param_table_indices);
    ASSERT_TRUE(status == synSuccess && "emb_22_embbag_dedw_param_table_indices tensor destruction failed!");
    status = hbmFree(emb_22_embbag_dedw_param_table_indices_dram, "emb_22_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_22_embbag_dedw_param_table_indices dram freeing failed!");
    status = synTensorDestroy(emb_22_offset_shape);
    ASSERT_TRUE(status == synSuccess && "emb_22_offset_shape tensor destruction failed!");
    status = hbmFree(emb_22_offset_shape_dram, "emb_22_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_22_offset_shape dram freeing failed!");
    status = synTensorDestroy(emb_22_embbag_dedw_weight_output_golden);
    ASSERT_TRUE(status == synSuccess && "emb_22_embbag_dedw_weight_output_golden tensor destruction failed!");
    status = synTensorDestroy(emb_22_embbag_dedw_momentum_output);
    ASSERT_TRUE(status == synSuccess && "emb_22_embbag_dedw_momentum_output tensor destruction failed!");
    status = hbmFree(emb_22_embbag_dedw_momentum_output_dram, "emb_22_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_22_embbag_dedw_momentum_output dram freeing failed!");
    status = synTensorDestroy(emb_22_embbag_dedw_weight_output);
    ASSERT_TRUE(status == synSuccess && "emb_22_embbag_dedw_weight_output tensor destruction failed!");

    status = synTensorDestroy(emb_23_embbag_dedw_grad_indices);
    ASSERT_TRUE(status == synSuccess && "emb_23_embbag_dedw_grad_indices tensor destruction failed!");
    status = hbmFree(emb_23_embbag_dedw_grad_indices_dram, "emb_23_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_23_embbag_dedw_grad_indices dram freeing failed!");
    status = synTensorDestroy(emb_23_embbag_dedw_lengths);
    ASSERT_TRUE(status == synSuccess && "emb_23_embbag_dedw_lengths tensor destruction failed!");
    status = hbmFree(emb_23_embbag_dedw_lengths_dram, "emb_23_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_23_embbag_dedw_lengths dram freeing failed!");
    status = synTensorDestroy(emb_23_embbag_valid_indices);
    ASSERT_TRUE(status == synSuccess && "emb_23_embbag_valid_indices tensor destruction failed!");
    status = hbmFree(emb_23_embbag_valid_indices_dram, "emb_23_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_23_embbag_valid_indices dram freeing failed!");
    status = synTensorDestroy(emb_23_embbag_dedw_grad_inter);
    ASSERT_TRUE(status == synSuccess && "emb_23_embbag_dedw_grad_inter tensor destruction failed!");

    status = synTensorDestroy(emb_23_embbag_weight_golden);
    ASSERT_TRUE(status == synSuccess && "emb_23_embbag_weight_golden tensor destruction failed!");
    status = hbmFree(emb_23_embbag_weight_golden_dram, "emb_23_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_23_embbag_weight_golden dram freeing failed!");
    status = synTensorDestroy(emb_23_embbag_momentum);
    ASSERT_TRUE(status == synSuccess && "emb_23_embbag_momentum tensor destruction failed!");
    status = hbmFree(emb_23_embbag_momentum_dram, "emb_23_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_23_embbag_momentum dram freeing failed!");
    status = synTensorDestroy(emb_23_embbag_dedw_param_table_indices);
    ASSERT_TRUE(status == synSuccess && "emb_23_embbag_dedw_param_table_indices tensor destruction failed!");
    status = hbmFree(emb_23_embbag_dedw_param_table_indices_dram, "emb_23_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_23_embbag_dedw_param_table_indices dram freeing failed!");
    status = synTensorDestroy(emb_23_offset_shape);
    ASSERT_TRUE(status == synSuccess && "emb_23_offset_shape tensor destruction failed!");
    status = hbmFree(emb_23_offset_shape_dram, "emb_23_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_23_offset_shape dram freeing failed!");
    status = synTensorDestroy(emb_23_embbag_dedw_weight_output_golden);
    ASSERT_TRUE(status == synSuccess && "emb_23_embbag_dedw_weight_output_golden tensor destruction failed!");
    status = synTensorDestroy(emb_23_embbag_dedw_momentum_output);
    ASSERT_TRUE(status == synSuccess && "emb_23_embbag_dedw_momentum_output tensor destruction failed!");
    status = hbmFree(emb_23_embbag_dedw_momentum_output_dram, "emb_23_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_23_embbag_dedw_momentum_output dram freeing failed!");
    status = synTensorDestroy(emb_23_embbag_dedw_weight_output);
    ASSERT_TRUE(status == synSuccess && "emb_23_embbag_dedw_weight_output tensor destruction failed!");

    status = synTensorDestroy(emb_24_embbag_dedw_grad_indices);
    ASSERT_TRUE(status == synSuccess && "emb_24_embbag_dedw_grad_indices tensor destruction failed!");
    status = hbmFree(emb_24_embbag_dedw_grad_indices_dram, "emb_24_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_24_embbag_dedw_grad_indices dram freeing failed!");
    status = synTensorDestroy(emb_24_embbag_dedw_lengths);
    ASSERT_TRUE(status == synSuccess && "emb_24_embbag_dedw_lengths tensor destruction failed!");
    status = hbmFree(emb_24_embbag_dedw_lengths_dram, "emb_24_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_24_embbag_dedw_lengths dram freeing failed!");
    status = synTensorDestroy(emb_24_embbag_valid_indices);
    ASSERT_TRUE(status == synSuccess && "emb_24_embbag_valid_indices tensor destruction failed!");
    status = hbmFree(emb_24_embbag_valid_indices_dram, "emb_24_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_24_embbag_valid_indices dram freeing failed!");
    status = synTensorDestroy(emb_24_embbag_dedw_grad_inter);
    ASSERT_TRUE(status == synSuccess && "emb_24_embbag_dedw_grad_inter tensor destruction failed!");

    status = synTensorDestroy(emb_24_embbag_weight_golden);
    ASSERT_TRUE(status == synSuccess && "emb_24_embbag_weight_golden tensor destruction failed!");
    status = hbmFree(emb_24_embbag_weight_golden_dram, "emb_24_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_24_embbag_weight_golden dram freeing failed!");
    status = synTensorDestroy(emb_24_embbag_momentum);
    ASSERT_TRUE(status == synSuccess && "emb_24_embbag_momentum tensor destruction failed!");
    status = hbmFree(emb_24_embbag_momentum_dram, "emb_24_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_24_embbag_momentum dram freeing failed!");
    status = synTensorDestroy(emb_24_embbag_dedw_param_table_indices);
    ASSERT_TRUE(status == synSuccess && "emb_24_embbag_dedw_param_table_indices tensor destruction failed!");
    status = hbmFree(emb_24_embbag_dedw_param_table_indices_dram, "emb_24_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_24_embbag_dedw_param_table_indices dram freeing failed!");
    status = synTensorDestroy(emb_24_offset_shape);
    ASSERT_TRUE(status == synSuccess && "emb_24_offset_shape tensor destruction failed!");
    status = hbmFree(emb_24_offset_shape_dram, "emb_24_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_24_offset_shape dram freeing failed!");
    status = synTensorDestroy(emb_24_embbag_dedw_weight_output_golden);
    ASSERT_TRUE(status == synSuccess && "emb_24_embbag_dedw_weight_output_golden tensor destruction failed!");
    status = synTensorDestroy(emb_24_embbag_dedw_momentum_output);
    ASSERT_TRUE(status == synSuccess && "emb_24_embbag_dedw_momentum_output tensor destruction failed!");
    status = hbmFree(emb_24_embbag_dedw_momentum_output_dram, "emb_24_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_24_embbag_dedw_momentum_output dram freeing failed!");
    status = synTensorDestroy(emb_24_embbag_dedw_weight_output);
    ASSERT_TRUE(status == synSuccess && "emb_24_embbag_dedw_weight_output tensor destruction failed!");

    status = synTensorDestroy(emb_25_embbag_dedw_grad_indices);
    ASSERT_TRUE(status == synSuccess && "emb_25_embbag_dedw_grad_indices tensor destruction failed!");
    status = hbmFree(emb_25_embbag_dedw_grad_indices_dram, "emb_25_embbag_dedw_grad_indices");
    ASSERT_TRUE(status == synSuccess && "emb_25_embbag_dedw_grad_indices dram freeing failed!");
    status = synTensorDestroy(emb_25_embbag_dedw_lengths);
    ASSERT_TRUE(status == synSuccess && "emb_25_embbag_dedw_lengths tensor destruction failed!");
    status = hbmFree(emb_25_embbag_dedw_lengths_dram, "emb_25_embbag_dedw_lengths");
    ASSERT_TRUE(status == synSuccess && "emb_25_embbag_dedw_lengths dram freeing failed!");
    status = synTensorDestroy(emb_25_embbag_valid_indices);
    ASSERT_TRUE(status == synSuccess && "emb_25_embbag_valid_indices tensor destruction failed!");
    status = hbmFree(emb_25_embbag_valid_indices_dram, "emb_25_embbag_valid_indices");
    ASSERT_TRUE(status == synSuccess && "emb_25_embbag_valid_indices dram freeing failed!");
    status = synTensorDestroy(emb_25_embbag_dedw_grad_inter);
    ASSERT_TRUE(status == synSuccess && "emb_25_embbag_dedw_grad_inter tensor destruction failed!");

    status = synTensorDestroy(emb_25_embbag_weight_golden);
    ASSERT_TRUE(status == synSuccess && "emb_25_embbag_weight_golden tensor destruction failed!");
    status = hbmFree(emb_25_embbag_weight_golden_dram, "emb_25_embbag_weight_golden");
    ASSERT_TRUE(status == synSuccess && "emb_25_embbag_weight_golden dram freeing failed!");
    status = synTensorDestroy(emb_25_embbag_momentum);
    ASSERT_TRUE(status == synSuccess && "emb_25_embbag_momentum tensor destruction failed!");
    status = hbmFree(emb_25_embbag_momentum_dram, "emb_25_embbag_momentum");
    ASSERT_TRUE(status == synSuccess && "emb_25_embbag_momentum dram freeing failed!");
    status = synTensorDestroy(emb_25_embbag_dedw_param_table_indices);
    ASSERT_TRUE(status == synSuccess && "emb_25_embbag_dedw_param_table_indices tensor destruction failed!");
    status = hbmFree(emb_25_embbag_dedw_param_table_indices_dram, "emb_25_embbag_dedw_param_table_indices");
    ASSERT_TRUE(status == synSuccess && "emb_25_embbag_dedw_param_table_indices dram freeing failed!");
    status = synTensorDestroy(emb_25_offset_shape);
    ASSERT_TRUE(status == synSuccess && "emb_25_offset_shape tensor destruction failed!");
    status = hbmFree(emb_25_offset_shape_dram, "emb_25_offset_shape");
    ASSERT_TRUE(status == synSuccess && "emb_25_offset_shape dram freeing failed!");
    status = synTensorDestroy(emb_25_embbag_dedw_weight_output_golden);
    ASSERT_TRUE(status == synSuccess && "emb_25_embbag_dedw_weight_output_golden tensor destruction failed!");
    status = synTensorDestroy(emb_25_embbag_dedw_momentum_output);
    ASSERT_TRUE(status == synSuccess && "emb_25_embbag_dedw_momentum_output tensor destruction failed!");
    status = hbmFree(emb_25_embbag_dedw_momentum_output_dram, "emb_25_embbag_dedw_momentum_output");
    ASSERT_TRUE(status == synSuccess && "emb_25_embbag_dedw_momentum_output dram freeing failed!");
    status = synTensorDestroy(emb_25_embbag_dedw_weight_output);
    ASSERT_TRUE(status == synSuccess && "emb_25_embbag_dedw_weight_output tensor destruction failed!");

    status = synTensorDestroy(bot_l_4_relu_bwd_add_grads_concat_output_tensor_reshape);
    ASSERT_TRUE(status == synSuccess && "bot_l_4_relu_bwd_add_grads_concat_output_tensor_reshape tensor destruction failed!");

    status = synTensorDestroy(bot_l_4_relu_grad_input);
    ASSERT_TRUE(status == synSuccess && "bot_l_4_relu_grad_input tensor destruction failed!");

    status = synTensorDestroy(bot_l_4_linear_grad_input);
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_grad_input tensor destruction failed!");
    status = hbmFree(bot_l_4_linear_grad_input_dram, "bot_l_4_linear_grad_input");
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_grad_input dram freeing failed!");

    status = synTensorDestroy(bot_l_4_linear_weight_grad);
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_weight_grad tensor destruction failed!");
    status = hbmFree(bot_l_4_linear_weight_grad_dram, "bot_l_4_linear_weight_grad");
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_weight_grad dram freeing failed!");

    status = synTensorDestroy(bot_l_4_linear_dedb_bot_l_4_relu_grad_input_tensor_reshape);
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_dedb_bot_l_4_relu_grad_input_tensor_reshape tensor destruction failed!");

    status = synTensorDestroy(bot_l_4_linear_bias_grad);
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_bias_grad tensor destruction failed!");
    status = hbmFree(bot_l_4_linear_bias_grad_dram, "bot_l_4_linear_bias_grad");
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_bias_grad dram freeing failed!");

    status = synTensorDestroy(bot_l_2_relu_grad_input);
    ASSERT_TRUE(status == synSuccess && "bot_l_2_relu_grad_input tensor destruction failed!");

    status = synTensorDestroy(bot_l_2_linear_grad_input);
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_grad_input tensor destruction failed!");
    status = hbmFree(bot_l_2_linear_grad_input_dram, "bot_l_2_linear_grad_input");
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_grad_input dram freeing failed!");

    status = synTensorDestroy(bot_l_2_linear_weight_grad);
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_weight_grad tensor destruction failed!");
    status = hbmFree(bot_l_2_linear_weight_grad_dram, "bot_l_2_linear_weight_grad");
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_weight_grad dram freeing failed!");

    status = synTensorDestroy(bot_l_2_linear_dedb_bot_l_2_relu_grad_input_tensor_reshape);
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_dedb_bot_l_2_relu_grad_input_tensor_reshape tensor destruction failed!");

    status = synTensorDestroy(bot_l_2_linear_bias_grad);
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_bias_grad tensor destruction failed!");
    status = hbmFree(bot_l_2_linear_bias_grad_dram, "bot_l_2_linear_bias_grad");
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_bias_grad dram freeing failed!");

    status = synTensorDestroy(bot_l_0_relu_grad_input);
    ASSERT_TRUE(status == synSuccess && "bot_l_0_relu_grad_input tensor destruction failed!");

    status = synTensorDestroy(bot_l_0_linear_grad_input);
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_grad_input tensor destruction failed!");
    status = hbmFree(bot_l_0_linear_grad_input_dram, "bot_l_0_linear_grad_input");
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_grad_input dram freeing failed!");

    status = synTensorDestroy(bot_l_0_linear_weight_grad);
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_weight_grad tensor destruction failed!");
    status = hbmFree(bot_l_0_linear_weight_grad_dram, "bot_l_0_linear_weight_grad");
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_weight_grad dram freeing failed!");

    status = synTensorDestroy(bot_l_0_linear_dedb_bot_l_0_relu_grad_input_tensor_reshape);
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_dedb_bot_l_0_relu_grad_input_tensor_reshape tensor destruction failed!");

    status = synTensorDestroy(bot_l_0_linear_bias_grad);
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_bias_grad tensor destruction failed!");
    status = hbmFree(bot_l_0_linear_bias_grad_dram, "bot_l_0_linear_bias_grad");
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_bias_grad dram freeing failed!");

    status = synTensorDestroy(bot_l_0_linear_weight_grad_wu);
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_weight_grad_wu tensor destruction failed!");
    status = hbmFree(bot_l_0_linear_weight_grad_wu_dram, "bot_l_0_linear_weight_grad_wu");
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_weight_grad_wu dram freeing failed!");
    status = synTensorDestroy(bot_l_0_linear_weight_golden);
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_weight_golden tensor destruction failed!");
    status = hbmFree(bot_l_0_linear_weight_golden_dram, "bot_l_0_linear_weight_golden");
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_weight_golden dram freeing failed!");
    status = synTensorDestroy(learning_rate);
    ASSERT_TRUE(status == synSuccess && "learning_rate tensor destruction failed!");
    status = hbmFree(learning_rate_dram, "learning_rate");
    ASSERT_TRUE(status == synSuccess && "learning_rate dram freeing failed!");
    status = synTensorDestroy(bot_l_0_linear_weight_golden_wu_out);
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_weight_golden_wu_out tensor destruction failed!");
    status = hbmFree(bot_l_0_linear_weight_golden_wu_out_dram, "bot_l_0_linear_weight_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_weight_golden_wu_out dram freeing failed!");
    status = synTensorDestroy(bot_l_0_linear_weight_wu_out);
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_weight_wu_out tensor destruction failed!");
    status = hbmFree(bot_l_0_linear_weight_wu_out_dram, "bot_l_0_linear_weight_wu_out");
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_weight_wu_out dram freeing failed!");

    status = synTensorDestroy(bot_l_2_linear_weight_grad_wu);
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_weight_grad_wu tensor destruction failed!");
    status = hbmFree(bot_l_2_linear_weight_grad_wu_dram, "bot_l_2_linear_weight_grad_wu");
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_weight_grad_wu dram freeing failed!");
    status = synTensorDestroy(bot_l_2_linear_weight_golden);
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_weight_golden tensor destruction failed!");
    status = hbmFree(bot_l_2_linear_weight_golden_dram, "bot_l_2_linear_weight_golden");
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_weight_golden dram freeing failed!");
    status = synTensorDestroy(bot_l_2_linear_weight_golden_wu_out);
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_weight_golden_wu_out tensor destruction failed!");
    status = hbmFree(bot_l_2_linear_weight_golden_wu_out_dram, "bot_l_2_linear_weight_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_weight_golden_wu_out dram freeing failed!");
    status = synTensorDestroy(bot_l_2_linear_weight_wu_out);
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_weight_wu_out tensor destruction failed!");
    status = hbmFree(bot_l_2_linear_weight_wu_out_dram, "bot_l_2_linear_weight_wu_out");
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_weight_wu_out dram freeing failed!");

    status = synTensorDestroy(bot_l_4_linear_weight_grad_wu);
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_weight_grad_wu tensor destruction failed!");
    status = hbmFree(bot_l_4_linear_weight_grad_wu_dram, "bot_l_4_linear_weight_grad_wu");
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_weight_grad_wu dram freeing failed!");
    status = synTensorDestroy(bot_l_4_linear_weight_golden);
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_weight_golden tensor destruction failed!");
    status = hbmFree(bot_l_4_linear_weight_golden_dram, "bot_l_4_linear_weight_golden");
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_weight_golden dram freeing failed!");
    status = synTensorDestroy(bot_l_4_linear_weight_golden_wu_out);
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_weight_golden_wu_out tensor destruction failed!");
    status = hbmFree(bot_l_4_linear_weight_golden_wu_out_dram, "bot_l_4_linear_weight_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_weight_golden_wu_out dram freeing failed!");
    status = synTensorDestroy(bot_l_4_linear_weight_wu_out);
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_weight_wu_out tensor destruction failed!");
    status = hbmFree(bot_l_4_linear_weight_wu_out_dram, "bot_l_4_linear_weight_wu_out");
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_weight_wu_out dram freeing failed!");

    status = synTensorDestroy(top_l_0_linear_weight_grad_wu);
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_weight_grad_wu tensor destruction failed!");
    status = hbmFree(top_l_0_linear_weight_grad_wu_dram, "top_l_0_linear_weight_grad_wu");
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_weight_grad_wu dram freeing failed!");
    status = synTensorDestroy(top_l_0_linear_weight_golden);
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_weight_golden tensor destruction failed!");
    status = hbmFree(top_l_0_linear_weight_golden_dram, "top_l_0_linear_weight_golden");
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_weight_golden dram freeing failed!");
    status = synTensorDestroy(top_l_0_linear_weight_golden_wu_out);
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_weight_golden_wu_out tensor destruction failed!");
    status = hbmFree(top_l_0_linear_weight_golden_wu_out_dram, "top_l_0_linear_weight_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_weight_golden_wu_out dram freeing failed!");
    status = synTensorDestroy(top_l_0_linear_weight_wu_out);
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_weight_wu_out tensor destruction failed!");
    status = hbmFree(top_l_0_linear_weight_wu_out_dram, "top_l_0_linear_weight_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_weight_wu_out dram freeing failed!");

    status = synTensorDestroy(top_l_2_linear_weight_grad_wu);
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_weight_grad_wu tensor destruction failed!");
    status = hbmFree(top_l_2_linear_weight_grad_wu_dram, "top_l_2_linear_weight_grad_wu");
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_weight_grad_wu dram freeing failed!");
    status = synTensorDestroy(top_l_2_linear_weight_golden);
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_weight_golden tensor destruction failed!");
    status = hbmFree(top_l_2_linear_weight_golden_dram, "top_l_2_linear_weight_golden");
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_weight_golden dram freeing failed!");
    status = synTensorDestroy(top_l_2_linear_weight_golden_wu_out);
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_weight_golden_wu_out tensor destruction failed!");
    status = hbmFree(top_l_2_linear_weight_golden_wu_out_dram, "top_l_2_linear_weight_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_weight_golden_wu_out dram freeing failed!");
    status = synTensorDestroy(top_l_2_linear_weight_wu_out);
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_weight_wu_out tensor destruction failed!");
    status = hbmFree(top_l_2_linear_weight_wu_out_dram, "top_l_2_linear_weight_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_weight_wu_out dram freeing failed!");

    status = synTensorDestroy(top_l_4_linear_weight_grad_wu);
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_weight_grad_wu tensor destruction failed!");
    status = hbmFree(top_l_4_linear_weight_grad_wu_dram, "top_l_4_linear_weight_grad_wu");
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_weight_grad_wu dram freeing failed!");
    status = synTensorDestroy(top_l_4_linear_weight_golden);
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_weight_golden tensor destruction failed!");
    status = hbmFree(top_l_4_linear_weight_golden_dram, "top_l_4_linear_weight_golden");
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_weight_golden dram freeing failed!");
    status = synTensorDestroy(top_l_4_linear_weight_golden_wu_out);
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_weight_golden_wu_out tensor destruction failed!");
    status = hbmFree(top_l_4_linear_weight_golden_wu_out_dram, "top_l_4_linear_weight_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_weight_golden_wu_out dram freeing failed!");
    status = synTensorDestroy(top_l_4_linear_weight_wu_out);
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_weight_wu_out tensor destruction failed!");
    status = hbmFree(top_l_4_linear_weight_wu_out_dram, "top_l_4_linear_weight_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_weight_wu_out dram freeing failed!");

    status = synTensorDestroy(top_l_6_linear_weight_grad_wu);
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_weight_grad_wu tensor destruction failed!");
    status = hbmFree(top_l_6_linear_weight_grad_wu_dram, "top_l_6_linear_weight_grad_wu");
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_weight_grad_wu dram freeing failed!");
    status = synTensorDestroy(top_l_6_linear_weight_golden);
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_weight_golden tensor destruction failed!");
    status = hbmFree(top_l_6_linear_weight_golden_dram, "top_l_6_linear_weight_golden");
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_weight_golden dram freeing failed!");
    status = synTensorDestroy(top_l_6_linear_weight_golden_wu_out);
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_weight_golden_wu_out tensor destruction failed!");
    status = hbmFree(top_l_6_linear_weight_golden_wu_out_dram, "top_l_6_linear_weight_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_weight_golden_wu_out dram freeing failed!");
    status = synTensorDestroy(top_l_6_linear_weight_wu_out);
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_weight_wu_out tensor destruction failed!");
    status = hbmFree(top_l_6_linear_weight_wu_out_dram, "top_l_6_linear_weight_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_weight_wu_out dram freeing failed!");

    status = synTensorDestroy(top_l_8_linear_weight_grad_wu);
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_weight_grad_wu tensor destruction failed!");
    status = hbmFree(top_l_8_linear_weight_grad_wu_dram, "top_l_8_linear_weight_grad_wu");
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_weight_grad_wu dram freeing failed!");
    status = synTensorDestroy(top_l_8_linear_weight_golden);
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_weight_golden tensor destruction failed!");
    status = hbmFree(top_l_8_linear_weight_golden_dram, "top_l_8_linear_weight_golden");
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_weight_golden dram freeing failed!");
    status = synTensorDestroy(top_l_8_linear_weight_golden_wu_out);
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_weight_golden_wu_out tensor destruction failed!");
    status = hbmFree(top_l_8_linear_weight_golden_wu_out_dram, "top_l_8_linear_weight_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_weight_golden_wu_out dram freeing failed!");
    status = synTensorDestroy(top_l_8_linear_weight_wu_out);
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_weight_wu_out tensor destruction failed!");
    status = hbmFree(top_l_8_linear_weight_wu_out_dram, "top_l_8_linear_weight_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_weight_wu_out dram freeing failed!");

    status = synTensorDestroy(top_l_10_linear_weight_grad_wu);
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_weight_grad_wu tensor destruction failed!");
    status = hbmFree(top_l_10_linear_weight_grad_wu_dram, "top_l_10_linear_weight_grad_wu");
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_weight_grad_wu dram freeing failed!");
    status = synTensorDestroy(top_l_10_linear_weight_golden);
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_weight_golden tensor destruction failed!");
    status = hbmFree(top_l_10_linear_weight_golden_dram, "top_l_10_linear_weight_golden");
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_weight_golden dram freeing failed!");
    status = synTensorDestroy(top_l_10_linear_weight_golden_wu_out);
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_weight_golden_wu_out tensor destruction failed!");
    status = hbmFree(top_l_10_linear_weight_golden_wu_out_dram, "top_l_10_linear_weight_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_weight_golden_wu_out dram freeing failed!");
    status = synTensorDestroy(top_l_10_linear_weight_wu_out);
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_weight_wu_out tensor destruction failed!");
    status = hbmFree(top_l_10_linear_weight_wu_out_dram, "top_l_10_linear_weight_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_weight_wu_out dram freeing failed!");

    status = synTensorDestroy(bot_l_0_linear_bias_grad_wu);
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_bias_grad_wu tensor destruction failed!");
    status = hbmFree(bot_l_0_linear_bias_grad_wu_dram, "bot_l_0_linear_bias_grad_wu");
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_bias_grad_wu dram freeing failed!");
    status = synTensorDestroy(bot_l_0_linear_bias_golden);
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_bias_golden tensor destruction failed!");
    status = hbmFree(bot_l_0_linear_bias_golden_dram, "bot_l_0_linear_bias_golden");
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_bias_golden dram freeing failed!");
    status = synTensorDestroy(bot_l_0_linear_bias_golden_wu_out);
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_bias_golden_wu_out tensor destruction failed!");
    status = hbmFree(bot_l_0_linear_bias_golden_wu_out_dram, "bot_l_0_linear_bias_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_bias_golden_wu_out dram freeing failed!");
    status = synTensorDestroy(bot_l_0_linear_bias_wu_out);
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_bias_wu_out tensor destruction failed!");
    status = hbmFree(bot_l_0_linear_bias_wu_out_dram, "bot_l_0_linear_bias_wu_out");
    ASSERT_TRUE(status == synSuccess && "bot_l_0_linear_bias_wu_out dram freeing failed!");

    status = synTensorDestroy(bot_l_2_linear_bias_grad_wu);
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_bias_grad_wu tensor destruction failed!");
    status = hbmFree(bot_l_2_linear_bias_grad_wu_dram, "bot_l_2_linear_bias_grad_wu");
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_bias_grad_wu dram freeing failed!");
    status = synTensorDestroy(bot_l_2_linear_bias_golden);
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_bias_golden tensor destruction failed!");
    status = hbmFree(bot_l_2_linear_bias_golden_dram, "bot_l_2_linear_bias_golden");
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_bias_golden dram freeing failed!");
    status = synTensorDestroy(bot_l_2_linear_bias_golden_wu_out);
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_bias_golden_wu_out tensor destruction failed!");
    status = hbmFree(bot_l_2_linear_bias_golden_wu_out_dram, "bot_l_2_linear_bias_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_bias_golden_wu_out dram freeing failed!");
    status = synTensorDestroy(bot_l_2_linear_bias_wu_out);
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_bias_wu_out tensor destruction failed!");
    status = hbmFree(bot_l_2_linear_bias_wu_out_dram, "bot_l_2_linear_bias_wu_out");
    ASSERT_TRUE(status == synSuccess && "bot_l_2_linear_bias_wu_out dram freeing failed!");

    status = synTensorDestroy(bot_l_4_linear_bias_grad_wu);
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_bias_grad_wu tensor destruction failed!");
    status = hbmFree(bot_l_4_linear_bias_grad_wu_dram, "bot_l_4_linear_bias_grad_wu");
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_bias_grad_wu dram freeing failed!");
    status = synTensorDestroy(bot_l_4_linear_bias_golden);
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_bias_golden tensor destruction failed!");
    status = hbmFree(bot_l_4_linear_bias_golden_dram, "bot_l_4_linear_bias_golden");
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_bias_golden dram freeing failed!");
    status = synTensorDestroy(bot_l_4_linear_bias_golden_wu_out);
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_bias_golden_wu_out tensor destruction failed!");
    status = hbmFree(bot_l_4_linear_bias_golden_wu_out_dram, "bot_l_4_linear_bias_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_bias_golden_wu_out dram freeing failed!");
    status = synTensorDestroy(bot_l_4_linear_bias_wu_out);
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_bias_wu_out tensor destruction failed!");
    status = hbmFree(bot_l_4_linear_bias_wu_out_dram, "bot_l_4_linear_bias_wu_out");
    ASSERT_TRUE(status == synSuccess && "bot_l_4_linear_bias_wu_out dram freeing failed!");

    status = synTensorDestroy(top_l_0_linear_bias_grad_wu);
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_bias_grad_wu tensor destruction failed!");
    status = hbmFree(top_l_0_linear_bias_grad_wu_dram, "top_l_0_linear_bias_grad_wu");
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_bias_grad_wu dram freeing failed!");
    status = synTensorDestroy(top_l_0_linear_bias_golden);
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_bias_golden tensor destruction failed!");
    status = hbmFree(top_l_0_linear_bias_golden_dram, "top_l_0_linear_bias_golden");
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_bias_golden dram freeing failed!");
    status = synTensorDestroy(top_l_0_linear_bias_golden_wu_out);
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_bias_golden_wu_out tensor destruction failed!");
    status = hbmFree(top_l_0_linear_bias_golden_wu_out_dram, "top_l_0_linear_bias_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_bias_golden_wu_out dram freeing failed!");
    status = synTensorDestroy(top_l_0_linear_bias_wu_out);
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_bias_wu_out tensor destruction failed!");
    status = hbmFree(top_l_0_linear_bias_wu_out_dram, "top_l_0_linear_bias_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_0_linear_bias_wu_out dram freeing failed!");

    status = synTensorDestroy(top_l_2_linear_bias_grad_wu);
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_bias_grad_wu tensor destruction failed!");
    status = hbmFree(top_l_2_linear_bias_grad_wu_dram, "top_l_2_linear_bias_grad_wu");
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_bias_grad_wu dram freeing failed!");
    status = synTensorDestroy(top_l_2_linear_bias_golden);
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_bias_golden tensor destruction failed!");
    status = hbmFree(top_l_2_linear_bias_golden_dram, "top_l_2_linear_bias_golden");
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_bias_golden dram freeing failed!");
    status = synTensorDestroy(top_l_2_linear_bias_golden_wu_out);
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_bias_golden_wu_out tensor destruction failed!");
    status = hbmFree(top_l_2_linear_bias_golden_wu_out_dram, "top_l_2_linear_bias_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_bias_golden_wu_out dram freeing failed!");
    status = synTensorDestroy(top_l_2_linear_bias_wu_out);
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_bias_wu_out tensor destruction failed!");
    status = hbmFree(top_l_2_linear_bias_wu_out_dram, "top_l_2_linear_bias_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_2_linear_bias_wu_out dram freeing failed!");

    status = synTensorDestroy(top_l_4_linear_bias_grad_wu);
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_bias_grad_wu tensor destruction failed!");
    status = hbmFree(top_l_4_linear_bias_grad_wu_dram, "top_l_4_linear_bias_grad_wu");
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_bias_grad_wu dram freeing failed!");
    status = synTensorDestroy(top_l_4_linear_bias_golden);
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_bias_golden tensor destruction failed!");
    status = hbmFree(top_l_4_linear_bias_golden_dram, "top_l_4_linear_bias_golden");
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_bias_golden dram freeing failed!");
    status = synTensorDestroy(top_l_4_linear_bias_golden_wu_out);
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_bias_golden_wu_out tensor destruction failed!");
    status = hbmFree(top_l_4_linear_bias_golden_wu_out_dram, "top_l_4_linear_bias_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_bias_golden_wu_out dram freeing failed!");
    status = synTensorDestroy(top_l_4_linear_bias_wu_out);
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_bias_wu_out tensor destruction failed!");
    status = hbmFree(top_l_4_linear_bias_wu_out_dram, "top_l_4_linear_bias_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_4_linear_bias_wu_out dram freeing failed!");

    status = synTensorDestroy(top_l_6_linear_bias_grad_wu);
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_bias_grad_wu tensor destruction failed!");
    status = hbmFree(top_l_6_linear_bias_grad_wu_dram, "top_l_6_linear_bias_grad_wu");
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_bias_grad_wu dram freeing failed!");
    status = synTensorDestroy(top_l_6_linear_bias_golden);
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_bias_golden tensor destruction failed!");
    status = hbmFree(top_l_6_linear_bias_golden_dram, "top_l_6_linear_bias_golden");
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_bias_golden dram freeing failed!");
    status = synTensorDestroy(top_l_6_linear_bias_golden_wu_out);
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_bias_golden_wu_out tensor destruction failed!");
    status = hbmFree(top_l_6_linear_bias_golden_wu_out_dram, "top_l_6_linear_bias_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_bias_golden_wu_out dram freeing failed!");
    status = synTensorDestroy(top_l_6_linear_bias_wu_out);
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_bias_wu_out tensor destruction failed!");
    status = hbmFree(top_l_6_linear_bias_wu_out_dram, "top_l_6_linear_bias_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_6_linear_bias_wu_out dram freeing failed!");

    status = synTensorDestroy(top_l_8_linear_bias_grad_wu);
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_bias_grad_wu tensor destruction failed!");
    status = hbmFree(top_l_8_linear_bias_grad_wu_dram, "top_l_8_linear_bias_grad_wu");
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_bias_grad_wu dram freeing failed!");
    status = synTensorDestroy(top_l_8_linear_bias_golden);
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_bias_golden tensor destruction failed!");
    status = hbmFree(top_l_8_linear_bias_golden_dram, "top_l_8_linear_bias_golden");
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_bias_golden dram freeing failed!");
    status = synTensorDestroy(top_l_8_linear_bias_golden_wu_out);
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_bias_golden_wu_out tensor destruction failed!");
    status = hbmFree(top_l_8_linear_bias_golden_wu_out_dram, "top_l_8_linear_bias_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_bias_golden_wu_out dram freeing failed!");
    status = synTensorDestroy(top_l_8_linear_bias_wu_out);
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_bias_wu_out tensor destruction failed!");
    status = hbmFree(top_l_8_linear_bias_wu_out_dram, "top_l_8_linear_bias_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_8_linear_bias_wu_out dram freeing failed!");

    status = synTensorDestroy(top_l_10_linear_bias_grad_wu);
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_bias_grad_wu tensor destruction failed!");
    status = hbmFree(top_l_10_linear_bias_grad_wu_dram, "top_l_10_linear_bias_grad_wu");
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_bias_grad_wu dram freeing failed!");
    status = synTensorDestroy(top_l_10_linear_bias_golden);
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_bias_golden tensor destruction failed!");
    status = hbmFree(top_l_10_linear_bias_golden_dram, "top_l_10_linear_bias_golden");
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_bias_golden dram freeing failed!");
    status = synTensorDestroy(top_l_10_linear_bias_golden_wu_out);
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_bias_golden_wu_out tensor destruction failed!");
    status = hbmFree(top_l_10_linear_bias_golden_wu_out_dram, "top_l_10_linear_bias_golden_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_bias_golden_wu_out dram freeing failed!");
    status = synTensorDestroy(top_l_10_linear_bias_wu_out);
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_bias_wu_out tensor destruction failed!");
    status = hbmFree(top_l_10_linear_bias_wu_out_dram, "top_l_10_linear_bias_wu_out");
    ASSERT_TRUE(status == synSuccess && "top_l_10_linear_bias_wu_out dram freeing failed!");

    synRecipeDestroy(wuLaunchInfo.m_recipeHandle);
    synRecipeDestroy(dlrmLaunchInfo.m_recipeHandle);
}
